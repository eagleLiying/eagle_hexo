{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":0,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/avater.png","path":"css/images/avater.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1528294440165},{"_id":"themes/vexo/.gitignore","hash":"37fb9fd49e7f944716efd3284a6bf55adb6dd0c2","modified":1528559440000},{"_id":"themes/vexo/.travis.yml","hash":"cc482f06f4ea6962058f2548dcb814b954876e76","modified":1528559440000},{"_id":"themes/vexo/LICENSE","hash":"3e135cd69c0e02c0a49dd43d571f600223cc61d1","modified":1528559440000},{"_id":"themes/vexo/README.md","hash":"036ddc66e868b93411a15ed3fd5ed5e9101045a5","modified":1528559440000},{"_id":"themes/vexo/_config.yml","hash":"03c435d2ae54c98825e7fc99c97c78e14f2b4af4","modified":1530118072520},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1528559440000},{"_id":"themes/vexo/package.json","hash":"8852c5a394ac59d219e5bbbcee10d573d33e1fc6","modified":1528559440000},{"_id":"source/_posts/.DS_Store","hash":"c784e364dcc67a8b98fc080c7f5c34c9fd319718","modified":1530115986493},{"_id":"source/_posts/git-账户切换的怪异处理方式.md","hash":"ec09418521a17106ac5c99320447fca264aa6eb5","modified":1529774405060},{"_id":"source/_posts/gitCommand.md","hash":"f83c7236b2f8cbee7890b8dab694898b796d2c2b","modified":1529774416322},{"_id":"source/_posts/hexoGithubIo.md","hash":"9d5bca06c81c2d7d81856e8759c2c78898dabf92","modified":1530116854347},{"_id":"source/_posts/hexo-page.png","hash":"bcc8884f0fa4b9491eff8c4511d7ebc95a4d1f40","modified":1530117394969},{"_id":"source/_posts/js-继承方式.md","hash":"eabeb0139af0e332e479d21c23428392c3c75beb","modified":1529774435594},{"_id":"source/_posts/let-vs-var.md","hash":"b6b69451fcbd4875503bebe78ffae16bc95dd22f","modified":1529774441596},{"_id":"source/_posts/package-json文件.md","hash":"b29cc91ad446cd8d248fe6987dbf6b51c94a9920","modified":1529774457138},{"_id":"source/_posts/localStorage-sessionStorage.md","hash":"77b5747b5587c32cce2d0c3001269de5a7d1c859","modified":1529774449707},{"_id":"source/_posts/什么是跨域？.md","hash":"38f81261d6d53feee5bf9ba488879332fd1aceec","modified":1529774463207},{"_id":"source/_posts/解决跨域的-10-种方法.md","hash":"b0182165c743d5bfce9e972a215c328d2f1cd325","modified":1529774468891},{"_id":"source/about/index.md","hash":"2f9c503b618939cfb0dddccf08f031c829ef9aa2","modified":1530117533566},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1530114572598},{"_id":"themes/vexo/layout/about.ejs","hash":"76ba7418788eb2bb9ba46844f4d750734847d0b4","modified":1528559440000},{"_id":"themes/vexo/layout/archive.ejs","hash":"cb12abb19cb70e90d410a6233933eedb3f2c033a","modified":1528559440000},{"_id":"themes/vexo/layout/index.ejs","hash":"9f12f5928d68d4d68175b825e18f89f3b0dfdb69","modified":1528559440000},{"_id":"themes/vexo/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1528559440000},{"_id":"themes/vexo/layout/page.ejs","hash":"a886fb7e8a9d70bc971b6dfc7210d4fa2ee671c9","modified":1528559440000},{"_id":"themes/vexo/layout/project.ejs","hash":"666be5c72bac8165e0946428642b36dd3232983e","modified":1528559440000},{"_id":"themes/vexo/layout/tags.ejs","hash":"5b326e2bd3292b3015d0666b796544d7126acfda","modified":1528559440000},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1528559440000},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1528559440000},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"6032a4dcc6224ad916b7898d54e91552c17396ce","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"90334bd53e232d7b2cc5ae743b377fc5336bcd6b","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"e544f516b23bc609cc6367190f380c879b935c21","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/nav.ejs","hash":"3d8ddc1f6e135a240d40edd157cf37f5d0a12df6","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1528559440000},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1528559440000},{"_id":"themes/vexo/layout/_third-party/mathjax.ejs","hash":"aa58f0cfe22e7151c1a0521bbfa5cbd76f6dcd9d","modified":1528559440000},{"_id":"themes/vexo/source/css/.DS_Store","hash":"86806d4ca2b22f665a852d64aa29b177757f27bb","modified":1530113582746},{"_id":"themes/vexo/source/css/_config.styl","hash":"0c9c0e77d6b8813cb76494e8d757843aab9e117b","modified":1528559440000},{"_id":"themes/vexo/source/css/style.styl","hash":"c09ad049c647cc089eaf00aa59e5d5d2a7f782d4","modified":1528559440000},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1528559440000},{"_id":"themes/vexo/source/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"8a428687f74f33426bf0c7de3fdd1f7654c26587","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"e80ddf26f2af3523632afeabd57f81592537985a","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"cbf3f59d3c3162700eb9cbd4cf72c8470c170f81","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"970b6fd3d05834926c69724934b798dd5a1472e6","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"7f3f828d0107cca18c0929fd902753441ae5d3c1","modified":1530113304785},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"3ec22606f9548681389158384dc29ddf59c8ceea","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/nav.styl","hash":"e92c010c5cd460e75c67083df8cdd0bf4d25cde4","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"e9b6faadf4852bce3a4141cba0a102a7afb81e9f","modified":1528559440000},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1528559440000},{"_id":"themes/vexo/source/css/images/.DS_Store","hash":"b5eeb85efd083fb6d67b71c888b4f26ed88d5f6b","modified":1530115160481},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1528559440000},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1528559440000},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1528559440000},{"_id":"themes/vexo/source/css/images/favicon.ico","hash":"84133d0b67e264f6008e81233f0f3a37defd4af3","modified":1530113823328},{"_id":"themes/vexo/source/css/images/logo.png","hash":"c20b2395c9a2fd5e7c188bcc0676a3efbb6e6cb7","modified":1530113186642},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1528559440000},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1528559440000},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1528559440000},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1528559440000},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1528559440000},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1528559440000},{"_id":"themes/vexo/source/css/images/avater.png","hash":"56d6339a771cab60aaa71e2dc4e347c75bf6a954","modified":1530115941539},{"_id":"public/about/index.html","hash":"c0ebb11776f94c8cd1f845beb2670ba216f5c7bf","modified":1530118266658},{"_id":"public/tags/index.html","hash":"181b33b7bec8a1171371b40da42b50a47a546d5d","modified":1530118266658},{"_id":"public/2018/06/22/let-vs-var/index.html","hash":"40a2bcdd7cfad73ee11ae3ab8fd49ba0fa265a14","modified":1530118266658},{"_id":"public/2018/06/11/什么是跨域？/index.html","hash":"17f9ce77bf2ac3537b89b7c3b6fb46119ccc16b6","modified":1530118266658},{"_id":"public/2018/06/09/git-账户切换的怪异处理方式/index.html","hash":"4d92e12d9b2b99e2ff3dcb4c54720319f99eb859","modified":1530118266658},{"_id":"public/archives/index.html","hash":"0edd0f9f4084c10c5f94c7f6e15048b9ca2a911c","modified":1530118266658},{"_id":"public/archives/2018/index.html","hash":"2ebebd442eeb30d8d821895167b7c906f7dddbce","modified":1530118266659},{"_id":"public/archives/2018/06/index.html","hash":"03b935d5a831156c04bc9ab71605a859ebc85c9a","modified":1530118266659},{"_id":"public/categories/指令/index.html","hash":"892e03204f3a61c408b2d27f19971af3b233930d","modified":1530118266659},{"_id":"public/categories/环境/index.html","hash":"cd70581c446902594386c2d24f560234ce329451","modified":1530118266659},{"_id":"public/categories/js/index.html","hash":"35a6f017b6f0548b3d5743fad80b614bf4e09113","modified":1530118266659},{"_id":"public/categories/html/index.html","hash":"d2456fd4ebe96516ac1aca8111dd591276740682","modified":1530118266659},{"_id":"public/categories/json/index.html","hash":"56678d6455567326b712de4742969b13efa7e4f5","modified":1530118266659},{"_id":"public/index.html","hash":"8ebef5ddbcca0ef8ec206bbc3289336b27d2264e","modified":1530118266659},{"_id":"public/tags/git/index.html","hash":"118c2dd9f9ec9e6cd117f6fe38228f0a5c2b8167","modified":1530118266659},{"_id":"public/tags/hexo/index.html","hash":"37ba560e1184acbcc960484373de5213cf280282","modified":1530118266659},{"_id":"public/tags/js/index.html","hash":"1e1bf7dc879f43f19120fe3b9c624752260450dd","modified":1530118266659},{"_id":"public/tags/html/index.html","hash":"0b0515b9d66cd218aced09fc19f3c937f2a7126b","modified":1530118266659},{"_id":"public/tags/跨域/index.html","hash":"3cff07220539ccbcfda3da4560ecb83c9c5e5820","modified":1530118266659},{"_id":"public/tags/package-json/index.html","hash":"cd09dde17a5ca3e9f87dd5b0d43e1ae339804804","modified":1530118266660},{"_id":"public/2018/06/23/localStorage-sessionStorage/index.html","hash":"c2f0fbaf796112fe5816d3109e31af24c479326e","modified":1530118266660},{"_id":"public/2018/06/21/js-继承方式/index.html","hash":"94ebc5cd3274993835024df576555bb7f2b57a34","modified":1530118266660},{"_id":"public/2018/06/17/package-json文件/index.html","hash":"a97a0fe04e1196ca80811aedd362c7a10b2e9913","modified":1530118266660},{"_id":"public/2018/06/11/解决跨域的-10-种方法/index.html","hash":"f06e39fdad9e89a4df07607f66c19704b42fc204","modified":1530118266660},{"_id":"public/2018/06/09/gitCommand/index.html","hash":"7f81311e6678e881a2682b47851f32ddc625050d","modified":1530118266660},{"_id":"public/2018/06/06/hexoGithubIo/index.html","hash":"b7dfefbd99dd622873e41618fb6ca5a809ebcaf7","modified":1530118266660},{"_id":"public/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1530118266663},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1530118266663},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1530118266663},{"_id":"public/css/images/favicon.ico","hash":"84133d0b67e264f6008e81233f0f3a37defd4af3","modified":1530118266663},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1530118266664},{"_id":"public/css/images/logo.png","hash":"c20b2395c9a2fd5e7c188bcc0676a3efbb6e6cb7","modified":1530118266664},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1530118266664},{"_id":"public/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1530118266664},{"_id":"public/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1530118266821},{"_id":"public/css/style.css","hash":"41aeb651949e331fdc2b9a731c42a6976ee197bb","modified":1530118266821},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1530118266821},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1530118266829},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1530118266829},{"_id":"public/css/images/avater.png","hash":"56d6339a771cab60aaa71e2dc4e347c75bf6a954","modified":1530118266844},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1530118266848}],"Category":[{"name":"指令","_id":"cjixcjze900025ds6e5tq4u0h"},{"name":"环境","_id":"cjixcjzei000c5ds61n5sewlk"},{"name":"js","_id":"cjixcjzek000i5ds61uidg183"},{"name":"html","_id":"cjixcjzem000p5ds6p0zuq1t2"},{"name":"json","_id":"cjixcjzf200175ds6e3wwvy3v"}],"Data":[],"Page":[{"title":"About","type":"about","comments":0,"_content":"Eagle Li\n\n喜欢自己折腾一些感兴趣的小东西\n\n敲起代码不喜欢被打扰\n\n周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天\n\n长假想要出去走走，看看这大好的风光\n\n在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌\n\n舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万\n\n\n\n\n邮箱：liying_eagle@163.com","source":"about/index.md","raw":"title: About\ntype: \"about\"\ncomments: false\n---\nEagle Li\n\n喜欢自己折腾一些感兴趣的小东西\n\n敲起代码不喜欢被打扰\n\n周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天\n\n长假想要出去走走，看看这大好的风光\n\n在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌\n\n舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万\n\n\n\n\n邮箱：liying_eagle@163.com","date":"2018-06-27T16:38:53.566Z","updated":"2018-06-27T16:38:53.566Z","path":"about/index.html","layout":"page","_id":"cjixcjzey00155ds6hoft4ezm","content":"<p>Eagle Li</p>\n<p>喜欢自己折腾一些感兴趣的小东西</p>\n<p>敲起代码不喜欢被打扰</p>\n<p>周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天</p>\n<p>长假想要出去走走，看看这大好的风光</p>\n<p>在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌</p>\n<p>舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万</p>\n<p>邮箱：<a href=\"mailto:liying_eagle@163.com\" target=\"_blank\" rel=\"noopener\">liying_eagle@163.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Eagle Li</p>\n<p>喜欢自己折腾一些感兴趣的小东西</p>\n<p>敲起代码不喜欢被打扰</p>\n<p>周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天</p>\n<p>长假想要出去走走，看看这大好的风光</p>\n<p>在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌</p>\n<p>舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万</p>\n<p>邮箱：<a href=\"mailto:liying_eagle@163.com\" target=\"_blank\" rel=\"noopener\">liying_eagle@163.com</a></p>\n"},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2018-06-27T15:49:32.598Z","updated":"2018-06-27T15:49:32.598Z","path":"tags/index.html","comments":1,"_id":"cjixcjzf100165ds6ya5kpn0p","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"git 账户切换的怪异处理方式","date":"2018-06-09T13:44:35.000Z","_content":"\n在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”\n\n指令： ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.xx\"\n\n执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub \n在你的编辑器里打开 id_rsa.pub\n复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。\n保存之后就OK了  ：）\n","source":"_posts/git-账户切换的怪异处理方式.md","raw":"---\ntitle: git 账户切换的怪异处理方式\ndate: 2018-06-09 21:44:35\ntags: git\ncategories: 指令\n---\n\n在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”\n\n指令： ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.xx\"\n\n执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub \n在你的编辑器里打开 id_rsa.pub\n复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。\n保存之后就OK了  ：）\n","slug":"git-账户切换的怪异处理方式","published":1,"updated":"2018-06-23T17:20:05.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjze400005ds6d4tsozj7","content":"<p>在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”</p>\n<p>指令： ssh-keygen -t rsa -b 4096 -C “<a href=\"mailto:xxx@xxx.xx\" target=\"_blank\" rel=\"noopener\">xxx@xxx.xx</a>“</p>\n<p>执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub<br>在你的编辑器里打开 id_rsa.pub<br>复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。<br>保存之后就OK了  ：）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”</p>\n<p>指令： ssh-keygen -t rsa -b 4096 -C “<a href=\"mailto:xxx@xxx.xx\" target=\"_blank\" rel=\"noopener\">xxx@xxx.xx</a>“</p>\n<p>执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub<br>在你的编辑器里打开 id_rsa.pub<br>复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。<br>保存之后就OK了  ：）</p>\n"},{"title":"Git Command","date":"2018-06-09T12:51:35.000Z","_content":"\n使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：\n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 配置 git\n\n1. git 基本配置：\n\ngit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置（如果加 --global 表示设置全局）\n$ git config --list [--global]\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息 \n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n2. fork 代码库\n\n\n如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。\n```\n# 显示所有远程仓库\n$ git remote -v\n\n# 查看帮助\n$ git remote —help  \n\n# 删除 origin\n$ git remote remove origin  \n\n# 将当前的代码塞进刚建的心的项目\n$ git remote add origin [url]\n\n# 推送当前的代码到远程的 master 分支\n$ git push -u origin master\n\n# 监听版本更新:\n$ git remote add upstream [url]\n```\n### 文件管理\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 分支管理\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n### commit 管理\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 同步远程分支\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销某些操作\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 撤回上一次 commit\n$ git reset HEAD^\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。\nmerge 命令不会保留 merge 的分支的 commit\nrebase 命令会保留 merge 的分支的 commit\n\n\n```\n# 从源分支进行变基\n$ git rebase origin\n\n# 变基倒数三个 commit\n$ git rebase -i HEAD~3\n\n# 继续执行\n$ git rebase --continue\n\n# 停止变基\n$ git rebase --abort\n```","source":"_posts/gitCommand.md","raw":"---\ntitle: Git Command\ndate: 2018-06-09 20:51:35\ntags: git\ncategories: 指令\n---\n\n使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：\n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 配置 git\n\n1. git 基本配置：\n\ngit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置（如果加 --global 表示设置全局）\n$ git config --list [--global]\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息 \n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n2. fork 代码库\n\n\n如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。\n```\n# 显示所有远程仓库\n$ git remote -v\n\n# 查看帮助\n$ git remote —help  \n\n# 删除 origin\n$ git remote remove origin  \n\n# 将当前的代码塞进刚建的心的项目\n$ git remote add origin [url]\n\n# 推送当前的代码到远程的 master 分支\n$ git push -u origin master\n\n# 监听版本更新:\n$ git remote add upstream [url]\n```\n### 文件管理\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 分支管理\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n### commit 管理\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 同步远程分支\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销某些操作\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 撤回上一次 commit\n$ git reset HEAD^\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。\nmerge 命令不会保留 merge 的分支的 commit\nrebase 命令会保留 merge 的分支的 commit\n\n\n```\n# 从源分支进行变基\n$ git rebase origin\n\n# 变基倒数三个 commit\n$ git rebase -i HEAD~3\n\n# 继续执行\n$ git rebase --continue\n\n# 停止变基\n$ git rebase --abort\n```","slug":"gitCommand","published":1,"updated":"2018-06-23T17:20:16.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjze700015ds6mp7pqu7a","content":"<p>使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：</p>\n<h3 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个目录，将其初始化为Git代码库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 下载一个项目和它的整个代码历史</span><br><span class=\"line\">$ git clone [url]</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><ol>\n<li>git 基本配置：</li>\n</ol>\n<p>git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前的Git配置（如果加 --global 表示设置全局）</span><br><span class=\"line\">$ git config --list [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 编辑Git配置文件</span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置提交代码时的用户信息 </span><br><span class=\"line\">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>fork 代码库</li>\n</ol>\n<p>如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看帮助</span><br><span class=\"line\">$ git remote —help  </span><br><span class=\"line\"></span><br><span class=\"line\"># 删除 origin</span><br><span class=\"line\">$ git remote remove origin  </span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前的代码塞进刚建的心的项目</span><br><span class=\"line\">$ git remote add origin [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送当前的代码到远程的 master 分支</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"># 监听版本更新:</span><br><span class=\"line\">$ git remote add upstream [url]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加每个变化前，都会要求确认</span><br><span class=\"line\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 改名文件，并且将这个改名放入暂存区</span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class=\"line\">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-管理\"><a href=\"#commit-管理\" class=\"headerlink\" title=\"commit 管理\"></a>commit 管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区</span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit [file1] [file2] ... -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时显示所有diff信息</span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"line\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重做上一次commit，并包括指定文件的新变化</span><br><span class=\"line\">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示有变更的文件</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的版本历史</span><br><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class=\"line\">$ git log --stat</span><br><span class=\"line\"></span><br><span class=\"line\"># 搜索提交历史，根据关键词</span><br><span class=\"line\">$ git log -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class=\"line\">$ git log [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class=\"line\">$ git log [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个文件的版本历史，包括文件改名</span><br><span class=\"line\">$ git log --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件相关的每一次diff</span><br><span class=\"line\">$ git log -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示过去5次提交</span><br><span class=\"line\">$ git log -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有提交过的用户，按提交次数排序</span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件是什么人在什么时间修改过</span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和工作区的差异</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和上一个commit的差异</span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示工作区与当前分支最新commit之间的差异</span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示两次提交之间的差异</span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示今天你写了多少行代码</span><br><span class=\"line\">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交的元数据和内容变化</span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交发生变化的文件</span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交时，某个文件的内容</span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的最近几次提交</span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载远程仓库的所有变动</span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个远程仓库的信息</span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个新的远程仓库，并命名</span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 取回远程仓库的变化，并与本地分支合并</span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 上传本地指定分支到远程仓库</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销某些操作\"><a href=\"#撤销某些操作\" class=\"headerlink\" title=\"撤销某些操作\"></a>撤销某些操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 恢复暂存区的指定文件到工作区</span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复暂存区的所有文件到工作区</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 撤回上一次 commit</span><br><span class=\"line\">$ git reset HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂时将未提交的变化移除，稍后再移入</span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。<br>merge 命令不会保留 merge 的分支的 commit<br>rebase 命令会保留 merge 的分支的 commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从源分支进行变基</span><br><span class=\"line\">$ git rebase origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 变基倒数三个 commit</span><br><span class=\"line\">$ git rebase -i HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\"># 继续执行</span><br><span class=\"line\">$ git rebase --continue</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止变基</span><br><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：</p>\n<h3 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个目录，将其初始化为Git代码库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 下载一个项目和它的整个代码历史</span><br><span class=\"line\">$ git clone [url]</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><ol>\n<li>git 基本配置：</li>\n</ol>\n<p>git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前的Git配置（如果加 --global 表示设置全局）</span><br><span class=\"line\">$ git config --list [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 编辑Git配置文件</span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置提交代码时的用户信息 </span><br><span class=\"line\">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>fork 代码库</li>\n</ol>\n<p>如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看帮助</span><br><span class=\"line\">$ git remote —help  </span><br><span class=\"line\"></span><br><span class=\"line\"># 删除 origin</span><br><span class=\"line\">$ git remote remove origin  </span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前的代码塞进刚建的心的项目</span><br><span class=\"line\">$ git remote add origin [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送当前的代码到远程的 master 分支</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"># 监听版本更新:</span><br><span class=\"line\">$ git remote add upstream [url]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加每个变化前，都会要求确认</span><br><span class=\"line\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 改名文件，并且将这个改名放入暂存区</span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class=\"line\">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-管理\"><a href=\"#commit-管理\" class=\"headerlink\" title=\"commit 管理\"></a>commit 管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区</span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit [file1] [file2] ... -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时显示所有diff信息</span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"line\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重做上一次commit，并包括指定文件的新变化</span><br><span class=\"line\">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示有变更的文件</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的版本历史</span><br><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class=\"line\">$ git log --stat</span><br><span class=\"line\"></span><br><span class=\"line\"># 搜索提交历史，根据关键词</span><br><span class=\"line\">$ git log -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class=\"line\">$ git log [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class=\"line\">$ git log [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个文件的版本历史，包括文件改名</span><br><span class=\"line\">$ git log --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件相关的每一次diff</span><br><span class=\"line\">$ git log -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示过去5次提交</span><br><span class=\"line\">$ git log -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有提交过的用户，按提交次数排序</span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件是什么人在什么时间修改过</span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和工作区的差异</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和上一个commit的差异</span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示工作区与当前分支最新commit之间的差异</span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示两次提交之间的差异</span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示今天你写了多少行代码</span><br><span class=\"line\">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交的元数据和内容变化</span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交发生变化的文件</span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交时，某个文件的内容</span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的最近几次提交</span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载远程仓库的所有变动</span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个远程仓库的信息</span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个新的远程仓库，并命名</span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 取回远程仓库的变化，并与本地分支合并</span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 上传本地指定分支到远程仓库</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销某些操作\"><a href=\"#撤销某些操作\" class=\"headerlink\" title=\"撤销某些操作\"></a>撤销某些操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 恢复暂存区的指定文件到工作区</span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复暂存区的所有文件到工作区</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 撤回上一次 commit</span><br><span class=\"line\">$ git reset HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂时将未提交的变化移除，稍后再移入</span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。<br>merge 命令不会保留 merge 的分支的 commit<br>rebase 命令会保留 merge 的分支的 commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从源分支进行变基</span><br><span class=\"line\">$ git rebase origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 变基倒数三个 commit</span><br><span class=\"line\">$ git rebase -i HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\"># 继续执行</span><br><span class=\"line\">$ git rebase --continue</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止变基</span><br><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure>"},{"title":"hexo + github.io","date":"2018-06-05T16:14:18.000Z","_content":"\n### 第一步：需要的环境：\n   node环境  （[立即下载](https://nodejs.org/zh-cn/)）\n   git 环境  （[立即下载](https://git-scm.com/download/)）\n   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。\n    [安装 homebrw](https://brew.sh/)\n    [安装 yarn](https://yarnpkg.com/en/docs/install#mac-stable)\n### 第二步：安装 hexo:\n([也可以按照官方网站就行安装](https://hexo.io/zh-cn/docs/index.html))\n1. 安装 hexo\n```\n$ yarn add -g hexo-cli\n```\n2. 创建一个新的 hexo 项目\n```\n$ hexo init blog（项目名字）\ncd blog\n$ yarn install\n```\n3. 启动项目\n```\n$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000\n```\n\n项目文件结构为：\n\n<img src=\"https://raw.githubusercontent.com/eagleLiying/eagle_hexo/master/images/hexo-page.png\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"300\" />\n\n至此，我们本地的一个博客环境就已经搭建完成。\n常用的指令如下：([具体参数使用前查看详细文档](https://hexo.io/zh-cn/docs/commands.html))\n```\n$ hexo server = hexo s  // 启动项目\n$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage\n$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中\n$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）\n```\n### 第三步：更换主题\n现在为自己的博客找一个喜欢的主题：\n1. 进入[hexo 主题库](https://hexo.io/themes/)，选择一个自己喜欢的主题\n2. 点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来\n3. 将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字\n\n当前我所用的主题为 [clean-blog](https://github.com/klugjo/hexo-theme-clean-blog)\n\n### 第四步：搭建免费的 github.io 服务器\n\n首先明白什么是 github pages:\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n\n***特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的***\n\n\n1. 注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。\n\n2. 将本地环境推上线上环境，\n    1. 首先需要知道，如果直接访问 http://eagle.github.io 的时候，他会直接去找根目录下的 index.html 的静态文件。\n    2. Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问\n    3. 需要将hexo生成的静态文件，提交 commit 推到github上\n\n部署的方法一：\nhexo deploy ，可以参考 [官方的文档](https://hexo.io/docs/deployment.html)\n\n安装 hexo-deployer-git\n```\n$ yarn add hexo-deployer-git\n```\n配置：_config.xml\n```\ndeploy:\n  type: git\n  repo: git@github.com:jiji262/jiji262.github.io.git\n  branch: master\n```\n执行：\n```\n$ hexo d\n```\n\n执行之后可能会报错：\n```\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n则是因为没有设置好public key所致。\n在本机生成public key[参考github帮助](https://help.github.com/articles/connecting-to-github-with-ssh/)\n```\n$ ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\"\n```\n然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.\n然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。\n\n根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。\n\n部署方法二：\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。\n\n写一个发布脚本：deploy.sh\n```\nhexo generate\ncp -R public/* deploy/eagle.github.io\ncd deploy/eagle.github.io\ngit add .\ngit commit -m “update blog”\ngit push origin master\n```\n\n做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。\n\n至此，一个简单的博客建完  ^ - ^","source":"_posts/hexoGithubIo.md","raw":"---\ntitle: hexo + github.io\ndate: 2018-06-06 00:14:18\ntags: hexo\ncategories: 环境\n---\n\n### 第一步：需要的环境：\n   node环境  （[立即下载](https://nodejs.org/zh-cn/)）\n   git 环境  （[立即下载](https://git-scm.com/download/)）\n   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。\n    [安装 homebrw](https://brew.sh/)\n    [安装 yarn](https://yarnpkg.com/en/docs/install#mac-stable)\n### 第二步：安装 hexo:\n([也可以按照官方网站就行安装](https://hexo.io/zh-cn/docs/index.html))\n1. 安装 hexo\n```\n$ yarn add -g hexo-cli\n```\n2. 创建一个新的 hexo 项目\n```\n$ hexo init blog（项目名字）\ncd blog\n$ yarn install\n```\n3. 启动项目\n```\n$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000\n```\n\n项目文件结构为：\n\n<img src=\"https://raw.githubusercontent.com/eagleLiying/eagle_hexo/master/images/hexo-page.png\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"300\" />\n\n至此，我们本地的一个博客环境就已经搭建完成。\n常用的指令如下：([具体参数使用前查看详细文档](https://hexo.io/zh-cn/docs/commands.html))\n```\n$ hexo server = hexo s  // 启动项目\n$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage\n$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中\n$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）\n```\n### 第三步：更换主题\n现在为自己的博客找一个喜欢的主题：\n1. 进入[hexo 主题库](https://hexo.io/themes/)，选择一个自己喜欢的主题\n2. 点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来\n3. 将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字\n\n当前我所用的主题为 [clean-blog](https://github.com/klugjo/hexo-theme-clean-blog)\n\n### 第四步：搭建免费的 github.io 服务器\n\n首先明白什么是 github pages:\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n\n***特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的***\n\n\n1. 注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。\n\n2. 将本地环境推上线上环境，\n    1. 首先需要知道，如果直接访问 http://eagle.github.io 的时候，他会直接去找根目录下的 index.html 的静态文件。\n    2. Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问\n    3. 需要将hexo生成的静态文件，提交 commit 推到github上\n\n部署的方法一：\nhexo deploy ，可以参考 [官方的文档](https://hexo.io/docs/deployment.html)\n\n安装 hexo-deployer-git\n```\n$ yarn add hexo-deployer-git\n```\n配置：_config.xml\n```\ndeploy:\n  type: git\n  repo: git@github.com:jiji262/jiji262.github.io.git\n  branch: master\n```\n执行：\n```\n$ hexo d\n```\n\n执行之后可能会报错：\n```\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n则是因为没有设置好public key所致。\n在本机生成public key[参考github帮助](https://help.github.com/articles/connecting-to-github-with-ssh/)\n```\n$ ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\"\n```\n然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.\n然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。\n\n根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。\n\n部署方法二：\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。\n\n写一个发布脚本：deploy.sh\n```\nhexo generate\ncp -R public/* deploy/eagle.github.io\ncd deploy/eagle.github.io\ngit add .\ngit commit -m “update blog”\ngit push origin master\n```\n\n做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。\n\n至此，一个简单的博客建完  ^ - ^","slug":"hexoGithubIo","published":1,"updated":"2018-06-27T16:27:34.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzea00045ds6zt9hf2l3","content":"<h3 id=\"第一步：需要的环境：\"><a href=\"#第一步：需要的环境：\" class=\"headerlink\" title=\"第一步：需要的环境：\"></a>第一步：需要的环境：</h3><p>   node环境  （<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   git 环境  （<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。<br>    <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">安装 homebrw</a><br>    <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\" target=\"_blank\" rel=\"noopener\">安装 yarn</a></p>\n<h3 id=\"第二步：安装-hexo\"><a href=\"#第二步：安装-hexo\" class=\"headerlink\" title=\"第二步：安装 hexo:\"></a>第二步：安装 hexo:</h3><p>(<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">也可以按照官方网站就行安装</a>)</p>\n<ol>\n<li><p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个新的 hexo 项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog（项目名字）</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>项目文件结构为：</p>\n<p><img src=\"https://raw.githubusercontent.com/eagleLiying/eagle_hexo/master/images/hexo-page.png\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"300\"></p>\n<p>至此，我们本地的一个博客环境就已经搭建完成。<br>常用的指令如下：(<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">具体参数使用前查看详细文档</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server = hexo s  // 启动项目</span><br><span class=\"line\">$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage</span><br><span class=\"line\">$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中</span><br><span class=\"line\">$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：更换主题\"><a href=\"#第三步：更换主题\" class=\"headerlink\" title=\"第三步：更换主题\"></a>第三步：更换主题</h3><p>现在为自己的博客找一个喜欢的主题：</p>\n<ol>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo 主题库</a>，选择一个自己喜欢的主题</li>\n<li>点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来</li>\n<li>将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字</li>\n</ol>\n<p>当前我所用的主题为 <a href=\"https://github.com/klugjo/hexo-theme-clean-blog\" target=\"_blank\" rel=\"noopener\">clean-blog</a></p>\n<h3 id=\"第四步：搭建免费的-github-io-服务器\"><a href=\"#第四步：搭建免费的-github-io-服务器\" class=\"headerlink\" title=\"第四步：搭建免费的 github.io 服务器\"></a>第四步：搭建免费的 github.io 服务器</h3><p>首先明白什么是 github pages:<br>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>\n<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。</p>\n<p><strong><em>特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的</em></strong></p>\n<ol>\n<li><p>注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。</p>\n</li>\n<li><p>将本地环境推上线上环境，</p>\n<ol>\n<li>首先需要知道，如果直接访问 <a href=\"http://eagle.github.io\" target=\"_blank\" rel=\"noopener\">http://eagle.github.io</a> 的时候，他会直接去找根目录下的 index.html 的静态文件。</li>\n<li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问</li>\n<li>需要将hexo生成的静态文件，提交 commit 推到github上</li>\n</ol>\n</li>\n</ol>\n<p>部署的方法一：<br>hexo deploy ，可以参考 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">官方的文档</a></p>\n<p>安装 hexo-deployer-git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure></p>\n<p>配置：_config.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>执行之后可能会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure></p>\n<p>则是因为没有设置好public key所致。<br>在本机生成public key<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">参考github帮助</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.<br>然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。</p>\n<p>根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。</p>\n<p>部署方法二：</p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。</p>\n<p>写一个发布脚本：deploy.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* deploy/eagle.github.io</span><br><span class=\"line\">cd deploy/eagle.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “update blog”</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p>做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。</p>\n<p>至此，一个简单的博客建完  ^ - ^</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第一步：需要的环境：\"><a href=\"#第一步：需要的环境：\" class=\"headerlink\" title=\"第一步：需要的环境：\"></a>第一步：需要的环境：</h3><p>   node环境  （<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   git 环境  （<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。<br>    <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">安装 homebrw</a><br>    <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\" target=\"_blank\" rel=\"noopener\">安装 yarn</a></p>\n<h3 id=\"第二步：安装-hexo\"><a href=\"#第二步：安装-hexo\" class=\"headerlink\" title=\"第二步：安装 hexo:\"></a>第二步：安装 hexo:</h3><p>(<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">也可以按照官方网站就行安装</a>)</p>\n<ol>\n<li><p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个新的 hexo 项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog（项目名字）</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>项目文件结构为：</p>\n<p><img src=\"https://raw.githubusercontent.com/eagleLiying/eagle_hexo/master/images/hexo-page.png\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"300\"></p>\n<p>至此，我们本地的一个博客环境就已经搭建完成。<br>常用的指令如下：(<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">具体参数使用前查看详细文档</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server = hexo s  // 启动项目</span><br><span class=\"line\">$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage</span><br><span class=\"line\">$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中</span><br><span class=\"line\">$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：更换主题\"><a href=\"#第三步：更换主题\" class=\"headerlink\" title=\"第三步：更换主题\"></a>第三步：更换主题</h3><p>现在为自己的博客找一个喜欢的主题：</p>\n<ol>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo 主题库</a>，选择一个自己喜欢的主题</li>\n<li>点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来</li>\n<li>将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字</li>\n</ol>\n<p>当前我所用的主题为 <a href=\"https://github.com/klugjo/hexo-theme-clean-blog\" target=\"_blank\" rel=\"noopener\">clean-blog</a></p>\n<h3 id=\"第四步：搭建免费的-github-io-服务器\"><a href=\"#第四步：搭建免费的-github-io-服务器\" class=\"headerlink\" title=\"第四步：搭建免费的 github.io 服务器\"></a>第四步：搭建免费的 github.io 服务器</h3><p>首先明白什么是 github pages:<br>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>\n<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。</p>\n<p><strong><em>特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的</em></strong></p>\n<ol>\n<li><p>注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。</p>\n</li>\n<li><p>将本地环境推上线上环境，</p>\n<ol>\n<li>首先需要知道，如果直接访问 <a href=\"http://eagle.github.io\" target=\"_blank\" rel=\"noopener\">http://eagle.github.io</a> 的时候，他会直接去找根目录下的 index.html 的静态文件。</li>\n<li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问</li>\n<li>需要将hexo生成的静态文件，提交 commit 推到github上</li>\n</ol>\n</li>\n</ol>\n<p>部署的方法一：<br>hexo deploy ，可以参考 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">官方的文档</a></p>\n<p>安装 hexo-deployer-git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure></p>\n<p>配置：_config.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>执行之后可能会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure></p>\n<p>则是因为没有设置好public key所致。<br>在本机生成public key<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">参考github帮助</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.<br>然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。</p>\n<p>根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。</p>\n<p>部署方法二：</p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。</p>\n<p>写一个发布脚本：deploy.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* deploy/eagle.github.io</span><br><span class=\"line\">cd deploy/eagle.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “update blog”</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p>做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。</p>\n<p>至此，一个简单的博客建完  ^ - ^</p>\n"},{"title":"js 继承方式","date":"2018-06-21T15:36:41.000Z","_content":"\nJS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。\n\n需要实现继承必须现有父类，首先定义一个父类。\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1. 原型链继承\n\n核心： 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.eat('fish'));\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); //true \n\nconsole.log(cat instanceof Cat); //true\n```\n\n> 补充小知识点： \n>\n> ` object instanceof constructor ` 中:\n> \n> instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。\n\n2. 父类新增原型方法/原型属性，子类都能访问到。\n\n3. 简单，易于实现。\n\n缺点：\n\n1. 如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。\n\n2. 无法实现多继承。\n\n3. 来自原型对象的引用属性是所有实例共享的。\n\n4. 创建子类实例时，无法向父类构造函数传参。\n\n## 2、构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); // false\n\nconsole.log(cat instanceof Cat); // true\n```\n\n> 补充小知识：\n> \n> call, apply 和 bind 的区别:\n>\n> 它们在功能上是没有区别的，都是改变 ` this ` 的指向。他们主要的区别是实现方式和传递的参数不同。\n> \n> 1. call: Fun.call(object, arg1, arg2....); \n> \n> 2. apply: Fun.apply(object, [arg1, arg2....]);\n> \n> 3. bind: Fun.bind(object, arg1, arg2, ....); \n> \n> 其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2...)），Fun 接受几个参数，后面的 arg 就有几个。\n\n特点：\n\n1. 可以实现多继承（call多个父类对象）\n\n2. 创建子类实例时，可以向父类传递参数\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）\n\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n## 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n\n2. 不支持多继承\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n## 5、组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n\n2. 既是子类的实例，也是父类的实例\n\n3. 不存在引用属性共享问题\n\n4. 可传参\n\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n## 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\nCat.prototype.constructor = Cat; // 需要修复下构造函数\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\\\n```","source":"_posts/js-继承方式.md","raw":"---\ntitle: js 继承方式\ndate: 2018-06-21 23:36:41\ntags: js\ncategories: js\n---\n\nJS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。\n\n需要实现继承必须现有父类，首先定义一个父类。\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1. 原型链继承\n\n核心： 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.eat('fish'));\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); //true \n\nconsole.log(cat instanceof Cat); //true\n```\n\n> 补充小知识点： \n>\n> ` object instanceof constructor ` 中:\n> \n> instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。\n\n2. 父类新增原型方法/原型属性，子类都能访问到。\n\n3. 简单，易于实现。\n\n缺点：\n\n1. 如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。\n\n2. 无法实现多继承。\n\n3. 来自原型对象的引用属性是所有实例共享的。\n\n4. 创建子类实例时，无法向父类构造函数传参。\n\n## 2、构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); // false\n\nconsole.log(cat instanceof Cat); // true\n```\n\n> 补充小知识：\n> \n> call, apply 和 bind 的区别:\n>\n> 它们在功能上是没有区别的，都是改变 ` this ` 的指向。他们主要的区别是实现方式和传递的参数不同。\n> \n> 1. call: Fun.call(object, arg1, arg2....); \n> \n> 2. apply: Fun.apply(object, [arg1, arg2....]);\n> \n> 3. bind: Fun.bind(object, arg1, arg2, ....); \n> \n> 其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2...)），Fun 接受几个参数，后面的 arg 就有几个。\n\n特点：\n\n1. 可以实现多继承（call多个父类对象）\n\n2. 创建子类实例时，可以向父类传递参数\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）\n\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n## 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n\n2. 不支持多继承\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n## 5、组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n\n2. 既是子类的实例，也是父类的实例\n\n3. 不存在引用属性共享问题\n\n4. 可传参\n\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n## 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\nCat.prototype.constructor = Cat; // 需要修复下构造函数\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\\\n```","slug":"js-继承方式","published":1,"updated":"2018-06-23T17:20:35.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzec00055ds6zdxciyle","content":"<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。</p>\n<p>需要实现继承必须现有父类，首先定义一个父类。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h2><p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识点： </p>\n<p><code>object instanceof constructor</code> 中:</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例。</p>\n</li>\n<li><p>父类新增原型方法/原型属性，子类都能访问到。</p>\n</li>\n<li><p>简单，易于实现。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。</p>\n</li>\n<li><p>无法实现多继承。</p>\n</li>\n<li><p>来自原型对象的引用属性是所有实例共享的。</p>\n</li>\n<li><p>创建子类实例时，无法向父类构造函数传参。</p>\n</li>\n</ol>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识：</p>\n<p>call, apply 和 bind 的区别:</p>\n<p>它们在功能上是没有区别的，都是改变 <code>this</code> 的指向。他们主要的区别是实现方式和传递的参数不同。</p>\n<ol>\n<li><p>call: Fun.call(object, arg1, arg2….); </p>\n</li>\n<li><p>apply: Fun.apply(object, [arg1, arg2….]);</p>\n</li>\n<li><p>bind: Fun.bind(object, arg1, arg2, ….); </p>\n</li>\n</ol>\n<p>其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2…)），Fun 接受几个参数，后面的 arg 就有几个。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>可以实现多继承（call多个父类对象）</p>\n</li>\n<li><p>创建子类实例时，可以向父类传递参数</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）</p>\n</li>\n<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n</li>\n</ol>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例是父类的实例，不是子类的实例</p>\n</li>\n<li><p>不支持多继承</p>\n</li>\n</ol>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n</li>\n<li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n</li>\n</ol>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p>\n</li>\n<li><p>既是子类的实例，也是父类的实例</p>\n</li>\n<li><p>不存在引用属性共享问题</p>\n</li>\n<li><p>可传参</p>\n</li>\n<li><p>函数可复用</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; <span class=\"comment\">// 需要修复下构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true\\</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。</p>\n<p>需要实现继承必须现有父类，首先定义一个父类。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h2><p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识点： </p>\n<p><code>object instanceof constructor</code> 中:</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例。</p>\n</li>\n<li><p>父类新增原型方法/原型属性，子类都能访问到。</p>\n</li>\n<li><p>简单，易于实现。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。</p>\n</li>\n<li><p>无法实现多继承。</p>\n</li>\n<li><p>来自原型对象的引用属性是所有实例共享的。</p>\n</li>\n<li><p>创建子类实例时，无法向父类构造函数传参。</p>\n</li>\n</ol>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识：</p>\n<p>call, apply 和 bind 的区别:</p>\n<p>它们在功能上是没有区别的，都是改变 <code>this</code> 的指向。他们主要的区别是实现方式和传递的参数不同。</p>\n<ol>\n<li><p>call: Fun.call(object, arg1, arg2….); </p>\n</li>\n<li><p>apply: Fun.apply(object, [arg1, arg2….]);</p>\n</li>\n<li><p>bind: Fun.bind(object, arg1, arg2, ….); </p>\n</li>\n</ol>\n<p>其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2…)），Fun 接受几个参数，后面的 arg 就有几个。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>可以实现多继承（call多个父类对象）</p>\n</li>\n<li><p>创建子类实例时，可以向父类传递参数</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）</p>\n</li>\n<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n</li>\n</ol>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例是父类的实例，不是子类的实例</p>\n</li>\n<li><p>不支持多继承</p>\n</li>\n</ol>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n</li>\n<li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n</li>\n</ol>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p>\n</li>\n<li><p>既是子类的实例，也是父类的实例</p>\n</li>\n<li><p>不存在引用属性共享问题</p>\n</li>\n<li><p>可传参</p>\n</li>\n<li><p>函数可复用</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; <span class=\"comment\">// 需要修复下构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true\\</span></span><br></pre></td></tr></table></figure>"},{"title":"let、var、const","date":"2018-06-22T03:20:15.000Z","_content":"\nlet、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。\n\n## 首先来说 let 和 var 的异同。\n\n` let ` 声明的用法与 ` var ` 一致，` let ` 声明的变量可以把变量限制在作用域的代码中。\n\n1. 声明后未赋值，表现相同\n\n```\n(function() {\n  var varTest;\n  let letTest;\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 undefined\n}());\n```\n\n2. 使用未声明的变量，表现不同\n\n```\n(function() {\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 Error: letTest is not defined\n\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n}());\n```\n\n3. 不允许重复申明一个变量\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  var varTest = 'varTest changed.';\n  let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared\n\n  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)\n  console.log(letTest);\n}());\n```\n\n4. 不同作用域申明变量不一样\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  {\n    var varTest = 'varTest changed.';\n    let letTest = 'letTest changed.';\n  }\n\n  console.log(varTest); //输出\"varTest changed.\"，内部\"{}\"中声明的varTest变量覆盖外部的letTest声明\n  console.log(letTest); //输出\"test let OK.\"，内部\"{}\"中声明的letTest和外部的letTest不是同一个变量\n}());\n```\n\n## const\n\n1. ` const ` 声明的是常量，起止一旦设定后不可修改。因此，` const ` 常量声明是必须进行初始化。\n\n2.  ` const ` 声明的常量和 ` let ` 一样都有作用域的限制。\n\n3. 常量也不可以重复声明变量，无论该变量是 ` var ` 或者 ` let ` 声明的。","source":"_posts/let-vs-var.md","raw":"---\ntitle: let、var、const\ndate: 2018-06-22 11:20:15\ntags: js\ncategories: js\n---\n\nlet、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。\n\n## 首先来说 let 和 var 的异同。\n\n` let ` 声明的用法与 ` var ` 一致，` let ` 声明的变量可以把变量限制在作用域的代码中。\n\n1. 声明后未赋值，表现相同\n\n```\n(function() {\n  var varTest;\n  let letTest;\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 undefined\n}());\n```\n\n2. 使用未声明的变量，表现不同\n\n```\n(function() {\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 Error: letTest is not defined\n\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n}());\n```\n\n3. 不允许重复申明一个变量\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  var varTest = 'varTest changed.';\n  let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared\n\n  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)\n  console.log(letTest);\n}());\n```\n\n4. 不同作用域申明变量不一样\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  {\n    var varTest = 'varTest changed.';\n    let letTest = 'letTest changed.';\n  }\n\n  console.log(varTest); //输出\"varTest changed.\"，内部\"{}\"中声明的varTest变量覆盖外部的letTest声明\n  console.log(letTest); //输出\"test let OK.\"，内部\"{}\"中声明的letTest和外部的letTest不是同一个变量\n}());\n```\n\n## const\n\n1. ` const ` 声明的是常量，起止一旦设定后不可修改。因此，` const ` 常量声明是必须进行初始化。\n\n2.  ` const ` 声明的常量和 ` let ` 一样都有作用域的限制。\n\n3. 常量也不可以重复声明变量，无论该变量是 ` var ` 或者 ` let ` 声明的。","slug":"let-vs-var","published":1,"updated":"2018-06-23T17:20:41.596Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzed00065ds6xi1mgrar","content":"<p>let、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。</p>\n<h2 id=\"首先来说-let-和-var-的异同。\"><a href=\"#首先来说-let-和-var-的异同。\" class=\"headerlink\" title=\"首先来说 let 和 var 的异同。\"></a>首先来说 let 和 var 的异同。</h2><p><code>let</code> 声明的用法与 <code>var</code> 一致，<code>let</code> 声明的变量可以把变量限制在作用域的代码中。</p>\n<ol>\n<li>声明后未赋值，表现相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest;</span><br><span class=\"line\">  let letTest;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 undefined</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用未声明的变量，表现不同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 Error: letTest is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>不允许重复申明一个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">  let letTest = &apos;letTest changed.&apos;; //直接报错：SyntaxError: Identifier &apos;letTest&apos; has already been declared</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span><br><span class=\"line\">  console.log(letTest);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不同作用域申明变量不一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">    let letTest = &apos;letTest changed.&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明</span><br><span class=\"line\">  console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><p><code>const</code> 声明的是常量，起止一旦设定后不可修改。因此，<code>const</code> 常量声明是必须进行初始化。</p>\n</li>\n<li><p><code>const</code> 声明的常量和 <code>let</code> 一样都有作用域的限制。</p>\n</li>\n<li><p>常量也不可以重复声明变量，无论该变量是 <code>var</code> 或者 <code>let</code> 声明的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>let、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。</p>\n<h2 id=\"首先来说-let-和-var-的异同。\"><a href=\"#首先来说-let-和-var-的异同。\" class=\"headerlink\" title=\"首先来说 let 和 var 的异同。\"></a>首先来说 let 和 var 的异同。</h2><p><code>let</code> 声明的用法与 <code>var</code> 一致，<code>let</code> 声明的变量可以把变量限制在作用域的代码中。</p>\n<ol>\n<li>声明后未赋值，表现相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest;</span><br><span class=\"line\">  let letTest;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 undefined</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用未声明的变量，表现不同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 Error: letTest is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>不允许重复申明一个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">  let letTest = &apos;letTest changed.&apos;; //直接报错：SyntaxError: Identifier &apos;letTest&apos; has already been declared</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span><br><span class=\"line\">  console.log(letTest);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不同作用域申明变量不一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">    let letTest = &apos;letTest changed.&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明</span><br><span class=\"line\">  console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><p><code>const</code> 声明的是常量，起止一旦设定后不可修改。因此，<code>const</code> 常量声明是必须进行初始化。</p>\n</li>\n<li><p><code>const</code> 声明的常量和 <code>let</code> 一样都有作用域的限制。</p>\n</li>\n<li><p>常量也不可以重复声明变量，无论该变量是 <code>var</code> 或者 <code>let</code> 声明的。</p>\n</li>\n</ol>\n"},{"title":"cookie、localStorage 和 sessionStorage","date":"2018-06-23T14:23:28.000Z","_content":"\n### Cookie\n\ncookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n### LocalStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。\n\nlocalStorage的优势\n\n1、localStorage 拓展了cookie 的 4K 限制\n\n2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\nlocalStorage的局限\n\n1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n\n2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n\n3、localStorage在浏览器的隐私模式下面是不可读取的\n\n4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n\n5、localStorage不能被爬虫抓取到\n\n### SessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n### 三者的异同\n\n特性 | Cookie | localStorage | sessionStorage\n---- | --- | --- | ---\n数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除\n存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB\n与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信\n易用性\t | 需要程序员自己封装，源生的Cookie接口不友好\t | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n### 使用\n\n#### 1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\n\n```js\nif(window.localStorage){\n    alert(\"浏览支持localStorage\")\n}else{\n   alert(\"浏览暂不支持localStorage\")\n}\n\n//或者\nif(typeof window.localStorage == 'undefined'){\n    alert(\"浏览暂不支持localStorage\")\n}\n```\n\n#### 2. setItem 存储数据 value（将value存储到key字段）\n\nlocalStorage 只支持 string 类型的存储。\n\n这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage\n\n```js\n<!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 -->\n\nconst storage=window.localStorage;\n\n// 存储数据方法一\nstorage[\"a\"]=1;\n\n// 存储数据方法二\nstorage.a=1;\n\n// 存储数据方法三（官方支持）\nlocalStorage.setItem(\"site\", \"js8.in\");\n\nsessionStorage.setItem(\"key\", \"value\");\n\nconsole.log(typeof storage[\"a\"]);  // 输出：string，原本存入的值是 int 类型，输出的是 string\nconsole.log(typeof storage[\"b\"]);  // 输出：string\nconsole.log(typeof storage[\"c\"]);  // 输出：string\n```\n\n#### 3. getItem 获取 value（获取指定key本地存储的值）\n\n```js\nconst value = sessionStorage.getItem(\"key\");\nconst site = localStorage.getItem(\"site\");\n```\n\n#### 4. removeItem 删除 key（删除指定key本地存储的值）\n\n```js\nsessionStorage.removeItem(\"key\");\nlocalStorage.removeItem(\"site\");\n```\n\nclear 清除所有的 key/value\n\n```js\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n","source":"_posts/localStorage-sessionStorage.md","raw":"---\ntitle: cookie、localStorage 和 sessionStorage\ndate: 2018-06-23 22:23:28\ntags: html\ncategories: html\n---\n\n### Cookie\n\ncookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n### LocalStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。\n\nlocalStorage的优势\n\n1、localStorage 拓展了cookie 的 4K 限制\n\n2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\nlocalStorage的局限\n\n1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n\n2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n\n3、localStorage在浏览器的隐私模式下面是不可读取的\n\n4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n\n5、localStorage不能被爬虫抓取到\n\n### SessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n### 三者的异同\n\n特性 | Cookie | localStorage | sessionStorage\n---- | --- | --- | ---\n数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除\n存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB\n与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信\n易用性\t | 需要程序员自己封装，源生的Cookie接口不友好\t | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n### 使用\n\n#### 1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\n\n```js\nif(window.localStorage){\n    alert(\"浏览支持localStorage\")\n}else{\n   alert(\"浏览暂不支持localStorage\")\n}\n\n//或者\nif(typeof window.localStorage == 'undefined'){\n    alert(\"浏览暂不支持localStorage\")\n}\n```\n\n#### 2. setItem 存储数据 value（将value存储到key字段）\n\nlocalStorage 只支持 string 类型的存储。\n\n这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage\n\n```js\n<!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 -->\n\nconst storage=window.localStorage;\n\n// 存储数据方法一\nstorage[\"a\"]=1;\n\n// 存储数据方法二\nstorage.a=1;\n\n// 存储数据方法三（官方支持）\nlocalStorage.setItem(\"site\", \"js8.in\");\n\nsessionStorage.setItem(\"key\", \"value\");\n\nconsole.log(typeof storage[\"a\"]);  // 输出：string，原本存入的值是 int 类型，输出的是 string\nconsole.log(typeof storage[\"b\"]);  // 输出：string\nconsole.log(typeof storage[\"c\"]);  // 输出：string\n```\n\n#### 3. getItem 获取 value（获取指定key本地存储的值）\n\n```js\nconst value = sessionStorage.getItem(\"key\");\nconst site = localStorage.getItem(\"site\");\n```\n\n#### 4. removeItem 删除 key（删除指定key本地存储的值）\n\n```js\nsessionStorage.removeItem(\"key\");\nlocalStorage.removeItem(\"site\");\n```\n\nclear 清除所有的 key/value\n\n```js\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n","slug":"localStorage-sessionStorage","published":1,"updated":"2018-06-23T17:20:49.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzef000a5ds6vzcabgss","content":"<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>cookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。</p>\n<p>localStorage的优势</p>\n<p>1、localStorage 拓展了cookie 的 4K 限制</p>\n<p>2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>\n<p>localStorage的局限</p>\n<p>1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</p>\n<p>2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</p>\n<p>3、localStorage在浏览器的隐私模式下面是不可读取的</p>\n<p>4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>\n<p>5、localStorage不能被爬虫抓取到</p>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<h3 id=\"三者的异同\"><a href=\"#三者的异同\" class=\"headerlink\" title=\"三者的异同\"></a>三者的异同</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>一般为5MB</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\"><a href=\"#1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\" class=\"headerlink\" title=\"1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\"></a>1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.localStorage)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览支持localStorage\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.localStorage == <span class=\"string\">'undefined'</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-setItem-存储数据-value（将value存储到key字段）\"><a href=\"#2-setItem-存储数据-value（将value存储到key字段）\" class=\"headerlink\" title=\"2. setItem 存储数据 value（将value存储到key字段）\"></a>2. setItem 存储数据 value（将value存储到key字段）</h4><p>localStorage 只支持 string 类型的存储。</p>\n<p>这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage=<span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法一</span></span><br><span class=\"line\">storage[<span class=\"string\">\"a\"</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法二</span></span><br><span class=\"line\">storage.a=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法三（官方支持）</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">\"site\"</span>, <span class=\"string\">\"js8.in\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage.setItem(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"a\"</span>]);  <span class=\"comment\">// 输出：string，原本存入的值是 int 类型，输出的是 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"b\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"c\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-getItem-获取-value（获取指定key本地存储的值）\"><a href=\"#3-getItem-获取-value（获取指定key本地存储的值）\" class=\"headerlink\" title=\"3. getItem 获取 value（获取指定key本地存储的值）\"></a>3. getItem 获取 value（获取指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = sessionStorage.getItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> site = localStorage.getItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-removeItem-删除-key（删除指定key本地存储的值）\"><a href=\"#4-removeItem-删除-key（删除指定key本地存储的值）\" class=\"headerlink\" title=\"4. removeItem 删除 key（删除指定key本地存储的值）\"></a>4. removeItem 删除 key（删除指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<p>clear 清除所有的 key/value</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>cookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。</p>\n<p>localStorage的优势</p>\n<p>1、localStorage 拓展了cookie 的 4K 限制</p>\n<p>2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>\n<p>localStorage的局限</p>\n<p>1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</p>\n<p>2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</p>\n<p>3、localStorage在浏览器的隐私模式下面是不可读取的</p>\n<p>4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>\n<p>5、localStorage不能被爬虫抓取到</p>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<h3 id=\"三者的异同\"><a href=\"#三者的异同\" class=\"headerlink\" title=\"三者的异同\"></a>三者的异同</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>一般为5MB</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\"><a href=\"#1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\" class=\"headerlink\" title=\"1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\"></a>1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.localStorage)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览支持localStorage\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.localStorage == <span class=\"string\">'undefined'</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-setItem-存储数据-value（将value存储到key字段）\"><a href=\"#2-setItem-存储数据-value（将value存储到key字段）\" class=\"headerlink\" title=\"2. setItem 存储数据 value（将value存储到key字段）\"></a>2. setItem 存储数据 value（将value存储到key字段）</h4><p>localStorage 只支持 string 类型的存储。</p>\n<p>这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage=<span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法一</span></span><br><span class=\"line\">storage[<span class=\"string\">\"a\"</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法二</span></span><br><span class=\"line\">storage.a=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法三（官方支持）</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">\"site\"</span>, <span class=\"string\">\"js8.in\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage.setItem(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"a\"</span>]);  <span class=\"comment\">// 输出：string，原本存入的值是 int 类型，输出的是 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"b\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"c\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-getItem-获取-value（获取指定key本地存储的值）\"><a href=\"#3-getItem-获取-value（获取指定key本地存储的值）\" class=\"headerlink\" title=\"3. getItem 获取 value（获取指定key本地存储的值）\"></a>3. getItem 获取 value（获取指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = sessionStorage.getItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> site = localStorage.getItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-removeItem-删除-key（删除指定key本地存储的值）\"><a href=\"#4-removeItem-删除-key（删除指定key本地存储的值）\" class=\"headerlink\" title=\"4. removeItem 删除 key（删除指定key本地存储的值）\"></a>4. removeItem 删除 key（删除指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<p>clear 清除所有的 key/value</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n"},{"title":"什么是跨域？","date":"2018-06-11T14:12:53.000Z","_content":"\n简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法\n\n看如下例子：\n\n1. 同一域名下  【允许通信】\nhttp://www.a.com/a.js\nhttp://www.a.com/b.js\n\n2. 同一域名下不同文件夹  【允许通信】\nhttp://www.a.com/lab/a.js\nhttp://www.a.com/script/b.js\n\n3. 同一域名，不同端口  【不允许通信】\nhttp://www.a.com:8000/a.js\nhttp://www.a.com/b.js\n\n4. 同一域名，不同协议  【不允许通信】\nhttp://www.a.com/a.js\nhttps://www.a.com/b.js\n\n5. 域名和域名对应ip 【不允许通信】\nhttp://www.a.com/a.js\nhttp://70.32.92.74/b.js\n\n6. 主域相同，子域不同 【不允许通信】\nhttp://www.a.com/a.js\nhttp://script.a.com/b.js\n\n7. 同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】\nhttp://www.a.com/a.js\nhttp://a.com/b.js\n\n8. 不同域名 【不允许通信】\nhttp://www.cnblogs.com/a.js\nhttp://www.a.com/b.js\n\n\n#### 同源策略（same-origin policy）\n同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。\n\n\n原文链接：http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\n","source":"_posts/什么是跨域？.md","raw":"---\ntitle: 什么是跨域？\ndate: 2018-06-11 22:12:53\ntags: 跨域\ncategories: js\n---\n\n简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法\n\n看如下例子：\n\n1. 同一域名下  【允许通信】\nhttp://www.a.com/a.js\nhttp://www.a.com/b.js\n\n2. 同一域名下不同文件夹  【允许通信】\nhttp://www.a.com/lab/a.js\nhttp://www.a.com/script/b.js\n\n3. 同一域名，不同端口  【不允许通信】\nhttp://www.a.com:8000/a.js\nhttp://www.a.com/b.js\n\n4. 同一域名，不同协议  【不允许通信】\nhttp://www.a.com/a.js\nhttps://www.a.com/b.js\n\n5. 域名和域名对应ip 【不允许通信】\nhttp://www.a.com/a.js\nhttp://70.32.92.74/b.js\n\n6. 主域相同，子域不同 【不允许通信】\nhttp://www.a.com/a.js\nhttp://script.a.com/b.js\n\n7. 同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】\nhttp://www.a.com/a.js\nhttp://a.com/b.js\n\n8. 不同域名 【不允许通信】\nhttp://www.cnblogs.com/a.js\nhttp://www.a.com/b.js\n\n\n#### 同源策略（same-origin policy）\n同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。\n\n\n原文链接：http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\n","slug":"什么是跨域？","published":1,"updated":"2018-06-23T17:21:03.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzeh000b5ds6wtcilsgj","content":"<p>简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法</p>\n<p>看如下例子：</p>\n<ol>\n<li><p>同一域名下  【允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名下不同文件夹  【允许通信】<br><a href=\"http://www.a.com/lab/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/lab/a.js</a><br><a href=\"http://www.a.com/script/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/script/b.js</a></p>\n</li>\n<li><p>同一域名，不同端口  【不允许通信】<br><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同协议  【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"https://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">https://www.a.com/b.js</a></p>\n</li>\n<li><p>域名和域名对应ip 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://70.32.92.74/b.js\" target=\"_blank\" rel=\"noopener\">http://70.32.92.74/b.js</a></p>\n</li>\n<li><p>主域相同，子域不同 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://script.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://script.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://a.com/b.js</a></p>\n</li>\n<li><p>不同域名 【不允许通信】<br><a href=\"http://www.cnblogs.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n</ol>\n<h4 id=\"同源策略（same-origin-policy）\"><a href=\"#同源策略（same-origin-policy）\" class=\"headerlink\" title=\"同源策略（same-origin policy）\"></a>同源策略（same-origin policy）</h4><p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法</p>\n<p>看如下例子：</p>\n<ol>\n<li><p>同一域名下  【允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名下不同文件夹  【允许通信】<br><a href=\"http://www.a.com/lab/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/lab/a.js</a><br><a href=\"http://www.a.com/script/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/script/b.js</a></p>\n</li>\n<li><p>同一域名，不同端口  【不允许通信】<br><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同协议  【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"https://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">https://www.a.com/b.js</a></p>\n</li>\n<li><p>域名和域名对应ip 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://70.32.92.74/b.js\" target=\"_blank\" rel=\"noopener\">http://70.32.92.74/b.js</a></p>\n</li>\n<li><p>主域相同，子域不同 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://script.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://script.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://a.com/b.js</a></p>\n</li>\n<li><p>不同域名 【不允许通信】<br><a href=\"http://www.cnblogs.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n</ol>\n<h4 id=\"同源策略（same-origin-policy）\"><a href=\"#同源策略（same-origin-policy）\" class=\"headerlink\" title=\"同源策略（same-origin policy）\"></a>同源策略（same-origin policy）</h4><p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html</a></p>\n"},{"title":"解决跨域的 10 种方法","date":"2018-06-11T14:40:49.000Z","_content":"\n## 单向跨域\n\n### 一、 JSONP（JSON with Padding）\n\nhtml中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源\n\n例子：\n【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数\n\n优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。\n缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。\n\n### 二、flash URLloader\n\nflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。\n\n例子：\n从域 www.a.com 请求域 www.b.com 上的数据，我们可以借助 flash 来发送 HTTP 请求。\n1. 修改域 www.b.com 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 www.a.com 加入到白名单。\n2. 通过 Flash URLLoader 发送 HTTP 请求。\n3. 通过 Flash API 把响应结果传递给 JavaScript。\n\n缺点：不支持 IOS\n\n### 三、Access Control\n\nAccess Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。\n\n例子：\nwww.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\n\n缺点：目前只在很少的浏览器中得以支持，\n\n\n### 四、window.name\n\nwindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。\n\n例子：\n在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。\n\n优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。\n\n### 五、server proxy\n\n在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。\n\n例子：\n当 www.a.com 域下的页面需要请求 www.b.com 下的资源文件 asset.txt 时，直接发送一个指向 www.b.com/asset.txt 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 www.a.com 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 www.a.com/proxy/ , 然后这个代理发送 HTTP 请求访问 www.b.com 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。\n\n注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。\n\n## 双向跨域\n\n### 一、document.domain\n\n通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。\n\n例子：\n同域策略认为域和子域隶属于不同的域，比如 www.a.com 和 sub.a.com 是不同的域，这时，我们无法在 www.a.com 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。\n\n### 二、FIM – Fragment Identitier Messaging\n\n不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。\nFIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。\n\n### 三、Flash LocalConnection\n\n页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。\n\n### 四、window.postMessage\n\nwindow.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。\n\n### 五、Cross Frame\n\nCross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 www.a.com 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 www.b.com 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。\n\n不同的跨域请求可以使用不同的方式解决\n\n原文链接：http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html","source":"_posts/解决跨域的-10-种方法.md","raw":"---\ntitle: 解决跨域的 10 种方法\ndate: 2018-06-11 22:40:49\ntags: 跨域\ncategories: js\n---\n\n## 单向跨域\n\n### 一、 JSONP（JSON with Padding）\n\nhtml中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源\n\n例子：\n【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数\n\n优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。\n缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。\n\n### 二、flash URLloader\n\nflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。\n\n例子：\n从域 www.a.com 请求域 www.b.com 上的数据，我们可以借助 flash 来发送 HTTP 请求。\n1. 修改域 www.b.com 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 www.a.com 加入到白名单。\n2. 通过 Flash URLLoader 发送 HTTP 请求。\n3. 通过 Flash API 把响应结果传递给 JavaScript。\n\n缺点：不支持 IOS\n\n### 三、Access Control\n\nAccess Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。\n\n例子：\nwww.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\n\n缺点：目前只在很少的浏览器中得以支持，\n\n\n### 四、window.name\n\nwindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。\n\n例子：\n在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。\n\n优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。\n\n### 五、server proxy\n\n在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。\n\n例子：\n当 www.a.com 域下的页面需要请求 www.b.com 下的资源文件 asset.txt 时，直接发送一个指向 www.b.com/asset.txt 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 www.a.com 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 www.a.com/proxy/ , 然后这个代理发送 HTTP 请求访问 www.b.com 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。\n\n注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。\n\n## 双向跨域\n\n### 一、document.domain\n\n通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。\n\n例子：\n同域策略认为域和子域隶属于不同的域，比如 www.a.com 和 sub.a.com 是不同的域，这时，我们无法在 www.a.com 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。\n\n### 二、FIM – Fragment Identitier Messaging\n\n不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。\nFIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。\n\n### 三、Flash LocalConnection\n\n页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。\n\n### 四、window.postMessage\n\nwindow.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。\n\n### 五、Cross Frame\n\nCross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 www.a.com 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 www.b.com 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。\n\n不同的跨域请求可以使用不同的方式解决\n\n原文链接：http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html","slug":"解决跨域的-10-种方法","published":1,"updated":"2018-06-23T17:21:08.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzej000g5ds610ah8752","content":"<h2 id=\"单向跨域\"><a href=\"#单向跨域\" class=\"headerlink\" title=\"单向跨域\"></a>单向跨域</h2><h3 id=\"一、-JSONP（JSON-with-Padding）\"><a href=\"#一、-JSONP（JSON-with-Padding）\" class=\"headerlink\" title=\"一、 JSONP（JSON with Padding）\"></a>一、 JSONP（JSON with Padding）</h3><p>html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源</p>\n<p>例子：<br>【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数</p>\n<p>优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。<br>缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。</p>\n<h3 id=\"二、flash-URLloader\"><a href=\"#二、flash-URLloader\" class=\"headerlink\" title=\"二、flash URLloader\"></a>二、flash URLloader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>\n<p>例子：<br>从域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 请求域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的数据，我们可以借助 flash 来发送 HTTP 请求。</p>\n<ol>\n<li>修改域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 加入到白名单。</li>\n<li>通过 Flash URLLoader 发送 HTTP 请求。</li>\n<li>通过 Flash API 把响应结果传递给 JavaScript。</li>\n</ol>\n<p>缺点：不支持 IOS</p>\n<h3 id=\"三、Access-Control\"><a href=\"#三、Access-Control\" class=\"headerlink\" title=\"三、Access Control\"></a>三、Access Control</h3><p>Access Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。</p>\n<p>例子：<br><a href=\"http://www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\" target=\"_blank\" rel=\"noopener\">www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头</a></p>\n<p>缺点：目前只在很少的浏览器中得以支持，</p>\n<h3 id=\"四、window-name\"><a href=\"#四、window-name\" class=\"headerlink\" title=\"四、window.name\"></a>四、window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。</p>\n<p>例子：<br>在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。</p>\n<p>优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。</p>\n<h3 id=\"五、server-proxy\"><a href=\"#五、server-proxy\" class=\"headerlink\" title=\"五、server proxy\"></a>五、server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>\n<p>例子：<br>当 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 域下的页面需要请求 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的资源文件 asset.txt 时，直接发送一个指向 <a href=\"http://www.b.com/asset.txt\" target=\"_blank\" rel=\"noopener\">www.b.com/asset.txt</a> 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 <a href=\"http://www.a.com/proxy/\" target=\"_blank\" rel=\"noopener\">www.a.com/proxy/</a> , 然后这个代理发送 HTTP 请求访问 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。</p>\n<p>注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</p>\n<h2 id=\"双向跨域\"><a href=\"#双向跨域\" class=\"headerlink\" title=\"双向跨域\"></a>双向跨域</h2><h3 id=\"一、document-domain\"><a href=\"#一、document-domain\" class=\"headerlink\" title=\"一、document.domain\"></a>一、document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。</p>\n<p>例子：<br>同域策略认为域和子域隶属于不同的域，比如 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 和 sub.a.com 是不同的域，这时，我们无法在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。</p>\n<h3 id=\"二、FIM-–-Fragment-Identitier-Messaging\"><a href=\"#二、FIM-–-Fragment-Identitier-Messaging\" class=\"headerlink\" title=\"二、FIM – Fragment Identitier Messaging\"></a>二、FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。<br>FIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。</p>\n<h3 id=\"三、Flash-LocalConnection\"><a href=\"#三、Flash-LocalConnection\" class=\"headerlink\" title=\"三、Flash LocalConnection\"></a>三、Flash LocalConnection</h3><p>页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。</p>\n<h3 id=\"四、window-postMessage\"><a href=\"#四、window-postMessage\" class=\"headerlink\" title=\"四、window.postMessage\"></a>四、window.postMessage</h3><p>window.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>\n<h3 id=\"五、Cross-Frame\"><a href=\"#五、Cross-Frame\" class=\"headerlink\" title=\"五、Cross Frame\"></a>五、Cross Frame</h3><p>Cross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。</p>\n<p>不同的跨域请求可以使用不同的方式解决</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单向跨域\"><a href=\"#单向跨域\" class=\"headerlink\" title=\"单向跨域\"></a>单向跨域</h2><h3 id=\"一、-JSONP（JSON-with-Padding）\"><a href=\"#一、-JSONP（JSON-with-Padding）\" class=\"headerlink\" title=\"一、 JSONP（JSON with Padding）\"></a>一、 JSONP（JSON with Padding）</h3><p>html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源</p>\n<p>例子：<br>【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数</p>\n<p>优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。<br>缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。</p>\n<h3 id=\"二、flash-URLloader\"><a href=\"#二、flash-URLloader\" class=\"headerlink\" title=\"二、flash URLloader\"></a>二、flash URLloader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>\n<p>例子：<br>从域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 请求域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的数据，我们可以借助 flash 来发送 HTTP 请求。</p>\n<ol>\n<li>修改域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 加入到白名单。</li>\n<li>通过 Flash URLLoader 发送 HTTP 请求。</li>\n<li>通过 Flash API 把响应结果传递给 JavaScript。</li>\n</ol>\n<p>缺点：不支持 IOS</p>\n<h3 id=\"三、Access-Control\"><a href=\"#三、Access-Control\" class=\"headerlink\" title=\"三、Access Control\"></a>三、Access Control</h3><p>Access Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。</p>\n<p>例子：<br><a href=\"http://www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\" target=\"_blank\" rel=\"noopener\">www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头</a></p>\n<p>缺点：目前只在很少的浏览器中得以支持，</p>\n<h3 id=\"四、window-name\"><a href=\"#四、window-name\" class=\"headerlink\" title=\"四、window.name\"></a>四、window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。</p>\n<p>例子：<br>在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。</p>\n<p>优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。</p>\n<h3 id=\"五、server-proxy\"><a href=\"#五、server-proxy\" class=\"headerlink\" title=\"五、server proxy\"></a>五、server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>\n<p>例子：<br>当 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 域下的页面需要请求 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的资源文件 asset.txt 时，直接发送一个指向 <a href=\"http://www.b.com/asset.txt\" target=\"_blank\" rel=\"noopener\">www.b.com/asset.txt</a> 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 <a href=\"http://www.a.com/proxy/\" target=\"_blank\" rel=\"noopener\">www.a.com/proxy/</a> , 然后这个代理发送 HTTP 请求访问 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。</p>\n<p>注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</p>\n<h2 id=\"双向跨域\"><a href=\"#双向跨域\" class=\"headerlink\" title=\"双向跨域\"></a>双向跨域</h2><h3 id=\"一、document-domain\"><a href=\"#一、document-domain\" class=\"headerlink\" title=\"一、document.domain\"></a>一、document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。</p>\n<p>例子：<br>同域策略认为域和子域隶属于不同的域，比如 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 和 sub.a.com 是不同的域，这时，我们无法在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。</p>\n<h3 id=\"二、FIM-–-Fragment-Identitier-Messaging\"><a href=\"#二、FIM-–-Fragment-Identitier-Messaging\" class=\"headerlink\" title=\"二、FIM – Fragment Identitier Messaging\"></a>二、FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。<br>FIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。</p>\n<h3 id=\"三、Flash-LocalConnection\"><a href=\"#三、Flash-LocalConnection\" class=\"headerlink\" title=\"三、Flash LocalConnection\"></a>三、Flash LocalConnection</h3><p>页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。</p>\n<h3 id=\"四、window-postMessage\"><a href=\"#四、window-postMessage\" class=\"headerlink\" title=\"四、window.postMessage\"></a>四、window.postMessage</h3><p>window.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>\n<h3 id=\"五、Cross-Frame\"><a href=\"#五、Cross-Frame\" class=\"headerlink\" title=\"五、Cross Frame\"></a>五、Cross Frame</h3><p>Cross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。</p>\n<p>不同的跨域请求可以使用不同的方式解决</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html</a></p>\n"},{"title":"package.json 文件","date":"2018-06-17T14:52:04.000Z","_content":"\n一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 ` npm install ` 会根据这个配置文件自动下载所需模块。\n\n### name\n\n项目的名字\n\n规则：\n 1. 该名称必须小于或等于214个字符。\n 2. 名称不能以点或下划线开头。\n 3. 新包名称中不能包含大写字母。\n 4. 该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。\n\n技巧\n 1. 不要使用与核心节点模块相同的名称。\n 2. 不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）\n 3. 这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。\n 4. 你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。[https://www.npmjs.com/](https://www.npmjs.com/)\n\n 名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 [npm-scope](https://docs.npmjs.com/misc/scope)查看更多\n\n### description\n\n在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search\n\n### version\n\n如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。\n\n版本必须可以由 [node-semver](https://docs.npmjs.com/misc/semver) 解析\n\n### keywords\n\n把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。\n\n### homepage\n\n项目首页的网址\n\n### bugs\n\n如果项目有问题，可以提交的问题的邮箱和 url。\n例如：\n```\n{ \"url\" : \"https://github.com/owner/project/issues\",\n  \"email\" : \"project@hostname.com\"\n}\n```\n\n可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 ` npm bugs ` 命令使用。\n\n### license\n\n项目包的许可证，可以让别人知道你的项目包的限制。[查看详情](https://docs.npmjs.com/files/package.json)\n\n### people fields: author, contributors  \n\nauthor 是一个人，contributors 是一群人。人具有 url 和 email 。\n\n### files\n\n\"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）\n你也可以在模块根目录下创建一个\".npmignore\"文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。\n\n容易被忽略的文件：\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json （改用shrinkwrap）\n\n### main\n\n程序的主要入口，这应该是相对于包文件夹根目录的模块ID。\n\n### browser\n\n如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）\n\n### bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）\n如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n例如：\n```\n{ \"bin\" : { \"myapp\" : \"./cli.js\" } }\n```\n\n模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。\n如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n```\n{ \n    \"name\": \"my-program\",\n    \"version\": \"1.2.5\",\n    \"bin\": \"./path/to/program\",\n}\n```\n\n### man\n\n制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。\n如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : \"./man/doc.1\"\n}\n```\n\n通过 man foo 命令会得到 ./man/doc.1 文件的内容。\n如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ]\n}\n```\n\n会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。\nman文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ]\n}\n```\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n### directories\n\nCommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。\n目前这个配置没有任何作用。\n\ndirectories.lib\n告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\ndirectories.bin\n如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。\n\ndirectories.man\n指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。\n\ndirectories.doc\n在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）\n\ndirectories.example\n放一些示例脚本，或许某一天会有用 - -！\n\n### repository\n\n代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 ` npm docs ` 命令将能够找到你的项目\n\n例如：\n```\n\"repository\" :\n  { \n      \"type\" : \"git\",\n      \"url\" : \"https://github.com/npm/npm.git\"\n  }\n\n\"repository\" :\n  { \n    \"type\" : \"svn\",\n    \"url\" : \"https://v8.googlecode.com/svn/trunk/\"\n  }\n```\n\n该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。\n\n对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法\n\n### scripts\n\n“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。\n[npm-scripts 查看更多](https://docs.npmjs.com/misc/scripts)\n\n### config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。\n用户用的时候可以使用如下用法：\n```\nhttp.createServer(...).listen(process.env.npm_package_config_port) \n```\n\n可以通过npm config set foo:port 80来修改config:\n```\n{ \n    \"name\" : \"foo\",\n    \"config\" : { \"port\" : \"8080\" }\n}\n```\n\n### dependencies 和 devDependencies\n\ndependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。\n它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n对应的版本可以加上各种限定，主要有以下几种：\n\n指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n> 1. 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n> \n> 2. 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n> \n> 3. latest：安装最新版本。\n\npackage.json 文件可以手工编写，也可以使用 ` npm init ` 命令自动生成。项目名称（name）和项目版本（version）是必填的\n\n通过指令安装：\n```\n$ npm install express --save\n$ npm install express --save-dev\n```\n\n` --save ` 参数表示将该模块写入 dependencies 属性\n` --save-dev ` 表示将该模块写入 devDependencies 属性。\n\n### peerDependencies\n\n有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。\n\n大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\n\npeerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。\n\n例如：\n```\n{\n  \"name\": \"tea-latte\",\n  \"version\": \"1.3.5\",\n  \"peerDependencies\": {\n    \"tea\": \"2.x\"\n  }\n}\n```\n\n这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：\n```\n├── tea-latte@1.3.5\n└── tea@2.2.0\n```\n\n注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。\n\n### preferGlobal\n\npreferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n\n### style\n\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。","source":"_posts/package-json文件.md","raw":"---\ntitle: package.json 文件\ndate: 2018-06-17 22:52:04\ntags: package.json\ncategories: json\n---\n\n一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 ` npm install ` 会根据这个配置文件自动下载所需模块。\n\n### name\n\n项目的名字\n\n规则：\n 1. 该名称必须小于或等于214个字符。\n 2. 名称不能以点或下划线开头。\n 3. 新包名称中不能包含大写字母。\n 4. 该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。\n\n技巧\n 1. 不要使用与核心节点模块相同的名称。\n 2. 不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）\n 3. 这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。\n 4. 你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。[https://www.npmjs.com/](https://www.npmjs.com/)\n\n 名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 [npm-scope](https://docs.npmjs.com/misc/scope)查看更多\n\n### description\n\n在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search\n\n### version\n\n如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。\n\n版本必须可以由 [node-semver](https://docs.npmjs.com/misc/semver) 解析\n\n### keywords\n\n把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。\n\n### homepage\n\n项目首页的网址\n\n### bugs\n\n如果项目有问题，可以提交的问题的邮箱和 url。\n例如：\n```\n{ \"url\" : \"https://github.com/owner/project/issues\",\n  \"email\" : \"project@hostname.com\"\n}\n```\n\n可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 ` npm bugs ` 命令使用。\n\n### license\n\n项目包的许可证，可以让别人知道你的项目包的限制。[查看详情](https://docs.npmjs.com/files/package.json)\n\n### people fields: author, contributors  \n\nauthor 是一个人，contributors 是一群人。人具有 url 和 email 。\n\n### files\n\n\"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）\n你也可以在模块根目录下创建一个\".npmignore\"文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。\n\n容易被忽略的文件：\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json （改用shrinkwrap）\n\n### main\n\n程序的主要入口，这应该是相对于包文件夹根目录的模块ID。\n\n### browser\n\n如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）\n\n### bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）\n如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n例如：\n```\n{ \"bin\" : { \"myapp\" : \"./cli.js\" } }\n```\n\n模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。\n如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n```\n{ \n    \"name\": \"my-program\",\n    \"version\": \"1.2.5\",\n    \"bin\": \"./path/to/program\",\n}\n```\n\n### man\n\n制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。\n如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : \"./man/doc.1\"\n}\n```\n\n通过 man foo 命令会得到 ./man/doc.1 文件的内容。\n如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ]\n}\n```\n\n会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。\nman文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ]\n}\n```\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n### directories\n\nCommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。\n目前这个配置没有任何作用。\n\ndirectories.lib\n告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\ndirectories.bin\n如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。\n\ndirectories.man\n指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。\n\ndirectories.doc\n在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）\n\ndirectories.example\n放一些示例脚本，或许某一天会有用 - -！\n\n### repository\n\n代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 ` npm docs ` 命令将能够找到你的项目\n\n例如：\n```\n\"repository\" :\n  { \n      \"type\" : \"git\",\n      \"url\" : \"https://github.com/npm/npm.git\"\n  }\n\n\"repository\" :\n  { \n    \"type\" : \"svn\",\n    \"url\" : \"https://v8.googlecode.com/svn/trunk/\"\n  }\n```\n\n该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。\n\n对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法\n\n### scripts\n\n“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。\n[npm-scripts 查看更多](https://docs.npmjs.com/misc/scripts)\n\n### config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。\n用户用的时候可以使用如下用法：\n```\nhttp.createServer(...).listen(process.env.npm_package_config_port) \n```\n\n可以通过npm config set foo:port 80来修改config:\n```\n{ \n    \"name\" : \"foo\",\n    \"config\" : { \"port\" : \"8080\" }\n}\n```\n\n### dependencies 和 devDependencies\n\ndependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。\n它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n对应的版本可以加上各种限定，主要有以下几种：\n\n指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n> 1. 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n> \n> 2. 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n> \n> 3. latest：安装最新版本。\n\npackage.json 文件可以手工编写，也可以使用 ` npm init ` 命令自动生成。项目名称（name）和项目版本（version）是必填的\n\n通过指令安装：\n```\n$ npm install express --save\n$ npm install express --save-dev\n```\n\n` --save ` 参数表示将该模块写入 dependencies 属性\n` --save-dev ` 表示将该模块写入 devDependencies 属性。\n\n### peerDependencies\n\n有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。\n\n大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\n\npeerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。\n\n例如：\n```\n{\n  \"name\": \"tea-latte\",\n  \"version\": \"1.3.5\",\n  \"peerDependencies\": {\n    \"tea\": \"2.x\"\n  }\n}\n```\n\n这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：\n```\n├── tea-latte@1.3.5\n└── tea@2.2.0\n```\n\n注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。\n\n### preferGlobal\n\npreferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n\n### style\n\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。","slug":"package-json文件","published":1,"updated":"2018-06-23T17:20:57.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjixcjzey00145ds6juzrhnjq","content":"<p>一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 <code>npm install</code> 会根据这个配置文件自动下载所需模块。</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>项目的名字</p>\n<p>规则：</p>\n<ol>\n<li>该名称必须小于或等于214个字符。</li>\n<li>名称不能以点或下划线开头。</li>\n<li>新包名称中不能包含大写字母。</li>\n<li>该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。</li>\n</ol>\n<p>技巧</p>\n<ol>\n<li>不要使用与核心节点模块相同的名称。</li>\n<li>不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）</li>\n<li>这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。</li>\n<li><p>你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 <a href=\"https://docs.npmjs.com/misc/scope\" target=\"_blank\" rel=\"noopener\">npm-scope</a>查看更多</p>\n</li>\n</ol>\n<h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search</p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p>如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。</p>\n<p>版本必须可以由 <a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">node-semver</a> 解析</p>\n<h3 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h3><p>把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。</p>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><p>项目首页的网址</p>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><p>如果项目有问题，可以提交的问题的邮箱和 url。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">  &quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 <code>npm bugs</code> 命令使用。</p>\n<h3 id=\"license\"><a href=\"#license\" class=\"headerlink\" title=\"license\"></a>license</h3><p>项目包的许可证，可以让别人知道你的项目包的限制。<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">查看详情</a></p>\n<h3 id=\"people-fields-author-contributors\"><a href=\"#people-fields-author-contributors\" class=\"headerlink\" title=\"people fields: author, contributors\"></a>people fields: author, contributors</h3><p>author 是一个人，contributors 是一群人。人具有 url 和 email 。</p>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p>\n<p>容易被忽略的文件：<br>.git<br>CVS<br>.svn<br>.hg<br>.lock-wscript<br>.wafpickle-N<br>.<em>.swp<br>.DS_Store<br>._</em><br>npm-debug.log<br>.npmrc<br>node_modules<br>config.gypi<br>*.orig<br>package-lock.json （改用shrinkwrap）</p>\n<h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><p>程序的主要入口，这应该是相对于包文件夹根目录的模块ID。</p>\n<h3 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h3><p>如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot;: &quot;my-program&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.2.5&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &quot;./path/to/program&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : &quot;./man/doc.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。<br>如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 <a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br>目前这个配置没有任何作用。</p>\n<p>directories.lib<br>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<p>directories.bin<br>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<p>directories.man<br>指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。</p>\n<p>directories.doc<br>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<p>directories.example<br>放一些示例脚本，或许某一天会有用 - -！</p>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><p>代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 <code>npm docs</code> 命令将能够找到你的项目</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">      &quot;type&quot; : &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    &quot;type&quot; : &quot;svn&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。</p>\n<p>对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。<br><a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm-scripts 查看更多</a></p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.createServer(...).listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure></p>\n<p>可以通过npm config set foo:port 80来修改config:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dependencies-和-devDependencies\"><a href=\"#dependencies-和-devDependencies\" class=\"headerlink\" title=\"dependencies 和 devDependencies\"></a>dependencies 和 devDependencies</h3><p>dependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br>对应的版本可以加上各种限定，主要有以下几种：</p>\n<p>指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</p>\n<blockquote>\n<ol>\n<li><p>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</p>\n</li>\n<li><p>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</p>\n</li>\n<li><p>latest：安装最新版本。</p>\n</li>\n</ol>\n</blockquote>\n<p>package.json 文件可以手工编写，也可以使用 <code>npm init</code> 命令自动生成。项目名称（name）和项目版本（version）是必填的</p>\n<p>通过指令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br><span class=\"line\">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><code>--save</code> 参数表示将该模块写入 dependencies 属性<br><code>--save-dev</code> 表示将该模块写入 devDependencies 属性。</p>\n<h3 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。</p>\n<p>大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>\n<p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p>\n<p>peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;tea-latte&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.3.5&quot;,</span><br><span class=\"line\">  &quot;peerDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;tea&quot;: &quot;2.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── tea-latte@1.3.5</span><br><span class=\"line\">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。</p>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 <code>npm install</code> 会根据这个配置文件自动下载所需模块。</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>项目的名字</p>\n<p>规则：</p>\n<ol>\n<li>该名称必须小于或等于214个字符。</li>\n<li>名称不能以点或下划线开头。</li>\n<li>新包名称中不能包含大写字母。</li>\n<li>该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。</li>\n</ol>\n<p>技巧</p>\n<ol>\n<li>不要使用与核心节点模块相同的名称。</li>\n<li>不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）</li>\n<li>这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。</li>\n<li><p>你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 <a href=\"https://docs.npmjs.com/misc/scope\" target=\"_blank\" rel=\"noopener\">npm-scope</a>查看更多</p>\n</li>\n</ol>\n<h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search</p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p>如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。</p>\n<p>版本必须可以由 <a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">node-semver</a> 解析</p>\n<h3 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h3><p>把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。</p>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><p>项目首页的网址</p>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><p>如果项目有问题，可以提交的问题的邮箱和 url。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">  &quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 <code>npm bugs</code> 命令使用。</p>\n<h3 id=\"license\"><a href=\"#license\" class=\"headerlink\" title=\"license\"></a>license</h3><p>项目包的许可证，可以让别人知道你的项目包的限制。<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">查看详情</a></p>\n<h3 id=\"people-fields-author-contributors\"><a href=\"#people-fields-author-contributors\" class=\"headerlink\" title=\"people fields: author, contributors\"></a>people fields: author, contributors</h3><p>author 是一个人，contributors 是一群人。人具有 url 和 email 。</p>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p>\n<p>容易被忽略的文件：<br>.git<br>CVS<br>.svn<br>.hg<br>.lock-wscript<br>.wafpickle-N<br>.<em>.swp<br>.DS_Store<br>._</em><br>npm-debug.log<br>.npmrc<br>node_modules<br>config.gypi<br>*.orig<br>package-lock.json （改用shrinkwrap）</p>\n<h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><p>程序的主要入口，这应该是相对于包文件夹根目录的模块ID。</p>\n<h3 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h3><p>如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot;: &quot;my-program&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.2.5&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &quot;./path/to/program&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : &quot;./man/doc.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。<br>如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 <a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br>目前这个配置没有任何作用。</p>\n<p>directories.lib<br>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<p>directories.bin<br>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<p>directories.man<br>指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。</p>\n<p>directories.doc<br>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<p>directories.example<br>放一些示例脚本，或许某一天会有用 - -！</p>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><p>代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 <code>npm docs</code> 命令将能够找到你的项目</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">      &quot;type&quot; : &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    &quot;type&quot; : &quot;svn&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。</p>\n<p>对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。<br><a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm-scripts 查看更多</a></p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.createServer(...).listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure></p>\n<p>可以通过npm config set foo:port 80来修改config:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dependencies-和-devDependencies\"><a href=\"#dependencies-和-devDependencies\" class=\"headerlink\" title=\"dependencies 和 devDependencies\"></a>dependencies 和 devDependencies</h3><p>dependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br>对应的版本可以加上各种限定，主要有以下几种：</p>\n<p>指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</p>\n<blockquote>\n<ol>\n<li><p>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</p>\n</li>\n<li><p>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</p>\n</li>\n<li><p>latest：安装最新版本。</p>\n</li>\n</ol>\n</blockquote>\n<p>package.json 文件可以手工编写，也可以使用 <code>npm init</code> 命令自动生成。项目名称（name）和项目版本（version）是必填的</p>\n<p>通过指令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br><span class=\"line\">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><code>--save</code> 参数表示将该模块写入 dependencies 属性<br><code>--save-dev</code> 表示将该模块写入 devDependencies 属性。</p>\n<h3 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。</p>\n<p>大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>\n<p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p>\n<p>peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;tea-latte&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.3.5&quot;,</span><br><span class=\"line\">  &quot;peerDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;tea&quot;: &quot;2.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── tea-latte@1.3.5</span><br><span class=\"line\">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。</p>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjixcjze400005ds6d4tsozj7","category_id":"cjixcjze900025ds6e5tq4u0h","_id":"cjixcjzei000d5ds6rcbx2bby"},{"post_id":"cjixcjze700015ds6mp7pqu7a","category_id":"cjixcjze900025ds6e5tq4u0h","_id":"cjixcjzek000h5ds6y94n817w"},{"post_id":"cjixcjzea00045ds6zt9hf2l3","category_id":"cjixcjzei000c5ds61n5sewlk","_id":"cjixcjzel000l5ds6ob2kvjb1"},{"post_id":"cjixcjzec00055ds6zdxciyle","category_id":"cjixcjzek000i5ds61uidg183","_id":"cjixcjzem000q5ds66k8kpxhs"},{"post_id":"cjixcjzed00065ds6xi1mgrar","category_id":"cjixcjzek000i5ds61uidg183","_id":"cjixcjzen000t5ds6vz4ojd2z"},{"post_id":"cjixcjzef000a5ds6vzcabgss","category_id":"cjixcjzem000p5ds6p0zuq1t2","_id":"cjixcjzeo000y5ds6xo78jsd3"},{"post_id":"cjixcjzeh000b5ds6wtcilsgj","category_id":"cjixcjzek000i5ds61uidg183","_id":"cjixcjzep00115ds6rj31an4l"},{"post_id":"cjixcjzej000g5ds610ah8752","category_id":"cjixcjzek000i5ds61uidg183","_id":"cjixcjzep00135ds6aa4xia5n"},{"post_id":"cjixcjzey00145ds6juzrhnjq","category_id":"cjixcjzf200175ds6e3wwvy3v","_id":"cjixcjzf3001a5ds61r1geiq3"}],"PostTag":[{"post_id":"cjixcjze400005ds6d4tsozj7","tag_id":"cjixcjzea00035ds6byipkfkh","_id":"cjixcjzef00095ds6px3kogrh"},{"post_id":"cjixcjze700015ds6mp7pqu7a","tag_id":"cjixcjzea00035ds6byipkfkh","_id":"cjixcjzej000f5ds6ajuayv6j"},{"post_id":"cjixcjzea00045ds6zt9hf2l3","tag_id":"cjixcjzei000e5ds6ajdhlnw1","_id":"cjixcjzel000k5ds614wsk9kv"},{"post_id":"cjixcjzec00055ds6zdxciyle","tag_id":"cjixcjzek000j5ds6cqs7voij","_id":"cjixcjzem000o5ds6xsrjzt7g"},{"post_id":"cjixcjzed00065ds6xi1mgrar","tag_id":"cjixcjzek000j5ds6cqs7voij","_id":"cjixcjzem000s5ds6yknsa08u"},{"post_id":"cjixcjzef000a5ds6vzcabgss","tag_id":"cjixcjzem000r5ds6me9w5okd","_id":"cjixcjzen000w5ds6gos7xnry"},{"post_id":"cjixcjzeh000b5ds6wtcilsgj","tag_id":"cjixcjzen000v5ds6em849fg6","_id":"cjixcjzeo00105ds6kh60zr5s"},{"post_id":"cjixcjzej000g5ds610ah8752","tag_id":"cjixcjzen000v5ds6em849fg6","_id":"cjixcjzep00125ds6fe0j1jwh"},{"post_id":"cjixcjzey00145ds6juzrhnjq","tag_id":"cjixcjzf200185ds6f31hpu07","_id":"cjixcjzf200195ds6wh787ryw"}],"Tag":[{"name":"git","_id":"cjixcjzea00035ds6byipkfkh"},{"name":"hexo","_id":"cjixcjzei000e5ds6ajdhlnw1"},{"name":"js","_id":"cjixcjzek000j5ds6cqs7voij"},{"name":"html","_id":"cjixcjzem000r5ds6me9w5okd"},{"name":"跨域","_id":"cjixcjzen000v5ds6em849fg6"},{"name":"package.json","_id":"cjixcjzf200185ds6f31hpu07"}]}}