{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/bom-dom.jpg","path":"images/bom-dom.jpg","modified":1,"renderable":0},{"_id":"source/images/git-computer.jpg","path":"images/git-computer.jpg","modified":1,"renderable":0},{"_id":"source/images/git-env.jpg","path":"images/git-env.jpg","modified":1,"renderable":0},{"_id":"source/images/git-path.jpg","path":"images/git-path.jpg","modified":1,"renderable":0},{"_id":"source/images/git-set.jpg","path":"images/git-set.jpg","modified":1,"renderable":0},{"_id":"source/images/hexo-page.png","path":"images/hexo-page.png","modified":1,"renderable":0},{"_id":"source/images/windows/installed.png","path":"images/windows/installed.png","modified":1,"renderable":0},{"_id":"source/images/windows/mongodbDownload.png","path":"images/windows/mongodbDownload.png","modified":1,"renderable":0},{"_id":"source/images/windows/mongodbShowDB.png","path":"images/windows/mongodbShowDB.png","modified":1,"renderable":0},{"_id":"source/images/windows/path.png","path":"images/windows/path.png","modified":1,"renderable":0},{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"source/images/reg/huisu.png","path":"images/reg/huisu.png","modified":1,"renderable":0},{"_id":"source/images/windows/mongodbInstall.png","path":"images/windows/mongodbInstall.png","modified":1,"renderable":0},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/avater.png","path":"css/images/avater.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"source/images/reg/match.png","path":"images/reg/match.png","modified":1,"renderable":0},{"_id":"source/images/webpack/env1.png","path":"images/webpack/env1.png","modified":1,"renderable":0},{"_id":"source/images/webpack/env2.png","path":"images/webpack/env2.png","modified":1,"renderable":0},{"_id":"themes/vexo/source/css/images/home-banner.png","path":"css/images/home-banner.png","modified":1,"renderable":1},{"_id":"source/images/webpack/env3.png","path":"images/webpack/env3.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/vexo/.gitignore","hash":"99e5bb4cc2a0b34f697ecc7c146f9d10d0a986e8","modified":1536977891882},{"_id":"themes/vexo/.travis.yml","hash":"b3ac9cda9d6000736519c78272ea03733f70bbfc","modified":1536977891892},{"_id":"themes/vexo/LICENSE","hash":"96a961acb8766182dca9e15280b37ee18156cee9","modified":1536977891892},{"_id":"themes/vexo/README.md","hash":"0519d952de0640daec890fd723410b735e8ec03d","modified":1536977891892},{"_id":"themes/vexo/_config.yml","hash":"079a3c6ac78b20edc747a67fb94bbc3f1dfe73e5","modified":1538272176859},{"_id":"themes/vexo/lint.sh","hash":"2f3d1e5bab055677cab305b34220ba090a59f49e","modified":1536977891902},{"_id":"themes/vexo/package.json","hash":"ce95b274241ba053218ee00952e0e2f720f4e30b","modified":1536977891902},{"_id":"source/_posts/BOM-DOM.md","hash":"3fcda90cfd4f8dafa9d6bb44557d3896e1472c08","modified":1538117693403},{"_id":"source/_posts/MongoDB-安装.md","hash":"d4023fecb6fc460bdff6f6e5d59621b2596b1047","modified":1538272206614},{"_id":"source/_posts/git-账户切换的怪异处理方式.md","hash":"71a0df35b0a3369efcd16e4b8dc04a3dd356024f","modified":1536977891872},{"_id":"source/_posts/gitCommand.md","hash":"89638b43db3329e839d65aea38fd66861d660973","modified":1538203128156},{"_id":"source/_posts/hexoGithubIo.md","hash":"21b85cdf76e6c61c16667bc57afbf5012aad4b35","modified":1536977891872},{"_id":"source/_posts/js-继承方式.md","hash":"4e75e798d655e92d71a565c784352251b6b7b02e","modified":1536977891872},{"_id":"source/_posts/js-银行卡号格式化.md","hash":"cd277dea00db323ba44a5fb3ea02fda9255a91f5","modified":1536977891872},{"_id":"source/_posts/let-vs-var.md","hash":"ae767e65e73449b45529aec571c67b8f96d4beab","modified":1536977891872},{"_id":"source/_posts/localStorage-sessionStorage.md","hash":"187bfef5497cf4fb8226d6af08c4523dcff6a64e","modified":1536977891872},{"_id":"source/_posts/mobile-modal-scroll.md","hash":"cb28ddc62e287b98fe779d92d919cba8d79b3a0c","modified":1536977891872},{"_id":"source/_posts/nextjs-postcss-typeScript.md","hash":"296d63f9ee82efe548882a2e1fa9224659d952f7","modified":1536977891872},{"_id":"source/_posts/package-json文件.md","hash":"63852a339ec1e5eaafc72576d64e02b319cbe663","modified":1536977891872},{"_id":"source/_posts/react-Lifecycle.md","hash":"53305aff13e042a3a2138ea8c8a25022ad6bb374","modified":1536977891872},{"_id":"source/_posts/react-高阶组件.md","hash":"91be86f70955a758e6ac5778e821488f0d12ee89","modified":1536977891872},{"_id":"source/_posts/typeScript（二）类.md","hash":"c182ab335210b2698e807a19e239d91e6b6f9c19","modified":1537870696198},{"_id":"source/_posts/typesSript（一）接口.md","hash":"6dcf3d23f87c8382541b6308ca17f33371573e10","modified":1537867116577},{"_id":"source/_posts/webpack-学习（一）.md","hash":"4c128e896d0473e940867f025ffabc5638967dc4","modified":1536994769833},{"_id":"source/_posts/windows-CMD-常用指令.md","hash":"0c3120e2fe82f841d965447e80fa28630750f608","modified":1538203038564},{"_id":"source/_posts/windows-下安装-git.md","hash":"6fd91df26b0e0c550fad00ec53447b89f8d6fc3c","modified":1536977891872},{"_id":"source/_posts/windows-常用快捷键总结.md","hash":"31b408986e3324ac83b931ed8032f03a5d642d7c","modified":1536977891872},{"_id":"source/_posts/什么是跨域？.md","hash":"35af620387503ba5ec2303de9a65b3cffaa901e0","modified":1536977891882},{"_id":"source/_posts/正则表达式.md","hash":"cef3cf2e0a1d5de57ec4e9bc6bf49fdb73f2c8f2","modified":1538102515922},{"_id":"source/_posts/浏览器内核.md","hash":"4e4e44959a4420c56840361fb09787b2df904631","modified":1536977891882},{"_id":"source/_posts/网址集合.md","hash":"4dd1c3c9bffd4b7bda5669dce1f8e0628960cdf5","modified":1536977891882},{"_id":"source/_posts/解决跨域的-10-种方法.md","hash":"e4c573f76959a9d78f84cbbfdca039a320adea5c","modified":1536977891882},{"_id":"source/about/index.md","hash":"966fba438bce3abca11f98de5fac7883e480404e","modified":1536977891882},{"_id":"source/images/bom-dom.jpg","hash":"72643a90e347098a053c30529760871c79d4e71f","modified":1536977891882},{"_id":"source/images/git-computer.jpg","hash":"d11af302b4088d6f72bb6561f17dba9388014f0a","modified":1536977891882},{"_id":"source/images/git-env.jpg","hash":"6c9e5550985a7856cb876ee6a1cfcc4920d6954c","modified":1536977891882},{"_id":"source/images/git-path.jpg","hash":"789384bcd7ac05e4b0b7e4be04102f3117a53541","modified":1536977891882},{"_id":"source/images/git-set.jpg","hash":"64d168a8ac9c30452635322f3c83e92c3a379657","modified":1536977891882},{"_id":"source/images/hexo-page.png","hash":"bcc8884f0fa4b9491eff8c4511d7ebc95a4d1f40","modified":1536977891882},{"_id":"source/tags/index.md","hash":"ae19acf22f855d3acfd9f58d28aebd1bd8ba4def","modified":1536977891882},{"_id":"themes/vexo/layout/about.ejs","hash":"9c796dc3a20ab7a2c126ba64efc4f7704b7b38be","modified":1538125592339},{"_id":"themes/vexo/layout/archive.ejs","hash":"238107d32e241854a9ee5caa4090a45a6b8904a1","modified":1538117676670},{"_id":"themes/vexo/layout/index.ejs","hash":"34e0da542758477495f81096ff91bbf1985a5308","modified":1536977891892},{"_id":"themes/vexo/layout/layout.ejs","hash":"f2663b2d38d506488954de4ee88437f7ecd8bef6","modified":1538104912735},{"_id":"themes/vexo/layout/page.ejs","hash":"a4a287134d5b4983fc7c29e0b764c1f7edcbe656","modified":1538121820078},{"_id":"themes/vexo/layout/project.ejs","hash":"4224332d7f9791353838024796daf21e993da66e","modified":1536977891902},{"_id":"themes/vexo/layout/tags.ejs","hash":"d212c99fe1283e2939a31c1137a861b985d20054","modified":1536977891902},{"_id":"source/images/windows/installed.png","hash":"5cb5cec3ce854082a0d83c1ed2a14cc7bf8bf4a8","modified":1538208178502},{"_id":"source/images/windows/mongodbDownload.png","hash":"6e34b94c7ed2c2e7c1b70f816625538635ee7014","modified":1538206543438},{"_id":"source/images/windows/mongodbShowDB.png","hash":"bbafb4e5f9d3fb3a4038f0ae4cb26443a04f6036","modified":1538209840517},{"_id":"source/images/windows/path.png","hash":"a062c9e740c00582863acb268d6381528341b6f7","modified":1538210136467},{"_id":"themes/vexo/_source/about/index.md","hash":"54861b4ba18c5d09a6b0d92429cabd617023caa0","modified":1536977891892},{"_id":"themes/vexo/_source/project/index.md","hash":"9e533e682312e2dc14844baa0c2576f4ee11169a","modified":1536977891892},{"_id":"themes/vexo/_source/tags/index.md","hash":"ae19acf22f855d3acfd9f58d28aebd1bd8ba4def","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"4857e09cb3dc8859a4b46b48806749a3fcbe1dad","modified":1538120942244},{"_id":"themes/vexo/layout/_partial/baidu_tongji.ejs","hash":"0f568f7adbbd5d8bfb493169e24645bce3ed7dc1","modified":1538112782852},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"388691959db5272d70995c9536c26135e07ec33d","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"27b223a0b3e75fe54d251d280a9b207703a68371","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"4170d992ef39f52654b3368719511f7d47d0ced1","modified":1538116813645},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"8bcd6655556310e150c0cf40d30a82bb939a2497","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/livere.ejs","hash":"1c9eecd2366e96afac8d6acd5b682c0ffcde2c84","modified":1538120859377},{"_id":"themes/vexo/layout/_partial/nav.ejs","hash":"d9845616016b20bf6604438600b34e0dcde0e135","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"b56ebe2bff1223b76865c4a43f2a0c28c08e9e7e","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"ff8f66ad350a0da1b7ef03840f70b637024e028c","modified":1536977891892},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"cb8abc06fa14d3ccc085629bbff0333d2f7aef37","modified":1536977891892},{"_id":"themes/vexo/layout/_third-party/mathjax.ejs","hash":"82a5df48b19ff02600c9deecd26f13b14645854d","modified":1536977891892},{"_id":"themes/vexo/source/css/_config.styl","hash":"b5a383312aea58303b30df471ba5134ee8b7d6fc","modified":1536977891902},{"_id":"themes/vexo/source/css/style.styl","hash":"7762c3a252fa4af0de63413ea72fe68ea5349bff","modified":1536977891912},{"_id":"themes/vexo/source/js/qrious.js","hash":"8017310ee572950086944a4c26e2017522add8e9","modified":1536977891912},{"_id":"themes/vexo/source/js/script.js","hash":"0e79c04a318c13b7b9fc0b23d41ab34185566f3b","modified":1536977891922},{"_id":"source/images/reg/huisu.png","hash":"d09bf9b5be0d017c5f33c9876731d5752089f027","modified":1538102239502},{"_id":"source/images/windows/mongodbInstall.png","hash":"1a6302daf00a80db5d7e8ef38ae669c75ad1c006","modified":1538208037491},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"be8ad35a89a11a183442a189667157a0e08d7ba2","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"f79fe04be64d5fe1355b15ff221fb39bfe16a835","modified":1538117492233},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"778880287b38cbb8b7c2bed29845525672200332","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"0fa2974f14dc8373e3705bc96d415dae236f49f3","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"46f7cb26ce62a66113dd46bb657237e0d0b61e50","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"928a0ae6870cbd7cbfb6d94a950baf8c632a0efe","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/nav.styl","hash":"566e4b18b3e0bcf7cb9c84462c8a1b5c8bcfab06","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"4a957c54f7f0773f5390a798a6fddefff4044cbb","modified":1538121423938},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"a4dc0b4bdf1b5e8fcd3a4c6f4d9b2ed8c06e72ba","modified":1536977891902},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"14cd7fbc4309ed2c470746497af14d79e62b6641","modified":1536977891902},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1536977891902},{"_id":"themes/vexo/source/css/images/avater.png","hash":"bcb54f5d16e2a6ebb84f931b280762b22574bd88","modified":1536977891902},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1536977891902},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1536977891902},{"_id":"themes/vexo/source/css/images/favicon.ico","hash":"84133d0b67e264f6008e81233f0f3a37defd4af3","modified":1536977891902},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1536977891912},{"_id":"themes/vexo/source/css/images/logo.png","hash":"c20b2395c9a2fd5e7c188bcc0676a3efbb6e6cb7","modified":1536977891912},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1536977891912},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1536977891912},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"1190f8b5c9962b96c3d3631b15ab8680faa9ddef","modified":1536977891912},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1536977891912},{"_id":"themes/vexo/source/js/gitment.js","hash":"b15998a45d5f386d30905cfbfbb1658336acbb5b","modified":1536977891912},{"_id":"source/images/reg/match.png","hash":"14e0e1ecdc3640cbc92f30165ac42d46c5d4d361","modified":1538101407417},{"_id":"source/images/webpack/env1.png","hash":"47880818a3537fdf04a14fd4aa76a5f6571909f3","modified":1536991999238},{"_id":"source/images/webpack/env2.png","hash":"e61c5400a48793098e3cab35167fa5c3932f4bb7","modified":1536991738539},{"_id":"themes/vexo/source/css/images/home-banner.png","hash":"943edbba46606d363d6432b29ee435a2f82aa9ae","modified":1536977891912},{"_id":"source/images/webpack/env3.png","hash":"0e3108771c3a7e1c2b376998bdbe7988b973c865","modified":1536991745239},{"_id":"public/about/index.html","hash":"1b0117951b316e8cc08f922253e091f763aee4ce","modified":1539052825512},{"_id":"public/tags/index.html","hash":"f879f6ac956eacdb196c80f75f2a06530128a903","modified":1539052825512},{"_id":"public/2018/09/29/windows-CMD-常用指令/index.html","hash":"db4ef419d59e55dcb7764934dc23bbd93e317916","modified":1539052825512},{"_id":"public/2018/08/25/windows-常用快捷键总结/index.html","hash":"a1dbec143fb58de244ac35930bbb02c5c17734fd","modified":1539052825513},{"_id":"public/2018/08/24/windows-下安装-git/index.html","hash":"8ceea659d785fcafc27606fa3f0a5ba415431e32","modified":1539052825513},{"_id":"public/2018/08/09/网址集合/index.html","hash":"86d70f45171dded86adecc58d537038d1220aa35","modified":1539052825513},{"_id":"public/2018/08/09/js-银行卡号格式化/index.html","hash":"504b6aa9bc4a8ce0a230490a8e2a2b52e59eb113","modified":1539052825513},{"_id":"public/2018/07/04/浏览器内核/index.html","hash":"2407ae0cd759bddc0eb28abb912e7c6560fb2281","modified":1539052825513},{"_id":"public/2018/06/28/BOM-DOM/index.html","hash":"83a775bb5d1fe06e437f8c3041711846911be97c","modified":1539052825513},{"_id":"public/2018/06/22/let-vs-var/index.html","hash":"a3ee87aff60a9b546221c1a13d5caea75b9ca13f","modified":1539052825513},{"_id":"public/2018/06/11/什么是跨域？/index.html","hash":"9775e39405b7337d8f6994ed23824ded105181f1","modified":1539052825513},{"_id":"public/2018/06/09/git-账户切换的怪异处理方式/index.html","hash":"2a5813faaafb180a988cee5a55f658ed34928b7a","modified":1539052825513},{"_id":"public/archives/index.html","hash":"fb8f3b05c0ce030bdae577ac2a1306f6b641a017","modified":1539052825513},{"_id":"public/archives/page/2/index.html","hash":"bdde5d5fed4f02b9781da47b68df811761358c39","modified":1539052825513},{"_id":"public/archives/page/3/index.html","hash":"8be43453afce40e0d1ed9079d3f76af5cae934d2","modified":1539052825514},{"_id":"public/archives/2018/index.html","hash":"ec81911242a55a388fbad92f30bff58cb1f5e880","modified":1539052825514},{"_id":"public/archives/2018/page/2/index.html","hash":"20fb3b9619ebc89ffa533257d6b5abcbcdd91051","modified":1539052825514},{"_id":"public/archives/2018/page/3/index.html","hash":"36ca36045dc73ee76b1bd399d6a34d219554edfc","modified":1539052825514},{"_id":"public/archives/2018/06/index.html","hash":"d374a804863c0e9feeccd42149e0f15a160f708f","modified":1539052825514},{"_id":"public/archives/2018/06/page/2/index.html","hash":"8487dd6e3eef1a1ecaa800951290f193bbce4fd1","modified":1539052825514},{"_id":"public/archives/2018/07/index.html","hash":"45ffdd4f615c9f68b86f2d2b1898d735b734ed13","modified":1539052825514},{"_id":"public/archives/2018/08/index.html","hash":"812e301beac94f7af4c315bb35676b9b1bc069a9","modified":1539052825514},{"_id":"public/archives/2018/09/index.html","hash":"57b0b111600ed71ccc3b1fe0b380febdc1a85b20","modified":1539052825514},{"_id":"public/categories/指令/index.html","hash":"7ef763f9e0f3a92019f45996bb702b5e34bf43f4","modified":1539052825514},{"_id":"public/categories/环境/index.html","hash":"5858a9977701fe167aa9231461e5d1ef26bef26f","modified":1539052825514},{"_id":"public/categories/js/index.html","hash":"bde0f6e21c18c9b7f358582b075ffbcac7f76df4","modified":1539052825514},{"_id":"public/categories/html/index.html","hash":"49685a04ffb37c63cd167640c7999fe95b8b38f2","modified":1539052825514},{"_id":"public/categories/json/index.html","hash":"5e7491eeb761ca92a21b17e254d1b504f94bcee7","modified":1539052825514},{"_id":"public/tags/html/index.html","hash":"d8bf09dc34849d022d27f83219a679c774015613","modified":1539052825514},{"_id":"public/tags/windows/index.html","hash":"20583a6031dff49c9aa0098bffe1ecab9347b2d3","modified":1539052825515},{"_id":"public/tags/数据库/index.html","hash":"a62300bf4d34405ccca8be32189d684bc4665a72","modified":1539052825515},{"_id":"public/tags/git/index.html","hash":"8d21f26a70b3cc44a281c912e743e6fbc7b087fe","modified":1539052825515},{"_id":"public/tags/hexo/index.html","hash":"1f92a0f24391fffc6bdac55634b81d32ed288099","modified":1539052825515},{"_id":"public/tags/指令/index.html","hash":"dc26dedf4e2c00d0c8fbca4dd4f31922ad15cc0f","modified":1539052825515},{"_id":"public/tags/js/index.html","hash":"2bfefd58e20aec58c4d564fc6935bd36e22c0c4d","modified":1539052825515},{"_id":"public/tags/css/index.html","hash":"2a7fa0fbced80136da285d409f9b05d35158b66c","modified":1539052825515},{"_id":"public/tags/nextjs/index.html","hash":"814cc5fec009c846edf1facd395f88bfd218eb7f","modified":1539052825515},{"_id":"public/tags/package-json/index.html","hash":"0bde4e89c065c6191dcc5cb9b8448ac1163cecc1","modified":1539052825515},{"_id":"public/tags/react/index.html","hash":"3e6293ff74aebeb329ca8a359ea913b30bc7abc5","modified":1539052825515},{"_id":"public/tags/ts/index.html","hash":"6df14a26d43fbfb6f72fed9bff2f6364864b2f9d","modified":1539052825515},{"_id":"public/tags/webpack/index.html","hash":"c81827b37e63d5db15c61d0a22c81541dc7fa96f","modified":1539052825515},{"_id":"public/tags/跨域/index.html","hash":"dce21c3a93e6029d93c782aebe8ec93414569181","modified":1539052825515},{"_id":"public/tags/浏览器/index.html","hash":"4dab35abda0aea72dd6334b0f5a6ba20bb69a8a6","modified":1539052825515},{"_id":"public/tags/其他/index.html","hash":"4df78d721b59d1a6ee2df5fce308c9f3f41ee9de","modified":1539052825516},{"_id":"public/index.html","hash":"8613e4103d7133d2ca9944fd3c86bfd96f9cc8c2","modified":1539052825516},{"_id":"public/page/2/index.html","hash":"78c8421217af4dcf061c3aec177369f7f076b846","modified":1539052825516},{"_id":"public/page/3/index.html","hash":"c3b8278f2d39d6710743c9213c85f9db4ad7375d","modified":1539052825516},{"_id":"public/2018/09/29/MongoDB-安装/index.html","hash":"a0086c6d81a65c397bca135b38a17a7848a51c1e","modified":1539052825516},{"_id":"public/2018/09/28/正则表达式/index.html","hash":"94d8d3eaf288365465214752f6fd46d31bb525a6","modified":1539052825516},{"_id":"public/2018/09/25/typeScript（二）类/index.html","hash":"30a0456a71b85829dd0a65408198fd7b85f40c26","modified":1539052825516},{"_id":"public/2018/09/25/typesSript（一）接口/index.html","hash":"b4e4c3f3189b315865efacab5e31997e54b18d86","modified":1539052825516},{"_id":"public/2018/09/15/webpack-学习（一）/index.html","hash":"a959a95de31e35bc932b2936541b55c125fb0dbe","modified":1539052825516},{"_id":"public/2018/08/09/react-高阶组件/index.html","hash":"803beceb093537f98a63a9bd5da443a1fe100c30","modified":1539052825516},{"_id":"public/2018/08/01/nextjs-postcss-typeScript/index.html","hash":"9442594ad3402207d08923ea6b298267b53b9525","modified":1539052825516},{"_id":"public/2018/07/31/mobile-modal-scroll/index.html","hash":"339e81c6bf3cdf997f44bbfc93bb10800e223fd5","modified":1539052825517},{"_id":"public/2018/06/28/react-Lifecycle/index.html","hash":"072d6223b11b9b8cbafaa523f04a290c1402bd1a","modified":1539052825517},{"_id":"public/2018/06/23/localStorage-sessionStorage/index.html","hash":"c5436a8251f6abb1c3290d1ae02cf9ea7e894271","modified":1539052825517},{"_id":"public/2018/06/21/js-继承方式/index.html","hash":"310c6cc0ae3efe5ada83d291b3b6e0e321f630ea","modified":1539052825517},{"_id":"public/2018/06/17/package-json文件/index.html","hash":"c3a6abf5d46e1f2f17be82d575e2e36b29f5b744","modified":1539052825517},{"_id":"public/2018/06/11/解决跨域的-10-种方法/index.html","hash":"ee1e2d4bb16367a189bfd8082380493285ef5186","modified":1539052825517},{"_id":"public/2018/06/09/gitCommand/index.html","hash":"da42c2c8f3633a481db9c0aa5fd4a73f0b28ab3f","modified":1539052825517},{"_id":"public/2018/06/06/hexoGithubIo/index.html","hash":"9532077be188a7f6910c74622b718dc7cc51395c","modified":1539052825517},{"_id":"public/images/bom-dom.jpg","hash":"72643a90e347098a053c30529760871c79d4e71f","modified":1539052825539},{"_id":"public/images/git-computer.jpg","hash":"d11af302b4088d6f72bb6561f17dba9388014f0a","modified":1539052825539},{"_id":"public/images/git-env.jpg","hash":"6c9e5550985a7856cb876ee6a1cfcc4920d6954c","modified":1539052825539},{"_id":"public/images/git-path.jpg","hash":"789384bcd7ac05e4b0b7e4be04102f3117a53541","modified":1539052825539},{"_id":"public/images/git-set.jpg","hash":"64d168a8ac9c30452635322f3c83e92c3a379657","modified":1539052825539},{"_id":"public/images/hexo-page.png","hash":"bcc8884f0fa4b9491eff8c4511d7ebc95a4d1f40","modified":1539052825539},{"_id":"public/images/windows/installed.png","hash":"5cb5cec3ce854082a0d83c1ed2a14cc7bf8bf4a8","modified":1539052825540},{"_id":"public/images/windows/mongodbShowDB.png","hash":"bbafb4e5f9d3fb3a4038f0ae4cb26443a04f6036","modified":1539052825540},{"_id":"public/images/windows/mongodbDownload.png","hash":"6e34b94c7ed2c2e7c1b70f816625538635ee7014","modified":1539052825540},{"_id":"public/images/windows/path.png","hash":"a062c9e740c00582863acb268d6381528341b6f7","modified":1539052825540},{"_id":"public/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1539052825540},{"_id":"public/css/images/avater.png","hash":"bcb54f5d16e2a6ebb84f931b280762b22574bd88","modified":1539052825540},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1539052825540},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1539052825540},{"_id":"public/css/images/favicon.ico","hash":"84133d0b67e264f6008e81233f0f3a37defd4af3","modified":1539052825540},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1539052825540},{"_id":"public/css/images/logo.png","hash":"c20b2395c9a2fd5e7c188bcc0676a3efbb6e6cb7","modified":1539052825541},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1539052825541},{"_id":"public/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1539052825541},{"_id":"public/images/reg/huisu.png","hash":"d09bf9b5be0d017c5f33c9876731d5752089f027","modified":1539052825884},{"_id":"public/images/windows/mongodbInstall.png","hash":"1a6302daf00a80db5d7e8ef38ae669c75ad1c006","modified":1539052825886},{"_id":"public/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1539052825910},{"_id":"public/css/style.css","hash":"849f1333f89dd2ac0feaf3de75b8ca3e92ab72df","modified":1539052825910},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1539052825910},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1539052825910},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1539052825910},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1539052825910},{"_id":"public/images/reg/match.png","hash":"14e0e1ecdc3640cbc92f30165ac42d46c5d4d361","modified":1539052825914},{"_id":"public/images/webpack/env1.png","hash":"47880818a3537fdf04a14fd4aa76a5f6571909f3","modified":1539052825914},{"_id":"public/css/images/home-banner.png","hash":"943edbba46606d363d6432b29ee435a2f82aa9ae","modified":1539052825914},{"_id":"public/images/webpack/env2.png","hash":"e61c5400a48793098e3cab35167fa5c3932f4bb7","modified":1539052825927},{"_id":"public/images/webpack/env3.png","hash":"0e3108771c3a7e1c2b376998bdbe7988b973c865","modified":1539052826234}],"Category":[{"name":"指令","_id":"cjn14bba40006fwvp3jx68531"},{"name":"环境","_id":"cjn14bbab000cfwvpkq5sayh9"},{"name":"js","_id":"cjn14bbax000mfwvp0g3uejs1"},{"name":"html","_id":"cjn14bbb70010fwvpsgeb00s9"},{"name":"json","_id":"cjn14bbbg001bfwvp5lae8jr2"}],"Data":[],"Page":[{"title":"About","type":"about","comments":0,"layout":"about","_content":"\nEagle Li\n\n喜欢自己折腾一些感兴趣的小东西\n\n敲起代码不喜欢被打扰\n\n周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天\n\n长假想要出去走走，看看这大好的风光\n\n在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌\n\n舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万\n\n\n\n\n邮箱：liying_eagle@163.com","source":"about/index.md","raw":"title: About\ntype: \"about\"\ncomments: false\nlayout: about\n---\n\nEagle Li\n\n喜欢自己折腾一些感兴趣的小东西\n\n敲起代码不喜欢被打扰\n\n周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天\n\n长假想要出去走走，看看这大好的风光\n\n在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌\n\n舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万\n\n\n\n\n邮箱：liying_eagle@163.com","date":"2018-09-15T02:18:11.882Z","updated":"2018-09-15T02:18:11.882Z","path":"about/index.html","_id":"cjn14bb9s0001fwvpebm8muyv","content":"<p>Eagle Li</p>\n<p>喜欢自己折腾一些感兴趣的小东西</p>\n<p>敲起代码不喜欢被打扰</p>\n<p>周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天</p>\n<p>长假想要出去走走，看看这大好的风光</p>\n<p>在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌</p>\n<p>舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万</p>\n<p>邮箱：<a href=\"mailto:liying_eagle@163.com\" target=\"_blank\" rel=\"noopener\">liying_eagle@163.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Eagle Li</p>\n<p>喜欢自己折腾一些感兴趣的小东西</p>\n<p>敲起代码不喜欢被打扰</p>\n<p>周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天</p>\n<p>长假想要出去走走，看看这大好的风光</p>\n<p>在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌</p>\n<p>舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万</p>\n<p>邮箱：<a href=\"mailto:liying_eagle@163.com\" target=\"_blank\" rel=\"noopener\">liying_eagle@163.com</a></p>\n"},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2018-09-15T02:18:11.882Z","updated":"2018-09-15T02:18:11.882Z","path":"tags/index.html","comments":1,"_id":"cjn14bbck002xfwvpfucc0uyx","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BOM-DOM","date":"2018-06-27T17:01:59.000Z","_content":"\n## BOM\n\n1. BOM 是 Browser Object Model 的缩写，即浏览器对象模型。\n\nBOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。\n\n2. BOM没有相关标准\n\n由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。\n\n3. BOM 的最根本对象是 window。\n\n## DOM\n\n1. DOM 是 Document Object Model 的缩写，即文档对象模型。\n\nDOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。\n\n2. DOM 是 W3C 的标准。\n\n3. DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。\n\n## BOM DOM 关系图\n\n![](/images/bom-dom.jpg)\n\n\n原文链接：https://blog.csdn.net/xiao__gui/article/details/8315148","source":"_posts/BOM-DOM.md","raw":"---\ntitle: BOM-DOM\ndate: 2018-06-28 01:01:59\ntags: html\n---\n\n## BOM\n\n1. BOM 是 Browser Object Model 的缩写，即浏览器对象模型。\n\nBOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。\n\n2. BOM没有相关标准\n\n由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。\n\n3. BOM 的最根本对象是 window。\n\n## DOM\n\n1. DOM 是 Document Object Model 的缩写，即文档对象模型。\n\nDOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。\n\n2. DOM 是 W3C 的标准。\n\n3. DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。\n\n## BOM DOM 关系图\n\n![](/images/bom-dom.jpg)\n\n\n原文链接：https://blog.csdn.net/xiao__gui/article/details/8315148","slug":"BOM-DOM","published":1,"updated":"2018-09-28T06:54:53.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bb9m0000fwvpmw5fd9mw","content":"<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><ol>\n<li>BOM 是 Browser Object Model 的缩写，即浏览器对象模型。</li>\n</ol>\n<p>BOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。</p>\n<ol start=\"2\">\n<li>BOM没有相关标准</li>\n</ol>\n<p>由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。</p>\n<ol start=\"3\">\n<li>BOM 的最根本对象是 window。</li>\n</ol>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><ol>\n<li>DOM 是 Document Object Model 的缩写，即文档对象模型。</li>\n</ol>\n<p>DOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。</p>\n<ol start=\"2\">\n<li><p>DOM 是 W3C 的标准。</p>\n</li>\n<li><p>DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p>\n</li>\n</ol>\n<h2 id=\"BOM-DOM-关系图\"><a href=\"#BOM-DOM-关系图\" class=\"headerlink\" title=\"BOM DOM 关系图\"></a>BOM DOM 关系图</h2><p><img src=\"/images/bom-dom.jpg\" alt=\"\"></p>\n<p>原文链接：<a href=\"https://blog.csdn.net/xiao__gui/article/details/8315148\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiao__gui/article/details/8315148</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><ol>\n<li>BOM 是 Browser Object Model 的缩写，即浏览器对象模型。</li>\n</ol>\n<p>BOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。</p>\n<ol start=\"2\">\n<li>BOM没有相关标准</li>\n</ol>\n<p>由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。</p>\n<ol start=\"3\">\n<li>BOM 的最根本对象是 window。</li>\n</ol>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><ol>\n<li>DOM 是 Document Object Model 的缩写，即文档对象模型。</li>\n</ol>\n<p>DOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。</p>\n<ol start=\"2\">\n<li><p>DOM 是 W3C 的标准。</p>\n</li>\n<li><p>DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p>\n</li>\n</ol>\n<h2 id=\"BOM-DOM-关系图\"><a href=\"#BOM-DOM-关系图\" class=\"headerlink\" title=\"BOM DOM 关系图\"></a>BOM DOM 关系图</h2><p><img src=\"/images/bom-dom.jpg\" alt=\"\"></p>\n<p>原文链接：<a href=\"https://blog.csdn.net/xiao__gui/article/details/8315148\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiao__gui/article/details/8315148</a></p>\n"},{"title":"MongoDB 安装","date":"2018-09-29T06:37:49.000Z","_content":"\n每次安装 mongodb 都很费劲，这次就总结一下整个流程（windows-64）\n\n## 下载\n\n在[官网下载中心](https://www.mongodb.com/download-center#community)上下载，如果你直接点击 DIWNLOAD 按钮的话可能需要你填写一些注册信息，其实有一个快捷入口，点击左下角有一个 [ALL Version Binaries](https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl?_ga=2.83391894.1257395547.1538126096-909476422.1538126096) 可以看到所有的历史版本，随便选择一个自己想要的版本下载就好了，\n\n<img src=\"/images/windows/mongodbDownload.png\">\n\n> 注意：\n> 1. 选择 Community Server\n> 2. 现在 windows 已经不支持 xp 和 32位操作系统\n\n## 安装\n\n安装前：\n<img src=\"/images/windows/mongodbInstall.png\">\n\n安装后：\n<img src=\"/images/windows/installed.png\">\n\ndata: 存放数据\nlog: 存放记录\n\n## 启动服务器\n\n在Win10中以管理员身份运行cmd命令窗口，执行一下指令：\n\n```js\n// 进入安装的mongodb 的 bin 目录下\n> cd F:\\software\\mongodb\\bin\n// 设置启动\n> mongod --dbpath F:\\software\\mongodb\\data --logpath=F:\\software\\mongodb\\log\\mongodb.log --logappend\n```\n<b>注意不要关闭 cmd，否则就会终止启动的服务器</b>\n<br />\n关于以上命令中的参数说明：\n\n参数 | 描述\n---- | --- \n--bind_ip | 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP\n--logpath | 定MongoDB日志文件，注意是指定文件不是目录\n--logappend\t| 使用追加的方式写日志\n--dbpath | 指定数据库路径\n--port | 指定服务端口号，默认端口27017\n--serviceName | 指定服务名称\n--serviceDisplayName | 指定服务名称，有多个mongodb服务时执行。\n--install | 指定作为一个Windows服务安装。\n\n## 连接服务器\n\n\n如果只是想检查服务器是否安装成功有两种方法：\n<br />\n#### 方法一\n\n你只需要在浏览器中输入：[http://localhost:27017](http://localhost:27017)，或者是 [http://127.0.0.1:27017](http://127.0.0.1:27017)，在浏览器中出现：\n\nIt looks like you are trying to access MongoDB over HTTP on the native driver port\n\n则证明安装成功。\n<br />\n#### 方法二\n\n新打开一个 cmd 窗口，执行一下指令测试一下是否连接成功。\n\n```js\n> cd F:\\software\\mongodb\\bin\n> mongo\n> show dbs  // 列出所有数据库\n```\n最后输出结果为：(证明你连接成功)\n<img src=\"/images/windows/mongodbShowDB.png\" />\n\n常用是数据库指令：\n```js\nshow dbs  //查看mongodb\n\nuse a // 创建数据库 a ，切换数据库 a\n\ndb.a.insertOne({\"key1\":\"value1\",\"key2\":\"value2\"})//插入一行\n\ndb.a.insertMany([{\"key1\":value1,\"key2\":\"value2\"},{\"key2\":value2},...]) //插入多行\n\ndb.a.find()  //查找数据库 里面 所有数据\n\ndb.a.find({key:value},{\"_id\":0}) // {key:value}条件  查找符合这一条件的mongodb,{\"_id\":0}不想显示  id等条件\n\ndb.a.drop()// 删除mongodb的数据库\n\ndb.a.remove(query(条件)) //可以根据条件删除 指定的 数据库\n\ndb.help()// mongodb的帮助\n\nuse music //music 文件夹\n\ndb.createCollection(\"albums\") // 链接albums 的集合\n\ndb.getCollectionNames()  // 出现 [\"albums\"]\n\ndb.albums.insert([{\"key\":\"value\"},{\"key1\":\"value\"}]) //新增多条\n\ndb。albums.save([{\"key\":\"value\"},{\"key1\":\"value\"}]) //新增多条\n\ndb.albums.find()  //查找 albums \n\ndb.albums.help() //查看所有命令\n\ndb.music.find() //music必须得有数据\n\ndb.albums.states() //查看状态\n\ndb.albums.update(query(查询条件),{$set:{\"key\":\"value\"}}) //修改一条\n\ndb.albums.updateOne(query(查询条件),{$set:{\"key\":\"value\"}})\n\ndb.albums.updateMany(query(查询条件),{$set:{\"key\":\"value\"}})\n\nmongodb //我本人认为 修改 这一功能 不能够 一次 将 几条数据 分别改成 不一样的 value值\n```\n\n## 设置环境变量\n\n将 `F:\\software\\mongodb\\bin` 设置成环境变量就可以再任何盘连接数据库了\n（注意：有的电脑可能因为权限问题，在 C 盘不能启动）\n<img src=\"/images/windows/path.png\" />\n\n现在可以去其他盘随意连接数据库了\n\n## 将 mongodb 作为 windows 服务启动\n(暂未完成)\n\n\n以上启动服务器只是一次性的，当关闭了命令窗口，服务器即会关闭，可以将mongodb作为windows启动，这样一开机，mongodb服务就已经启动了 \n\n\n## 参考地址\n[https://www.cnblogs.com/hongwest/p/7298257.html](https://www.cnblogs.com/hongwest/p/7298257.html)\n[https://www.cnblogs.com/shirly77/p/6536327.html](https://www.cnblogs.com/shirly77/p/6536327.html)","source":"_posts/MongoDB-安装.md","raw":"---\ntitle: MongoDB 安装\ndate: 2018-09-29 14:37:49\ntags: ['windows', '数据库']\n---\n\n每次安装 mongodb 都很费劲，这次就总结一下整个流程（windows-64）\n\n## 下载\n\n在[官网下载中心](https://www.mongodb.com/download-center#community)上下载，如果你直接点击 DIWNLOAD 按钮的话可能需要你填写一些注册信息，其实有一个快捷入口，点击左下角有一个 [ALL Version Binaries](https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl?_ga=2.83391894.1257395547.1538126096-909476422.1538126096) 可以看到所有的历史版本，随便选择一个自己想要的版本下载就好了，\n\n<img src=\"/images/windows/mongodbDownload.png\">\n\n> 注意：\n> 1. 选择 Community Server\n> 2. 现在 windows 已经不支持 xp 和 32位操作系统\n\n## 安装\n\n安装前：\n<img src=\"/images/windows/mongodbInstall.png\">\n\n安装后：\n<img src=\"/images/windows/installed.png\">\n\ndata: 存放数据\nlog: 存放记录\n\n## 启动服务器\n\n在Win10中以管理员身份运行cmd命令窗口，执行一下指令：\n\n```js\n// 进入安装的mongodb 的 bin 目录下\n> cd F:\\software\\mongodb\\bin\n// 设置启动\n> mongod --dbpath F:\\software\\mongodb\\data --logpath=F:\\software\\mongodb\\log\\mongodb.log --logappend\n```\n<b>注意不要关闭 cmd，否则就会终止启动的服务器</b>\n<br />\n关于以上命令中的参数说明：\n\n参数 | 描述\n---- | --- \n--bind_ip | 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP\n--logpath | 定MongoDB日志文件，注意是指定文件不是目录\n--logappend\t| 使用追加的方式写日志\n--dbpath | 指定数据库路径\n--port | 指定服务端口号，默认端口27017\n--serviceName | 指定服务名称\n--serviceDisplayName | 指定服务名称，有多个mongodb服务时执行。\n--install | 指定作为一个Windows服务安装。\n\n## 连接服务器\n\n\n如果只是想检查服务器是否安装成功有两种方法：\n<br />\n#### 方法一\n\n你只需要在浏览器中输入：[http://localhost:27017](http://localhost:27017)，或者是 [http://127.0.0.1:27017](http://127.0.0.1:27017)，在浏览器中出现：\n\nIt looks like you are trying to access MongoDB over HTTP on the native driver port\n\n则证明安装成功。\n<br />\n#### 方法二\n\n新打开一个 cmd 窗口，执行一下指令测试一下是否连接成功。\n\n```js\n> cd F:\\software\\mongodb\\bin\n> mongo\n> show dbs  // 列出所有数据库\n```\n最后输出结果为：(证明你连接成功)\n<img src=\"/images/windows/mongodbShowDB.png\" />\n\n常用是数据库指令：\n```js\nshow dbs  //查看mongodb\n\nuse a // 创建数据库 a ，切换数据库 a\n\ndb.a.insertOne({\"key1\":\"value1\",\"key2\":\"value2\"})//插入一行\n\ndb.a.insertMany([{\"key1\":value1,\"key2\":\"value2\"},{\"key2\":value2},...]) //插入多行\n\ndb.a.find()  //查找数据库 里面 所有数据\n\ndb.a.find({key:value},{\"_id\":0}) // {key:value}条件  查找符合这一条件的mongodb,{\"_id\":0}不想显示  id等条件\n\ndb.a.drop()// 删除mongodb的数据库\n\ndb.a.remove(query(条件)) //可以根据条件删除 指定的 数据库\n\ndb.help()// mongodb的帮助\n\nuse music //music 文件夹\n\ndb.createCollection(\"albums\") // 链接albums 的集合\n\ndb.getCollectionNames()  // 出现 [\"albums\"]\n\ndb.albums.insert([{\"key\":\"value\"},{\"key1\":\"value\"}]) //新增多条\n\ndb。albums.save([{\"key\":\"value\"},{\"key1\":\"value\"}]) //新增多条\n\ndb.albums.find()  //查找 albums \n\ndb.albums.help() //查看所有命令\n\ndb.music.find() //music必须得有数据\n\ndb.albums.states() //查看状态\n\ndb.albums.update(query(查询条件),{$set:{\"key\":\"value\"}}) //修改一条\n\ndb.albums.updateOne(query(查询条件),{$set:{\"key\":\"value\"}})\n\ndb.albums.updateMany(query(查询条件),{$set:{\"key\":\"value\"}})\n\nmongodb //我本人认为 修改 这一功能 不能够 一次 将 几条数据 分别改成 不一样的 value值\n```\n\n## 设置环境变量\n\n将 `F:\\software\\mongodb\\bin` 设置成环境变量就可以再任何盘连接数据库了\n（注意：有的电脑可能因为权限问题，在 C 盘不能启动）\n<img src=\"/images/windows/path.png\" />\n\n现在可以去其他盘随意连接数据库了\n\n## 将 mongodb 作为 windows 服务启动\n(暂未完成)\n\n\n以上启动服务器只是一次性的，当关闭了命令窗口，服务器即会关闭，可以将mongodb作为windows启动，这样一开机，mongodb服务就已经启动了 \n\n\n## 参考地址\n[https://www.cnblogs.com/hongwest/p/7298257.html](https://www.cnblogs.com/hongwest/p/7298257.html)\n[https://www.cnblogs.com/shirly77/p/6536327.html](https://www.cnblogs.com/shirly77/p/6536327.html)","slug":"MongoDB-安装","published":1,"updated":"2018-09-30T01:50:06.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bb9t0002fwvplxknyiqt","content":"<p>每次安装 mongodb 都很费劲，这次就总结一下整个流程（windows-64）</p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>在<a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">官网下载中心</a>上下载，如果你直接点击 DIWNLOAD 按钮的话可能需要你填写一些注册信息，其实有一个快捷入口，点击左下角有一个 <a href=\"https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl?_ga=2.83391894.1257395547.1538126096-909476422.1538126096\" target=\"_blank\" rel=\"noopener\">ALL Version Binaries</a> 可以看到所有的历史版本，随便选择一个自己想要的版本下载就好了，</p>\n<p><img src=\"/images/windows/mongodbDownload.png\"></p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>选择 Community Server</li>\n<li>现在 windows 已经不支持 xp 和 32位操作系统</li>\n</ol>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装前：<br><img src=\"/images/windows/mongodbInstall.png\"></p>\n<p>安装后：<br><img src=\"/images/windows/installed.png\"></p>\n<p>data: 存放数据<br>log: 存放记录</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p>在Win10中以管理员身份运行cmd命令窗口，执行一下指令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 进入安装的mongodb 的 bin 目录下</span></span><br><span class=\"line\">&gt; cd F:\\software\\mongodb\\bin</span><br><span class=\"line\"><span class=\"comment\">// 设置启动</span></span><br><span class=\"line\">&gt; mongod --dbpath F:\\software\\mongodb\\data --logpath=F:\\software\\mongodb\\log\\mongodb.log --logappend</span><br></pre></td></tr></table></figure>\n<p><b>注意不要关闭 cmd，否则就会终止启动的服务器</b><br><br><br>关于以上命令中的参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–bind_ip</td>\n<td>绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</td>\n</tr>\n<tr>\n<td>–logpath</td>\n<td>定MongoDB日志文件，注意是指定文件不是目录</td>\n</tr>\n<tr>\n<td>–logappend</td>\n<td>使用追加的方式写日志</td>\n</tr>\n<tr>\n<td>–dbpath</td>\n<td>指定数据库路径</td>\n</tr>\n<tr>\n<td>–port</td>\n<td>指定服务端口号，默认端口27017</td>\n</tr>\n<tr>\n<td>–serviceName</td>\n<td>指定服务名称</td>\n</tr>\n<tr>\n<td>–serviceDisplayName</td>\n<td>指定服务名称，有多个mongodb服务时执行。</td>\n</tr>\n<tr>\n<td>–install</td>\n<td>指定作为一个Windows服务安装。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h2><p>如果只是想检查服务器是否安装成功有两种方法：<br><br></p>\n<h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>你只需要在浏览器中输入：<a href=\"http://localhost:27017\" target=\"_blank\" rel=\"noopener\">http://localhost:27017</a>，或者是 <a href=\"http://127.0.0.1:27017\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:27017</a>，在浏览器中出现：</p>\n<p>It looks like you are trying to access MongoDB over HTTP on the native driver port</p>\n<p>则证明安装成功。<br><br></p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>新打开一个 cmd 窗口，执行一下指令测试一下是否连接成功。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cd F:\\software\\mongodb\\bin</span><br><span class=\"line\">&gt; mongo</span><br><span class=\"line\">&gt; show dbs  <span class=\"comment\">// 列出所有数据库</span></span><br></pre></td></tr></table></figure>\n<p>最后输出结果为：(证明你连接成功)<br><img src=\"/images/windows/mongodbShowDB.png\"></p>\n<p>常用是数据库指令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show dbs  <span class=\"comment\">//查看mongodb</span></span><br><span class=\"line\"></span><br><span class=\"line\">use a <span class=\"comment\">// 创建数据库 a ，切换数据库 a</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.insertOne(&#123;<span class=\"string\">\"key1\"</span>:<span class=\"string\">\"value1\"</span>,<span class=\"string\">\"key2\"</span>:<span class=\"string\">\"value2\"</span>&#125;)<span class=\"comment\">//插入一行</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.insertMany([&#123;<span class=\"string\">\"key1\"</span>:value1,<span class=\"string\">\"key2\"</span>:<span class=\"string\">\"value2\"</span>&#125;,&#123;<span class=\"string\">\"key2\"</span>:value2&#125;,...]) <span class=\"comment\">//插入多行</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.find()  <span class=\"comment\">//查找数据库 里面 所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.find(&#123;<span class=\"attr\">key</span>:value&#125;,&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">0</span>&#125;) <span class=\"comment\">// &#123;key:value&#125;条件  查找符合这一条件的mongodb,&#123;\"_id\":0&#125;不想显示  id等条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.drop()<span class=\"comment\">// 删除mongodb的数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.remove(query(条件)) <span class=\"comment\">//可以根据条件删除 指定的 数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.help()<span class=\"comment\">// mongodb的帮助</span></span><br><span class=\"line\"></span><br><span class=\"line\">use music <span class=\"comment\">//music 文件夹</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.createCollection(<span class=\"string\">\"albums\"</span>) <span class=\"comment\">// 链接albums 的集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.getCollectionNames()  <span class=\"comment\">// 出现 [\"albums\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.insert([&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;,&#123;<span class=\"string\">\"key1\"</span>:<span class=\"string\">\"value\"</span>&#125;]) <span class=\"comment\">//新增多条</span></span><br><span class=\"line\"></span><br><span class=\"line\">db。albums.save([&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;,&#123;<span class=\"string\">\"key1\"</span>:<span class=\"string\">\"value\"</span>&#125;]) <span class=\"comment\">//新增多条</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.find()  <span class=\"comment\">//查找 albums </span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.help() <span class=\"comment\">//查看所有命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.music.find() <span class=\"comment\">//music必须得有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.states() <span class=\"comment\">//查看状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.update(query(查询条件),&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;&#125;) <span class=\"comment\">//修改一条</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.updateOne(query(查询条件),&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.updateMany(query(查询条件),&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">mongodb <span class=\"comment\">//我本人认为 修改 这一功能 不能够 一次 将 几条数据 分别改成 不一样的 value值</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"设置环境变量\"><a href=\"#设置环境变量\" class=\"headerlink\" title=\"设置环境变量\"></a>设置环境变量</h2><p>将 <code>F:\\software\\mongodb\\bin</code> 设置成环境变量就可以再任何盘连接数据库了<br>（注意：有的电脑可能因为权限问题，在 C 盘不能启动）<br><img src=\"/images/windows/path.png\"></p>\n<p>现在可以去其他盘随意连接数据库了</p>\n<h2 id=\"将-mongodb-作为-windows-服务启动\"><a href=\"#将-mongodb-作为-windows-服务启动\" class=\"headerlink\" title=\"将 mongodb 作为 windows 服务启动\"></a>将 mongodb 作为 windows 服务启动</h2><p>(暂未完成)</p>\n<p>以上启动服务器只是一次性的，当关闭了命令窗口，服务器即会关闭，可以将mongodb作为windows启动，这样一开机，mongodb服务就已经启动了 </p>\n<h2 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h2><p><a href=\"https://www.cnblogs.com/hongwest/p/7298257.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hongwest/p/7298257.html</a><br><a href=\"https://www.cnblogs.com/shirly77/p/6536327.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/shirly77/p/6536327.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>每次安装 mongodb 都很费劲，这次就总结一下整个流程（windows-64）</p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>在<a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">官网下载中心</a>上下载，如果你直接点击 DIWNLOAD 按钮的话可能需要你填写一些注册信息，其实有一个快捷入口，点击左下角有一个 <a href=\"https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl?_ga=2.83391894.1257395547.1538126096-909476422.1538126096\" target=\"_blank\" rel=\"noopener\">ALL Version Binaries</a> 可以看到所有的历史版本，随便选择一个自己想要的版本下载就好了，</p>\n<p><img src=\"/images/windows/mongodbDownload.png\"></p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>选择 Community Server</li>\n<li>现在 windows 已经不支持 xp 和 32位操作系统</li>\n</ol>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装前：<br><img src=\"/images/windows/mongodbInstall.png\"></p>\n<p>安装后：<br><img src=\"/images/windows/installed.png\"></p>\n<p>data: 存放数据<br>log: 存放记录</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p>在Win10中以管理员身份运行cmd命令窗口，执行一下指令：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 进入安装的mongodb 的 bin 目录下</span></span><br><span class=\"line\">&gt; cd F:\\software\\mongodb\\bin</span><br><span class=\"line\"><span class=\"comment\">// 设置启动</span></span><br><span class=\"line\">&gt; mongod --dbpath F:\\software\\mongodb\\data --logpath=F:\\software\\mongodb\\log\\mongodb.log --logappend</span><br></pre></td></tr></table></figure>\n<p><b>注意不要关闭 cmd，否则就会终止启动的服务器</b><br><br><br>关于以上命令中的参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–bind_ip</td>\n<td>绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</td>\n</tr>\n<tr>\n<td>–logpath</td>\n<td>定MongoDB日志文件，注意是指定文件不是目录</td>\n</tr>\n<tr>\n<td>–logappend</td>\n<td>使用追加的方式写日志</td>\n</tr>\n<tr>\n<td>–dbpath</td>\n<td>指定数据库路径</td>\n</tr>\n<tr>\n<td>–port</td>\n<td>指定服务端口号，默认端口27017</td>\n</tr>\n<tr>\n<td>–serviceName</td>\n<td>指定服务名称</td>\n</tr>\n<tr>\n<td>–serviceDisplayName</td>\n<td>指定服务名称，有多个mongodb服务时执行。</td>\n</tr>\n<tr>\n<td>–install</td>\n<td>指定作为一个Windows服务安装。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h2><p>如果只是想检查服务器是否安装成功有两种方法：<br><br></p>\n<h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>你只需要在浏览器中输入：<a href=\"http://localhost:27017\" target=\"_blank\" rel=\"noopener\">http://localhost:27017</a>，或者是 <a href=\"http://127.0.0.1:27017\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:27017</a>，在浏览器中出现：</p>\n<p>It looks like you are trying to access MongoDB over HTTP on the native driver port</p>\n<p>则证明安装成功。<br><br></p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>新打开一个 cmd 窗口，执行一下指令测试一下是否连接成功。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; cd F:\\software\\mongodb\\bin</span><br><span class=\"line\">&gt; mongo</span><br><span class=\"line\">&gt; show dbs  <span class=\"comment\">// 列出所有数据库</span></span><br></pre></td></tr></table></figure>\n<p>最后输出结果为：(证明你连接成功)<br><img src=\"/images/windows/mongodbShowDB.png\"></p>\n<p>常用是数据库指令：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show dbs  <span class=\"comment\">//查看mongodb</span></span><br><span class=\"line\"></span><br><span class=\"line\">use a <span class=\"comment\">// 创建数据库 a ，切换数据库 a</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.insertOne(&#123;<span class=\"string\">\"key1\"</span>:<span class=\"string\">\"value1\"</span>,<span class=\"string\">\"key2\"</span>:<span class=\"string\">\"value2\"</span>&#125;)<span class=\"comment\">//插入一行</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.insertMany([&#123;<span class=\"string\">\"key1\"</span>:value1,<span class=\"string\">\"key2\"</span>:<span class=\"string\">\"value2\"</span>&#125;,&#123;<span class=\"string\">\"key2\"</span>:value2&#125;,...]) <span class=\"comment\">//插入多行</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.find()  <span class=\"comment\">//查找数据库 里面 所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.find(&#123;<span class=\"attr\">key</span>:value&#125;,&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">0</span>&#125;) <span class=\"comment\">// &#123;key:value&#125;条件  查找符合这一条件的mongodb,&#123;\"_id\":0&#125;不想显示  id等条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.drop()<span class=\"comment\">// 删除mongodb的数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.a.remove(query(条件)) <span class=\"comment\">//可以根据条件删除 指定的 数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.help()<span class=\"comment\">// mongodb的帮助</span></span><br><span class=\"line\"></span><br><span class=\"line\">use music <span class=\"comment\">//music 文件夹</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.createCollection(<span class=\"string\">\"albums\"</span>) <span class=\"comment\">// 链接albums 的集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.getCollectionNames()  <span class=\"comment\">// 出现 [\"albums\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.insert([&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;,&#123;<span class=\"string\">\"key1\"</span>:<span class=\"string\">\"value\"</span>&#125;]) <span class=\"comment\">//新增多条</span></span><br><span class=\"line\"></span><br><span class=\"line\">db。albums.save([&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;,&#123;<span class=\"string\">\"key1\"</span>:<span class=\"string\">\"value\"</span>&#125;]) <span class=\"comment\">//新增多条</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.find()  <span class=\"comment\">//查找 albums </span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.help() <span class=\"comment\">//查看所有命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.music.find() <span class=\"comment\">//music必须得有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.states() <span class=\"comment\">//查看状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.update(query(查询条件),&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;&#125;) <span class=\"comment\">//修改一条</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.updateOne(query(查询条件),&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.albums.updateMany(query(查询条件),&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"value\"</span>&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">mongodb <span class=\"comment\">//我本人认为 修改 这一功能 不能够 一次 将 几条数据 分别改成 不一样的 value值</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"设置环境变量\"><a href=\"#设置环境变量\" class=\"headerlink\" title=\"设置环境变量\"></a>设置环境变量</h2><p>将 <code>F:\\software\\mongodb\\bin</code> 设置成环境变量就可以再任何盘连接数据库了<br>（注意：有的电脑可能因为权限问题，在 C 盘不能启动）<br><img src=\"/images/windows/path.png\"></p>\n<p>现在可以去其他盘随意连接数据库了</p>\n<h2 id=\"将-mongodb-作为-windows-服务启动\"><a href=\"#将-mongodb-作为-windows-服务启动\" class=\"headerlink\" title=\"将 mongodb 作为 windows 服务启动\"></a>将 mongodb 作为 windows 服务启动</h2><p>(暂未完成)</p>\n<p>以上启动服务器只是一次性的，当关闭了命令窗口，服务器即会关闭，可以将mongodb作为windows启动，这样一开机，mongodb服务就已经启动了 </p>\n<h2 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h2><p><a href=\"https://www.cnblogs.com/hongwest/p/7298257.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hongwest/p/7298257.html</a><br><a href=\"https://www.cnblogs.com/shirly77/p/6536327.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/shirly77/p/6536327.html</a></p>\n"},{"title":"git 账户切换的怪异处理方式","date":"2018-06-09T13:44:35.000Z","_content":"\n在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”\n\n指令： ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.xx\"\n\n执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub \n在你的编辑器里打开 id_rsa.pub\n复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。\n保存之后就OK了  ：）\n","source":"_posts/git-账户切换的怪异处理方式.md","raw":"---\ntitle: git 账户切换的怪异处理方式\ndate: 2018-06-09 21:44:35\ntags: git\ncategories: 指令\n---\n\n在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”\n\n指令： ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.xx\"\n\n执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub \n在你的编辑器里打开 id_rsa.pub\n复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。\n保存之后就OK了  ：）\n","slug":"git-账户切换的怪异处理方式","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bba10004fwvpkvdkeyvh","content":"<p>在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”</p>\n<p>指令： ssh-keygen -t rsa -b 4096 -C “<a href=\"mailto:xxx@xxx.xx\" target=\"_blank\" rel=\"noopener\">xxx@xxx.xx</a>“</p>\n<p>执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub<br>在你的编辑器里打开 id_rsa.pub<br>复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。<br>保存之后就OK了  ：）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”</p>\n<p>指令： ssh-keygen -t rsa -b 4096 -C “<a href=\"mailto:xxx@xxx.xx\" target=\"_blank\" rel=\"noopener\">xxx@xxx.xx</a>“</p>\n<p>执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub<br>在你的编辑器里打开 id_rsa.pub<br>复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。<br>保存之后就OK了  ：）</p>\n"},{"title":"hexo + github.io","date":"2018-06-05T16:14:18.000Z","_content":"\n### 第一步：需要的环境：\n   node环境  （[立即下载](https://nodejs.org/zh-cn/)）\n   git 环境  （[立即下载](https://git-scm.com/download/)）\n   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。\n    [安装 homebrw](https://brew.sh/)\n    [安装 yarn](https://yarnpkg.com/en/docs/install#mac-stable)\n### 第二步：安装 hexo:\n([也可以按照官方网站就行安装](https://hexo.io/zh-cn/docs/index.html))\n1. 安装 hexo\n```\n$ yarn add -g hexo-cli\n```\n2. 创建一个新的 hexo 项目\n```\n$ hexo init blog（项目名字）\ncd blog\n$ yarn install\n```\n3. 启动项目\n```\n$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000\n```\n\n项目文件结构为：\n\n![](/images/hexo-page.png)\n\n至此，我们本地的一个博客环境就已经搭建完成。\n常用的指令如下：([具体参数使用前查看详细文档](https://hexo.io/zh-cn/docs/commands.html))\n```\n$ hexo server = hexo s  // 启动项目\n$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage\n$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中\n$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）\n```\n### 第三步：更换主题\n现在为自己的博客找一个喜欢的主题：\n1. 进入[hexo 主题库](https://hexo.io/themes/)，选择一个自己喜欢的主题\n2. 点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来\n3. 将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字\n\n当前我所用的主题为 [clean-blog](https://github.com/klugjo/hexo-theme-clean-blog)\n\n### 第四步：搭建免费的 github.io 服务器\n\n首先明白什么是 github pages:\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n\n***特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的***\n\n\n1. 注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。\n\n2. 将本地环境推上线上环境，\n    1. 首先需要知道，如果直接访问 http://eagle.github.io 的时候，他会直接去找根目录下的 index.html 的静态文件。\n    2. Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问\n    3. 需要将hexo生成的静态文件，提交 commit 推到github上\n\n部署的方法一：\nhexo deploy ，可以参考 [官方的文档](https://hexo.io/docs/deployment.html)\n\n安装 hexo-deployer-git\n```\n$ yarn add hexo-deployer-git\n```\n配置：_config.xml\n```\ndeploy:\n  type: git\n  repo: git@github.com:jiji262/jiji262.github.io.git\n  branch: master\n```\n执行：\n```\n$ hexo d\n```\n\n执行之后可能会报错：\n```\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n则是因为没有设置好public key所致。\n在本机生成public key[参考github帮助](https://help.github.com/articles/connecting-to-github-with-ssh/)\n```\n$ ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\"\n```\n然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.\n然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。\n\n根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。\n\n部署方法二：\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。\n\n写一个发布脚本：deploy.sh\n```\nhexo generate\ncp -R public/* deploy/eagle.github.io\ncd deploy/eagle.github.io\ngit add .\ngit commit -m “update blog”\ngit push origin master\n```\n\n做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。\n\n至此，一个简单的博客建完  ^ - ^","source":"_posts/hexoGithubIo.md","raw":"---\ntitle: hexo + github.io\ndate: 2018-06-06 00:14:18\ntags: hexo\ncategories: 环境\n---\n\n### 第一步：需要的环境：\n   node环境  （[立即下载](https://nodejs.org/zh-cn/)）\n   git 环境  （[立即下载](https://git-scm.com/download/)）\n   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。\n    [安装 homebrw](https://brew.sh/)\n    [安装 yarn](https://yarnpkg.com/en/docs/install#mac-stable)\n### 第二步：安装 hexo:\n([也可以按照官方网站就行安装](https://hexo.io/zh-cn/docs/index.html))\n1. 安装 hexo\n```\n$ yarn add -g hexo-cli\n```\n2. 创建一个新的 hexo 项目\n```\n$ hexo init blog（项目名字）\ncd blog\n$ yarn install\n```\n3. 启动项目\n```\n$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000\n```\n\n项目文件结构为：\n\n![](/images/hexo-page.png)\n\n至此，我们本地的一个博客环境就已经搭建完成。\n常用的指令如下：([具体参数使用前查看详细文档](https://hexo.io/zh-cn/docs/commands.html))\n```\n$ hexo server = hexo s  // 启动项目\n$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage\n$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中\n$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）\n```\n### 第三步：更换主题\n现在为自己的博客找一个喜欢的主题：\n1. 进入[hexo 主题库](https://hexo.io/themes/)，选择一个自己喜欢的主题\n2. 点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来\n3. 将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字\n\n当前我所用的主题为 [clean-blog](https://github.com/klugjo/hexo-theme-clean-blog)\n\n### 第四步：搭建免费的 github.io 服务器\n\n首先明白什么是 github pages:\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n\n***特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的***\n\n\n1. 注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。\n\n2. 将本地环境推上线上环境，\n    1. 首先需要知道，如果直接访问 http://eagle.github.io 的时候，他会直接去找根目录下的 index.html 的静态文件。\n    2. Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问\n    3. 需要将hexo生成的静态文件，提交 commit 推到github上\n\n部署的方法一：\nhexo deploy ，可以参考 [官方的文档](https://hexo.io/docs/deployment.html)\n\n安装 hexo-deployer-git\n```\n$ yarn add hexo-deployer-git\n```\n配置：_config.xml\n```\ndeploy:\n  type: git\n  repo: git@github.com:jiji262/jiji262.github.io.git\n  branch: master\n```\n执行：\n```\n$ hexo d\n```\n\n执行之后可能会报错：\n```\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n则是因为没有设置好public key所致。\n在本机生成public key[参考github帮助](https://help.github.com/articles/connecting-to-github-with-ssh/)\n```\n$ ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\"\n```\n然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.\n然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。\n\n根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。\n\n部署方法二：\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。\n\n写一个发布脚本：deploy.sh\n```\nhexo generate\ncp -R public/* deploy/eagle.github.io\ncd deploy/eagle.github.io\ngit add .\ngit commit -m “update blog”\ngit push origin master\n```\n\n做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。\n\n至此，一个简单的博客建完  ^ - ^","slug":"hexoGithubIo","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bba30005fwvpioj2zyl5","content":"<h3 id=\"第一步：需要的环境：\"><a href=\"#第一步：需要的环境：\" class=\"headerlink\" title=\"第一步：需要的环境：\"></a>第一步：需要的环境：</h3><p>   node环境  （<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   git 环境  （<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。<br>    <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">安装 homebrw</a><br>    <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\" target=\"_blank\" rel=\"noopener\">安装 yarn</a></p>\n<h3 id=\"第二步：安装-hexo\"><a href=\"#第二步：安装-hexo\" class=\"headerlink\" title=\"第二步：安装 hexo:\"></a>第二步：安装 hexo:</h3><p>(<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">也可以按照官方网站就行安装</a>)</p>\n<ol>\n<li><p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个新的 hexo 项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog（项目名字）</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>项目文件结构为：</p>\n<p><img src=\"/images/hexo-page.png\" alt=\"\"></p>\n<p>至此，我们本地的一个博客环境就已经搭建完成。<br>常用的指令如下：(<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">具体参数使用前查看详细文档</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server = hexo s  // 启动项目</span><br><span class=\"line\">$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage</span><br><span class=\"line\">$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中</span><br><span class=\"line\">$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：更换主题\"><a href=\"#第三步：更换主题\" class=\"headerlink\" title=\"第三步：更换主题\"></a>第三步：更换主题</h3><p>现在为自己的博客找一个喜欢的主题：</p>\n<ol>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo 主题库</a>，选择一个自己喜欢的主题</li>\n<li>点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来</li>\n<li>将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字</li>\n</ol>\n<p>当前我所用的主题为 <a href=\"https://github.com/klugjo/hexo-theme-clean-blog\" target=\"_blank\" rel=\"noopener\">clean-blog</a></p>\n<h3 id=\"第四步：搭建免费的-github-io-服务器\"><a href=\"#第四步：搭建免费的-github-io-服务器\" class=\"headerlink\" title=\"第四步：搭建免费的 github.io 服务器\"></a>第四步：搭建免费的 github.io 服务器</h3><p>首先明白什么是 github pages:<br>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>\n<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。</p>\n<p><strong><em>特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的</em></strong></p>\n<ol>\n<li><p>注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。</p>\n</li>\n<li><p>将本地环境推上线上环境，</p>\n<ol>\n<li>首先需要知道，如果直接访问 <a href=\"http://eagle.github.io\" target=\"_blank\" rel=\"noopener\">http://eagle.github.io</a> 的时候，他会直接去找根目录下的 index.html 的静态文件。</li>\n<li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问</li>\n<li>需要将hexo生成的静态文件，提交 commit 推到github上</li>\n</ol>\n</li>\n</ol>\n<p>部署的方法一：<br>hexo deploy ，可以参考 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">官方的文档</a></p>\n<p>安装 hexo-deployer-git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure></p>\n<p>配置：_config.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>执行之后可能会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure></p>\n<p>则是因为没有设置好public key所致。<br>在本机生成public key<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">参考github帮助</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.<br>然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。</p>\n<p>根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。</p>\n<p>部署方法二：</p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。</p>\n<p>写一个发布脚本：deploy.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* deploy/eagle.github.io</span><br><span class=\"line\">cd deploy/eagle.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “update blog”</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p>做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。</p>\n<p>至此，一个简单的博客建完  ^ - ^</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第一步：需要的环境：\"><a href=\"#第一步：需要的环境：\" class=\"headerlink\" title=\"第一步：需要的环境：\"></a>第一步：需要的环境：</h3><p>   node环境  （<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   git 环境  （<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。<br>    <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">安装 homebrw</a><br>    <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\" target=\"_blank\" rel=\"noopener\">安装 yarn</a></p>\n<h3 id=\"第二步：安装-hexo\"><a href=\"#第二步：安装-hexo\" class=\"headerlink\" title=\"第二步：安装 hexo:\"></a>第二步：安装 hexo:</h3><p>(<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">也可以按照官方网站就行安装</a>)</p>\n<ol>\n<li><p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个新的 hexo 项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog（项目名字）</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>项目文件结构为：</p>\n<p><img src=\"/images/hexo-page.png\" alt=\"\"></p>\n<p>至此，我们本地的一个博客环境就已经搭建完成。<br>常用的指令如下：(<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">具体参数使用前查看详细文档</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server = hexo s  // 启动项目</span><br><span class=\"line\">$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage</span><br><span class=\"line\">$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中</span><br><span class=\"line\">$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：更换主题\"><a href=\"#第三步：更换主题\" class=\"headerlink\" title=\"第三步：更换主题\"></a>第三步：更换主题</h3><p>现在为自己的博客找一个喜欢的主题：</p>\n<ol>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo 主题库</a>，选择一个自己喜欢的主题</li>\n<li>点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来</li>\n<li>将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字</li>\n</ol>\n<p>当前我所用的主题为 <a href=\"https://github.com/klugjo/hexo-theme-clean-blog\" target=\"_blank\" rel=\"noopener\">clean-blog</a></p>\n<h3 id=\"第四步：搭建免费的-github-io-服务器\"><a href=\"#第四步：搭建免费的-github-io-服务器\" class=\"headerlink\" title=\"第四步：搭建免费的 github.io 服务器\"></a>第四步：搭建免费的 github.io 服务器</h3><p>首先明白什么是 github pages:<br>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>\n<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。</p>\n<p><strong><em>特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的</em></strong></p>\n<ol>\n<li><p>注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。</p>\n</li>\n<li><p>将本地环境推上线上环境，</p>\n<ol>\n<li>首先需要知道，如果直接访问 <a href=\"http://eagle.github.io\" target=\"_blank\" rel=\"noopener\">http://eagle.github.io</a> 的时候，他会直接去找根目录下的 index.html 的静态文件。</li>\n<li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问</li>\n<li>需要将hexo生成的静态文件，提交 commit 推到github上</li>\n</ol>\n</li>\n</ol>\n<p>部署的方法一：<br>hexo deploy ，可以参考 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">官方的文档</a></p>\n<p>安装 hexo-deployer-git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure></p>\n<p>配置：_config.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>执行之后可能会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure></p>\n<p>则是因为没有设置好public key所致。<br>在本机生成public key<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">参考github帮助</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.<br>然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。</p>\n<p>根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。</p>\n<p>部署方法二：</p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。</p>\n<p>写一个发布脚本：deploy.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* deploy/eagle.github.io</span><br><span class=\"line\">cd deploy/eagle.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “update blog”</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p>做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。</p>\n<p>至此，一个简单的博客建完  ^ - ^</p>\n"},{"title":"Git Command","date":"2018-06-09T12:51:35.000Z","_content":"\n使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：\n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 配置 git\n\n1. git 基本配置：\n\ngit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置（如果加 --global 表示设置全局）\n$ git config --list [--global]\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息 \n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n2. fork 代码库\n\n\n如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。\n```\n# 显示所有远程仓库\n$ git remote -v\n\n# 查看帮助\n$ git remote —help  \n\n# 删除 origin\n$ git remote remove origin  \n\n# 将当前的代码塞进刚建的心的项目\n$ git remote add origin [url]\n\n# 推送当前的代码到远程的 master 分支\n$ git push -u origin master\n\n# 监听版本更新:\n$ git remote add upstream [url]\n```\n### 文件管理\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 分支管理\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n### commit 管理\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 同步远程分支\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销某些操作\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 撤回上一次 commit\n$ git reset HEAD^\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。\nmerge 命令不会保留 merge 的分支的 commit\nrebase 命令会保留 merge 的分支的 commit\n\n\n```\n# 从源分支进行变基\n$ git rebase origin\n\n# 变基倒数三个 commit\n$ git rebase -i HEAD~3\n\n# 继续执行\n$ git rebase --continue\n\n# 停止变基\n$ git rebase --abort\n```","source":"_posts/gitCommand.md","raw":"---\ntitle: Git Command\ndate: 2018-06-09 20:51:35\ntags: ['git', '指令']\ncategories: 指令\n---\n\n使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：\n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 配置 git\n\n1. git 基本配置：\n\ngit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置（如果加 --global 表示设置全局）\n$ git config --list [--global]\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息 \n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n2. fork 代码库\n\n\n如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。\n```\n# 显示所有远程仓库\n$ git remote -v\n\n# 查看帮助\n$ git remote —help  \n\n# 删除 origin\n$ git remote remove origin  \n\n# 将当前的代码塞进刚建的心的项目\n$ git remote add origin [url]\n\n# 推送当前的代码到远程的 master 分支\n$ git push -u origin master\n\n# 监听版本更新:\n$ git remote add upstream [url]\n```\n### 文件管理\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 分支管理\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n### commit 管理\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 同步远程分支\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销某些操作\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 撤回上一次 commit\n$ git reset HEAD^\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。\nmerge 命令不会保留 merge 的分支的 commit\nrebase 命令会保留 merge 的分支的 commit\n\n\n```\n# 从源分支进行变基\n$ git rebase origin\n\n# 变基倒数三个 commit\n$ git rebase -i HEAD~3\n\n# 继续执行\n$ git rebase --continue\n\n# 停止变基\n$ git rebase --abort\n```","slug":"gitCommand","published":1,"updated":"2018-09-29T06:38:48.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bba50007fwvpartfaqg4","content":"<p>使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：</p>\n<h3 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个目录，将其初始化为Git代码库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 下载一个项目和它的整个代码历史</span><br><span class=\"line\">$ git clone [url]</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><ol>\n<li>git 基本配置：</li>\n</ol>\n<p>git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前的Git配置（如果加 --global 表示设置全局）</span><br><span class=\"line\">$ git config --list [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 编辑Git配置文件</span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置提交代码时的用户信息 </span><br><span class=\"line\">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>fork 代码库</li>\n</ol>\n<p>如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看帮助</span><br><span class=\"line\">$ git remote —help  </span><br><span class=\"line\"></span><br><span class=\"line\"># 删除 origin</span><br><span class=\"line\">$ git remote remove origin  </span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前的代码塞进刚建的心的项目</span><br><span class=\"line\">$ git remote add origin [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送当前的代码到远程的 master 分支</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"># 监听版本更新:</span><br><span class=\"line\">$ git remote add upstream [url]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加每个变化前，都会要求确认</span><br><span class=\"line\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 改名文件，并且将这个改名放入暂存区</span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class=\"line\">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-管理\"><a href=\"#commit-管理\" class=\"headerlink\" title=\"commit 管理\"></a>commit 管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区</span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit [file1] [file2] ... -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时显示所有diff信息</span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"line\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重做上一次commit，并包括指定文件的新变化</span><br><span class=\"line\">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示有变更的文件</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的版本历史</span><br><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class=\"line\">$ git log --stat</span><br><span class=\"line\"></span><br><span class=\"line\"># 搜索提交历史，根据关键词</span><br><span class=\"line\">$ git log -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class=\"line\">$ git log [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class=\"line\">$ git log [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个文件的版本历史，包括文件改名</span><br><span class=\"line\">$ git log --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件相关的每一次diff</span><br><span class=\"line\">$ git log -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示过去5次提交</span><br><span class=\"line\">$ git log -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有提交过的用户，按提交次数排序</span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件是什么人在什么时间修改过</span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和工作区的差异</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和上一个commit的差异</span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示工作区与当前分支最新commit之间的差异</span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示两次提交之间的差异</span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示今天你写了多少行代码</span><br><span class=\"line\">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交的元数据和内容变化</span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交发生变化的文件</span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交时，某个文件的内容</span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的最近几次提交</span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载远程仓库的所有变动</span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个远程仓库的信息</span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个新的远程仓库，并命名</span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 取回远程仓库的变化，并与本地分支合并</span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 上传本地指定分支到远程仓库</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销某些操作\"><a href=\"#撤销某些操作\" class=\"headerlink\" title=\"撤销某些操作\"></a>撤销某些操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 恢复暂存区的指定文件到工作区</span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复暂存区的所有文件到工作区</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 撤回上一次 commit</span><br><span class=\"line\">$ git reset HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂时将未提交的变化移除，稍后再移入</span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。<br>merge 命令不会保留 merge 的分支的 commit<br>rebase 命令会保留 merge 的分支的 commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从源分支进行变基</span><br><span class=\"line\">$ git rebase origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 变基倒数三个 commit</span><br><span class=\"line\">$ git rebase -i HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\"># 继续执行</span><br><span class=\"line\">$ git rebase --continue</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止变基</span><br><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：</p>\n<h3 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个目录，将其初始化为Git代码库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 下载一个项目和它的整个代码历史</span><br><span class=\"line\">$ git clone [url]</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><ol>\n<li>git 基本配置：</li>\n</ol>\n<p>git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前的Git配置（如果加 --global 表示设置全局）</span><br><span class=\"line\">$ git config --list [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 编辑Git配置文件</span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置提交代码时的用户信息 </span><br><span class=\"line\">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>fork 代码库</li>\n</ol>\n<p>如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看帮助</span><br><span class=\"line\">$ git remote —help  </span><br><span class=\"line\"></span><br><span class=\"line\"># 删除 origin</span><br><span class=\"line\">$ git remote remove origin  </span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前的代码塞进刚建的心的项目</span><br><span class=\"line\">$ git remote add origin [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送当前的代码到远程的 master 分支</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"># 监听版本更新:</span><br><span class=\"line\">$ git remote add upstream [url]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加每个变化前，都会要求确认</span><br><span class=\"line\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 改名文件，并且将这个改名放入暂存区</span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class=\"line\">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-管理\"><a href=\"#commit-管理\" class=\"headerlink\" title=\"commit 管理\"></a>commit 管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区</span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit [file1] [file2] ... -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时显示所有diff信息</span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"line\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重做上一次commit，并包括指定文件的新变化</span><br><span class=\"line\">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示有变更的文件</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的版本历史</span><br><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class=\"line\">$ git log --stat</span><br><span class=\"line\"></span><br><span class=\"line\"># 搜索提交历史，根据关键词</span><br><span class=\"line\">$ git log -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class=\"line\">$ git log [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class=\"line\">$ git log [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个文件的版本历史，包括文件改名</span><br><span class=\"line\">$ git log --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件相关的每一次diff</span><br><span class=\"line\">$ git log -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示过去5次提交</span><br><span class=\"line\">$ git log -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有提交过的用户，按提交次数排序</span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件是什么人在什么时间修改过</span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和工作区的差异</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和上一个commit的差异</span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示工作区与当前分支最新commit之间的差异</span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示两次提交之间的差异</span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示今天你写了多少行代码</span><br><span class=\"line\">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交的元数据和内容变化</span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交发生变化的文件</span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交时，某个文件的内容</span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的最近几次提交</span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载远程仓库的所有变动</span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个远程仓库的信息</span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个新的远程仓库，并命名</span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 取回远程仓库的变化，并与本地分支合并</span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 上传本地指定分支到远程仓库</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销某些操作\"><a href=\"#撤销某些操作\" class=\"headerlink\" title=\"撤销某些操作\"></a>撤销某些操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 恢复暂存区的指定文件到工作区</span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复暂存区的所有文件到工作区</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 撤回上一次 commit</span><br><span class=\"line\">$ git reset HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂时将未提交的变化移除，稍后再移入</span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。<br>merge 命令不会保留 merge 的分支的 commit<br>rebase 命令会保留 merge 的分支的 commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从源分支进行变基</span><br><span class=\"line\">$ git rebase origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 变基倒数三个 commit</span><br><span class=\"line\">$ git rebase -i HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\"># 继续执行</span><br><span class=\"line\">$ git rebase --continue</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止变基</span><br><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure>"},{"title":"js 继承方式","date":"2018-06-21T15:36:41.000Z","_content":"\nJS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。\n\n需要实现继承必须现有父类，首先定义一个父类。\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1. 原型链继承\n\n核心： 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.eat('fish'));\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); //true \n\nconsole.log(cat instanceof Cat); //true\n```\n\n> 补充小知识点： \n>\n> ` object instanceof constructor ` 中:\n> \n> instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。\n\n2. 父类新增原型方法/原型属性，子类都能访问到。\n\n3. 简单，易于实现。\n\n缺点：\n\n1. 如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。\n\n2. 无法实现多继承。\n\n3. 来自原型对象的引用属性是所有实例共享的。\n\n4. 创建子类实例时，无法向父类构造函数传参。\n\n## 2、构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); // false\n\nconsole.log(cat instanceof Cat); // true\n```\n\n> 补充小知识：\n> \n> call, apply 和 bind 的区别:\n>\n> 它们在功能上是没有区别的，都是改变 ` this ` 的指向。他们主要的区别是实现方式和传递的参数不同。\n> \n> 1. call: Fun.call(object, arg1, arg2....); \n> \n> 2. apply: Fun.apply(object, [arg1, arg2....]);\n> \n> 3. bind: Fun.bind(object, arg1, arg2, ....); \n> \n> 其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2...)），Fun 接受几个参数，后面的 arg 就有几个。\n\n特点：\n\n1. 可以实现多继承（call多个父类对象）\n\n2. 创建子类实例时，可以向父类传递参数\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）\n\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n## 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n\n2. 不支持多继承\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n## 5、组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n\n2. 既是子类的实例，也是父类的实例\n\n3. 不存在引用属性共享问题\n\n4. 可传参\n\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n## 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\nCat.prototype.constructor = Cat; // 需要修复下构造函数\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\\\n```","source":"_posts/js-继承方式.md","raw":"---\ntitle: js 继承方式\ndate: 2018-06-21 23:36:41\ntags: js\ncategories: js\n---\n\nJS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。\n\n需要实现继承必须现有父类，首先定义一个父类。\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1. 原型链继承\n\n核心： 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.eat('fish'));\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); //true \n\nconsole.log(cat instanceof Cat); //true\n```\n\n> 补充小知识点： \n>\n> ` object instanceof constructor ` 中:\n> \n> instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。\n\n2. 父类新增原型方法/原型属性，子类都能访问到。\n\n3. 简单，易于实现。\n\n缺点：\n\n1. 如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。\n\n2. 无法实现多继承。\n\n3. 来自原型对象的引用属性是所有实例共享的。\n\n4. 创建子类实例时，无法向父类构造函数传参。\n\n## 2、构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); // false\n\nconsole.log(cat instanceof Cat); // true\n```\n\n> 补充小知识：\n> \n> call, apply 和 bind 的区别:\n>\n> 它们在功能上是没有区别的，都是改变 ` this ` 的指向。他们主要的区别是实现方式和传递的参数不同。\n> \n> 1. call: Fun.call(object, arg1, arg2....); \n> \n> 2. apply: Fun.apply(object, [arg1, arg2....]);\n> \n> 3. bind: Fun.bind(object, arg1, arg2, ....); \n> \n> 其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2...)），Fun 接受几个参数，后面的 arg 就有几个。\n\n特点：\n\n1. 可以实现多继承（call多个父类对象）\n\n2. 创建子类实例时，可以向父类传递参数\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）\n\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n## 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n\n2. 不支持多继承\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n## 5、组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n\n2. 既是子类的实例，也是父类的实例\n\n3. 不存在引用属性共享问题\n\n4. 可传参\n\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n## 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\nCat.prototype.constructor = Cat; // 需要修复下构造函数\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\\\n```","slug":"js-继承方式","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bba8000afwvpmd7m9phg","content":"<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。</p>\n<p>需要实现继承必须现有父类，首先定义一个父类。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h2><p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识点： </p>\n<p><code>object instanceof constructor</code> 中:</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例。</p>\n</li>\n<li><p>父类新增原型方法/原型属性，子类都能访问到。</p>\n</li>\n<li><p>简单，易于实现。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。</p>\n</li>\n<li><p>无法实现多继承。</p>\n</li>\n<li><p>来自原型对象的引用属性是所有实例共享的。</p>\n</li>\n<li><p>创建子类实例时，无法向父类构造函数传参。</p>\n</li>\n</ol>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识：</p>\n<p>call, apply 和 bind 的区别:</p>\n<p>它们在功能上是没有区别的，都是改变 <code>this</code> 的指向。他们主要的区别是实现方式和传递的参数不同。</p>\n<ol>\n<li><p>call: Fun.call(object, arg1, arg2….); </p>\n</li>\n<li><p>apply: Fun.apply(object, [arg1, arg2….]);</p>\n</li>\n<li><p>bind: Fun.bind(object, arg1, arg2, ….); </p>\n</li>\n</ol>\n<p>其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2…)），Fun 接受几个参数，后面的 arg 就有几个。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>可以实现多继承（call多个父类对象）</p>\n</li>\n<li><p>创建子类实例时，可以向父类传递参数</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）</p>\n</li>\n<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n</li>\n</ol>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例是父类的实例，不是子类的实例</p>\n</li>\n<li><p>不支持多继承</p>\n</li>\n</ol>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n</li>\n<li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n</li>\n</ol>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p>\n</li>\n<li><p>既是子类的实例，也是父类的实例</p>\n</li>\n<li><p>不存在引用属性共享问题</p>\n</li>\n<li><p>可传参</p>\n</li>\n<li><p>函数可复用</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; <span class=\"comment\">// 需要修复下构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true\\</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。</p>\n<p>需要实现继承必须现有父类，首先定义一个父类。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h2><p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识点： </p>\n<p><code>object instanceof constructor</code> 中:</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例。</p>\n</li>\n<li><p>父类新增原型方法/原型属性，子类都能访问到。</p>\n</li>\n<li><p>简单，易于实现。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。</p>\n</li>\n<li><p>无法实现多继承。</p>\n</li>\n<li><p>来自原型对象的引用属性是所有实例共享的。</p>\n</li>\n<li><p>创建子类实例时，无法向父类构造函数传参。</p>\n</li>\n</ol>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识：</p>\n<p>call, apply 和 bind 的区别:</p>\n<p>它们在功能上是没有区别的，都是改变 <code>this</code> 的指向。他们主要的区别是实现方式和传递的参数不同。</p>\n<ol>\n<li><p>call: Fun.call(object, arg1, arg2….); </p>\n</li>\n<li><p>apply: Fun.apply(object, [arg1, arg2….]);</p>\n</li>\n<li><p>bind: Fun.bind(object, arg1, arg2, ….); </p>\n</li>\n</ol>\n<p>其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2…)），Fun 接受几个参数，后面的 arg 就有几个。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>可以实现多继承（call多个父类对象）</p>\n</li>\n<li><p>创建子类实例时，可以向父类传递参数</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）</p>\n</li>\n<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n</li>\n</ol>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例是父类的实例，不是子类的实例</p>\n</li>\n<li><p>不支持多继承</p>\n</li>\n</ol>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n</li>\n<li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n</li>\n</ol>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p>\n</li>\n<li><p>既是子类的实例，也是父类的实例</p>\n</li>\n<li><p>不存在引用属性共享问题</p>\n</li>\n<li><p>可传参</p>\n</li>\n<li><p>函数可复用</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; <span class=\"comment\">// 需要修复下构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true\\</span></span><br></pre></td></tr></table></figure>"},{"title":"js-银行卡号格式化","date":"2018-08-09T08:38:14.000Z","_content":"# 银行卡号 JS 格式化\n\n最近面试遇到一个问题：写一个银行卡号格式化的方法<br />\n例如：`6201222200003224566    =>    6201 2222 0000 3224 566`<br />\n当时没想到使用正则，面试官提醒了一句我也没能想起来，面试完之后我才查了一下，最简单的方式就是使用正则的 `replace`。<br />\n### 关键代码\n\n```js\nlet cardNumber = '6201222200003224566';\ncardNumber = cardNumber.replace(/(\\d{4})(?=\\d)/g, \"$1 \");\n// 输出结果为: \"6201 2222 0000 3224 566\"\n```\n\n### 使用场景\n\n在 input 输入框中显示格式化的银行卡号\n\n> 注意：一般在数据库中存储的数据都是不带格式的原始数据，按照银行卡号格式展示只在前端进行格式化。\n\n### 反向去除空格的关键代码\n\n```js\nlet cardNumber = \"1234 4567 8901 2345 111\";\ncardNumber = cardNumber.replace(/\\s/g, '');\n//  输出结果为：\"1234456789012345111\"\n```\n","source":"_posts/js-银行卡号格式化.md","raw":"---\ntitle: js-银行卡号格式化\ndate: 2018-08-09 16:38:14\ntags: js\n---\n# 银行卡号 JS 格式化\n\n最近面试遇到一个问题：写一个银行卡号格式化的方法<br />\n例如：`6201222200003224566    =>    6201 2222 0000 3224 566`<br />\n当时没想到使用正则，面试官提醒了一句我也没能想起来，面试完之后我才查了一下，最简单的方式就是使用正则的 `replace`。<br />\n### 关键代码\n\n```js\nlet cardNumber = '6201222200003224566';\ncardNumber = cardNumber.replace(/(\\d{4})(?=\\d)/g, \"$1 \");\n// 输出结果为: \"6201 2222 0000 3224 566\"\n```\n\n### 使用场景\n\n在 input 输入框中显示格式化的银行卡号\n\n> 注意：一般在数据库中存储的数据都是不带格式的原始数据，按照银行卡号格式展示只在前端进行格式化。\n\n### 反向去除空格的关键代码\n\n```js\nlet cardNumber = \"1234 4567 8901 2345 111\";\ncardNumber = cardNumber.replace(/\\s/g, '');\n//  输出结果为：\"1234456789012345111\"\n```\n","slug":"js-银行卡号格式化","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbaa000bfwvpzab8usmd","content":"<h1 id=\"银行卡号-JS-格式化\"><a href=\"#银行卡号-JS-格式化\" class=\"headerlink\" title=\"银行卡号 JS 格式化\"></a>银行卡号 JS 格式化</h1><p>最近面试遇到一个问题：写一个银行卡号格式化的方法<br><br>例如：<code>6201222200003224566    =&gt;    6201 2222 0000 3224 566</code><br><br>当时没想到使用正则，面试官提醒了一句我也没能想起来，面试完之后我才查了一下，最简单的方式就是使用正则的 <code>replace</code>。<br></p>\n<h3 id=\"关键代码\"><a href=\"#关键代码\" class=\"headerlink\" title=\"关键代码\"></a>关键代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cardNumber = <span class=\"string\">'6201222200003224566'</span>;</span><br><span class=\"line\">cardNumber = cardNumber.replace(<span class=\"regexp\">/(\\d&#123;4&#125;)(?=\\d)/g</span>, <span class=\"string\">\"$1 \"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出结果为: \"6201 2222 0000 3224 566\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>在 input 输入框中显示格式化的银行卡号</p>\n<blockquote>\n<p>注意：一般在数据库中存储的数据都是不带格式的原始数据，按照银行卡号格式展示只在前端进行格式化。</p>\n</blockquote>\n<h3 id=\"反向去除空格的关键代码\"><a href=\"#反向去除空格的关键代码\" class=\"headerlink\" title=\"反向去除空格的关键代码\"></a>反向去除空格的关键代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cardNumber = <span class=\"string\">\"1234 4567 8901 2345 111\"</span>;</span><br><span class=\"line\">cardNumber = cardNumber.replace(<span class=\"regexp\">/\\s/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"comment\">//  输出结果为：\"1234456789012345111\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"银行卡号-JS-格式化\"><a href=\"#银行卡号-JS-格式化\" class=\"headerlink\" title=\"银行卡号 JS 格式化\"></a>银行卡号 JS 格式化</h1><p>最近面试遇到一个问题：写一个银行卡号格式化的方法<br><br>例如：<code>6201222200003224566    =&gt;    6201 2222 0000 3224 566</code><br><br>当时没想到使用正则，面试官提醒了一句我也没能想起来，面试完之后我才查了一下，最简单的方式就是使用正则的 <code>replace</code>。<br></p>\n<h3 id=\"关键代码\"><a href=\"#关键代码\" class=\"headerlink\" title=\"关键代码\"></a>关键代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cardNumber = <span class=\"string\">'6201222200003224566'</span>;</span><br><span class=\"line\">cardNumber = cardNumber.replace(<span class=\"regexp\">/(\\d&#123;4&#125;)(?=\\d)/g</span>, <span class=\"string\">\"$1 \"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出结果为: \"6201 2222 0000 3224 566\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>在 input 输入框中显示格式化的银行卡号</p>\n<blockquote>\n<p>注意：一般在数据库中存储的数据都是不带格式的原始数据，按照银行卡号格式展示只在前端进行格式化。</p>\n</blockquote>\n<h3 id=\"反向去除空格的关键代码\"><a href=\"#反向去除空格的关键代码\" class=\"headerlink\" title=\"反向去除空格的关键代码\"></a>反向去除空格的关键代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cardNumber = <span class=\"string\">\"1234 4567 8901 2345 111\"</span>;</span><br><span class=\"line\">cardNumber = cardNumber.replace(<span class=\"regexp\">/\\s/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"comment\">//  输出结果为：\"1234456789012345111\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"let、var、const","date":"2018-06-22T03:20:15.000Z","_content":"\nlet、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。\n\n## 首先来说 let 和 var 的异同。\n\n` let ` 声明的用法与 ` var ` 一致，` let ` 声明的变量可以把变量限制在作用域的代码中。\n\n1. 声明后未赋值，表现相同\n\n```\n(function() {\n  var varTest;\n  let letTest;\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 undefined\n}());\n```\n\n2. 使用未声明的变量，表现不同\n\n```\n(function() {\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 Error: letTest is not defined\n\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n}());\n```\n\n3. 不允许重复申明一个变量\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  var varTest = 'varTest changed.';\n  let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared\n\n  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)\n  console.log(letTest);\n}());\n```\n\n4. 不同作用域申明变量不一样\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  {\n    var varTest = 'varTest changed.';\n    let letTest = 'letTest changed.';\n  }\n\n  console.log(varTest); //输出\"varTest changed.\"，内部\"{}\"中声明的varTest变量覆盖外部的letTest声明\n  console.log(letTest); //输出\"test let OK.\"，内部\"{}\"中声明的letTest和外部的letTest不是同一个变量\n}());\n```\n\n## const\n\n1. ` const ` 声明的是常量，起止一旦设定后不可修改。因此，` const ` 常量声明是必须进行初始化。\n\n2.  ` const ` 声明的常量和 ` let ` 一样都有作用域的限制。\n\n3. 常量也不可以重复声明变量，无论该变量是 ` var ` 或者 ` let ` 声明的。","source":"_posts/let-vs-var.md","raw":"---\ntitle: let、var、const\ndate: 2018-06-22 11:20:15\ntags: js\ncategories: js\n---\n\nlet、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。\n\n## 首先来说 let 和 var 的异同。\n\n` let ` 声明的用法与 ` var ` 一致，` let ` 声明的变量可以把变量限制在作用域的代码中。\n\n1. 声明后未赋值，表现相同\n\n```\n(function() {\n  var varTest;\n  let letTest;\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 undefined\n}());\n```\n\n2. 使用未声明的变量，表现不同\n\n```\n(function() {\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 Error: letTest is not defined\n\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n}());\n```\n\n3. 不允许重复申明一个变量\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  var varTest = 'varTest changed.';\n  let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared\n\n  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)\n  console.log(letTest);\n}());\n```\n\n4. 不同作用域申明变量不一样\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  {\n    var varTest = 'varTest changed.';\n    let letTest = 'letTest changed.';\n  }\n\n  console.log(varTest); //输出\"varTest changed.\"，内部\"{}\"中声明的varTest变量覆盖外部的letTest声明\n  console.log(letTest); //输出\"test let OK.\"，内部\"{}\"中声明的letTest和外部的letTest不是同一个变量\n}());\n```\n\n## const\n\n1. ` const ` 声明的是常量，起止一旦设定后不可修改。因此，` const ` 常量声明是必须进行初始化。\n\n2.  ` const ` 声明的常量和 ` let ` 一样都有作用域的限制。\n\n3. 常量也不可以重复声明变量，无论该变量是 ` var ` 或者 ` let ` 声明的。","slug":"let-vs-var","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbad000efwvpxvsr0z80","content":"<p>let、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。</p>\n<h2 id=\"首先来说-let-和-var-的异同。\"><a href=\"#首先来说-let-和-var-的异同。\" class=\"headerlink\" title=\"首先来说 let 和 var 的异同。\"></a>首先来说 let 和 var 的异同。</h2><p><code>let</code> 声明的用法与 <code>var</code> 一致，<code>let</code> 声明的变量可以把变量限制在作用域的代码中。</p>\n<ol>\n<li>声明后未赋值，表现相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest;</span><br><span class=\"line\">  let letTest;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 undefined</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用未声明的变量，表现不同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 Error: letTest is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>不允许重复申明一个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">  let letTest = &apos;letTest changed.&apos;; //直接报错：SyntaxError: Identifier &apos;letTest&apos; has already been declared</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span><br><span class=\"line\">  console.log(letTest);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不同作用域申明变量不一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">    let letTest = &apos;letTest changed.&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明</span><br><span class=\"line\">  console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><p><code>const</code> 声明的是常量，起止一旦设定后不可修改。因此，<code>const</code> 常量声明是必须进行初始化。</p>\n</li>\n<li><p><code>const</code> 声明的常量和 <code>let</code> 一样都有作用域的限制。</p>\n</li>\n<li><p>常量也不可以重复声明变量，无论该变量是 <code>var</code> 或者 <code>let</code> 声明的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>let、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。</p>\n<h2 id=\"首先来说-let-和-var-的异同。\"><a href=\"#首先来说-let-和-var-的异同。\" class=\"headerlink\" title=\"首先来说 let 和 var 的异同。\"></a>首先来说 let 和 var 的异同。</h2><p><code>let</code> 声明的用法与 <code>var</code> 一致，<code>let</code> 声明的变量可以把变量限制在作用域的代码中。</p>\n<ol>\n<li>声明后未赋值，表现相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest;</span><br><span class=\"line\">  let letTest;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 undefined</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用未声明的变量，表现不同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 Error: letTest is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>不允许重复申明一个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">  let letTest = &apos;letTest changed.&apos;; //直接报错：SyntaxError: Identifier &apos;letTest&apos; has already been declared</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span><br><span class=\"line\">  console.log(letTest);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不同作用域申明变量不一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">    let letTest = &apos;letTest changed.&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明</span><br><span class=\"line\">  console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><p><code>const</code> 声明的是常量，起止一旦设定后不可修改。因此，<code>const</code> 常量声明是必须进行初始化。</p>\n</li>\n<li><p><code>const</code> 声明的常量和 <code>let</code> 一样都有作用域的限制。</p>\n</li>\n<li><p>常量也不可以重复声明变量，无论该变量是 <code>var</code> 或者 <code>let</code> 声明的。</p>\n</li>\n</ol>\n"},{"title":"cookie、localStorage 和 sessionStorage","date":"2018-06-23T14:23:28.000Z","_content":"\n### Cookie\n\ncookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n一般而言，cookies 会由服务端发送给客户端，客户端存储下来，然后在随后让请求中再发回给服务端。这可以用于诸如管理用户会话，追踪用户信息等事情。此外，客户端也用使用 cookies 存储数据。因而，cookies 常被用于存储一些通用的数据，如用户的首选项设置。\n\n#### 优缺点：\n优点：\n- 能用于和服务端通信\n- 当 cookie 快要自动过期时，我们可以重新设置而不是删除\n\n缺点：\n- 增加了文档传输的负载\n- 只能存储少量的数据\n- 只能存储字符串\n- 潜在的 安全问题\n- 自从有 Web Storage API (Local and Session Storage)，cookies 就不再被推荐用于存储数据了\n\n#### cookie 的基本操作\n\n```js\n// Create\ndocument.cookie = \"user_name=eagleli\";  \ndocument.cookie = \"user_age=25;max-age=31536000;secure\";\n\n// Read (All)\nconsole.log( document.cookie );\n\n// Update\ndocument.cookie = \"user_age=24;max-age=31536000;secure\"; \n\n// Delete\ndocument.cookie = \"user_name=eagleli;expires=Thu, 01 Jan 2018 00:00:01 GMT\";  \n```\n\n\n### LocalStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。\n\nlocalStorage的优势\n\n1. localStorage 拓展了cookie 的 4K 限制\n\n2. localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\nlocalStorage的局限\n\n1. 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n\n2. 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n\n3. localStorage在浏览器的隐私模式下面是不可读取的\n\n4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n\n5. localStorage不能被爬虫抓取到\n\n### SessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n### 三者的异同\n\n特性 | Cookie | localStorage | sessionStorage\n---- | --- | --- | ---\n数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除\n存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB\n与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信\n易用性\t | 需要程序员自己封装，源生的Cookie接口不友好\t | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n### 使用\n\n#### 1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\n\n```js\nif(window.localStorage){\n    alert(\"浏览支持localStorage\")\n}else{\n   alert(\"浏览暂不支持localStorage\")\n}\n\n//或者\nif(typeof window.localStorage == 'undefined'){\n    alert(\"浏览暂不支持localStorage\")\n}\n```\n\n#### 2. setItem 存储数据 value（将value存储到key字段）\n\nlocalStorage 只支持 string 类型的存储。\n\n这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage\n\n```js\n<!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 -->\n\nconst storage=window.localStorage;\n\n// 存储数据方法一\nstorage[\"a\"]=1;\n\n// 存储数据方法二\nstorage.a=1;\n\n// 存储数据方法三（官方支持）\nlocalStorage.setItem(\"site\", \"js8.in\");\n\nsessionStorage.setItem(\"key\", \"value\");\n\nconsole.log(typeof storage[\"a\"]);  // 输出：string，原本存入的值是 int 类型，输出的是 string\nconsole.log(typeof storage[\"b\"]);  // 输出：string\nconsole.log(typeof storage[\"c\"]);  // 输出：string\n```\n\n#### 3. getItem 获取 value（获取指定key本地存储的值）\n\n```js\nconst value = sessionStorage.getItem(\"key\");\nconst site = localStorage.getItem(\"site\");\n```\n\n#### 4. removeItem 删除 key（删除指定key本地存储的值）\n\n```js\nsessionStorage.removeItem(\"key\");\nlocalStorage.removeItem(\"site\");\n```\n\nclear 清除所有的 key/value\n\n```js\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n### 参考链接\nhttps://github.com/dwqs/blog/issues/42","source":"_posts/localStorage-sessionStorage.md","raw":"---\ntitle: cookie、localStorage 和 sessionStorage\ndate: 2018-06-23 22:23:28\ntags: html\ncategories: html\n---\n\n### Cookie\n\ncookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n一般而言，cookies 会由服务端发送给客户端，客户端存储下来，然后在随后让请求中再发回给服务端。这可以用于诸如管理用户会话，追踪用户信息等事情。此外，客户端也用使用 cookies 存储数据。因而，cookies 常被用于存储一些通用的数据，如用户的首选项设置。\n\n#### 优缺点：\n优点：\n- 能用于和服务端通信\n- 当 cookie 快要自动过期时，我们可以重新设置而不是删除\n\n缺点：\n- 增加了文档传输的负载\n- 只能存储少量的数据\n- 只能存储字符串\n- 潜在的 安全问题\n- 自从有 Web Storage API (Local and Session Storage)，cookies 就不再被推荐用于存储数据了\n\n#### cookie 的基本操作\n\n```js\n// Create\ndocument.cookie = \"user_name=eagleli\";  \ndocument.cookie = \"user_age=25;max-age=31536000;secure\";\n\n// Read (All)\nconsole.log( document.cookie );\n\n// Update\ndocument.cookie = \"user_age=24;max-age=31536000;secure\"; \n\n// Delete\ndocument.cookie = \"user_name=eagleli;expires=Thu, 01 Jan 2018 00:00:01 GMT\";  \n```\n\n\n### LocalStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。\n\nlocalStorage的优势\n\n1. localStorage 拓展了cookie 的 4K 限制\n\n2. localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\nlocalStorage的局限\n\n1. 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n\n2. 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n\n3. localStorage在浏览器的隐私模式下面是不可读取的\n\n4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n\n5. localStorage不能被爬虫抓取到\n\n### SessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n### 三者的异同\n\n特性 | Cookie | localStorage | sessionStorage\n---- | --- | --- | ---\n数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除\n存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB\n与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信\n易用性\t | 需要程序员自己封装，源生的Cookie接口不友好\t | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n### 使用\n\n#### 1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\n\n```js\nif(window.localStorage){\n    alert(\"浏览支持localStorage\")\n}else{\n   alert(\"浏览暂不支持localStorage\")\n}\n\n//或者\nif(typeof window.localStorage == 'undefined'){\n    alert(\"浏览暂不支持localStorage\")\n}\n```\n\n#### 2. setItem 存储数据 value（将value存储到key字段）\n\nlocalStorage 只支持 string 类型的存储。\n\n这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage\n\n```js\n<!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 -->\n\nconst storage=window.localStorage;\n\n// 存储数据方法一\nstorage[\"a\"]=1;\n\n// 存储数据方法二\nstorage.a=1;\n\n// 存储数据方法三（官方支持）\nlocalStorage.setItem(\"site\", \"js8.in\");\n\nsessionStorage.setItem(\"key\", \"value\");\n\nconsole.log(typeof storage[\"a\"]);  // 输出：string，原本存入的值是 int 类型，输出的是 string\nconsole.log(typeof storage[\"b\"]);  // 输出：string\nconsole.log(typeof storage[\"c\"]);  // 输出：string\n```\n\n#### 3. getItem 获取 value（获取指定key本地存储的值）\n\n```js\nconst value = sessionStorage.getItem(\"key\");\nconst site = localStorage.getItem(\"site\");\n```\n\n#### 4. removeItem 删除 key（删除指定key本地存储的值）\n\n```js\nsessionStorage.removeItem(\"key\");\nlocalStorage.removeItem(\"site\");\n```\n\nclear 清除所有的 key/value\n\n```js\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n### 参考链接\nhttps://github.com/dwqs/blog/issues/42","slug":"localStorage-sessionStorage","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbaf000ffwvph1p7wepk","content":"<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>cookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>\n<p>一般而言，cookies 会由服务端发送给客户端，客户端存储下来，然后在随后让请求中再发回给服务端。这可以用于诸如管理用户会话，追踪用户信息等事情。此外，客户端也用使用 cookies 存储数据。因而，cookies 常被用于存储一些通用的数据，如用户的首选项设置。</p>\n<h4 id=\"优缺点：\"><a href=\"#优缺点：\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h4><p>优点：</p>\n<ul>\n<li>能用于和服务端通信</li>\n<li>当 cookie 快要自动过期时，我们可以重新设置而不是删除</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>增加了文档传输的负载</li>\n<li>只能存储少量的数据</li>\n<li>只能存储字符串</li>\n<li>潜在的 安全问题</li>\n<li>自从有 Web Storage API (Local and Session Storage)，cookies 就不再被推荐用于存储数据了</li>\n</ul>\n<h4 id=\"cookie-的基本操作\"><a href=\"#cookie-的基本操作\" class=\"headerlink\" title=\"cookie 的基本操作\"></a>cookie 的基本操作</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_name=eagleli\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_age=25;max-age=31536000;secure\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read (All)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">document</span>.cookie );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Update</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_age=24;max-age=31536000;secure\"</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delete</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_name=eagleli;expires=Thu, 01 Jan 2018 00:00:01 GMT\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。</p>\n<p>localStorage的优势</p>\n<ol>\n<li><p>localStorage 拓展了cookie 的 4K 限制</p>\n</li>\n<li><p>localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>\n</li>\n</ol>\n<p>localStorage的局限</p>\n<ol>\n<li><p>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</p>\n</li>\n<li><p>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</p>\n</li>\n<li><p>localStorage在浏览器的隐私模式下面是不可读取的</p>\n</li>\n<li><p>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>\n</li>\n<li><p>localStorage不能被爬虫抓取到</p>\n</li>\n</ol>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<h3 id=\"三者的异同\"><a href=\"#三者的异同\" class=\"headerlink\" title=\"三者的异同\"></a>三者的异同</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>一般为5MB</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\"><a href=\"#1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\" class=\"headerlink\" title=\"1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\"></a>1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.localStorage)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览支持localStorage\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.localStorage == <span class=\"string\">'undefined'</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-setItem-存储数据-value（将value存储到key字段）\"><a href=\"#2-setItem-存储数据-value（将value存储到key字段）\" class=\"headerlink\" title=\"2. setItem 存储数据 value（将value存储到key字段）\"></a>2. setItem 存储数据 value（将value存储到key字段）</h4><p>localStorage 只支持 string 类型的存储。</p>\n<p>这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage=<span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法一</span></span><br><span class=\"line\">storage[<span class=\"string\">\"a\"</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法二</span></span><br><span class=\"line\">storage.a=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法三（官方支持）</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">\"site\"</span>, <span class=\"string\">\"js8.in\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage.setItem(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"a\"</span>]);  <span class=\"comment\">// 输出：string，原本存入的值是 int 类型，输出的是 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"b\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"c\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-getItem-获取-value（获取指定key本地存储的值）\"><a href=\"#3-getItem-获取-value（获取指定key本地存储的值）\" class=\"headerlink\" title=\"3. getItem 获取 value（获取指定key本地存储的值）\"></a>3. getItem 获取 value（获取指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = sessionStorage.getItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> site = localStorage.getItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-removeItem-删除-key（删除指定key本地存储的值）\"><a href=\"#4-removeItem-删除-key（删除指定key本地存储的值）\" class=\"headerlink\" title=\"4. removeItem 删除 key（删除指定key本地存储的值）\"></a>4. removeItem 删除 key（删除指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<p>clear 清除所有的 key/value</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://github.com/dwqs/blog/issues/42\" target=\"_blank\" rel=\"noopener\">https://github.com/dwqs/blog/issues/42</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>cookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>\n<p>一般而言，cookies 会由服务端发送给客户端，客户端存储下来，然后在随后让请求中再发回给服务端。这可以用于诸如管理用户会话，追踪用户信息等事情。此外，客户端也用使用 cookies 存储数据。因而，cookies 常被用于存储一些通用的数据，如用户的首选项设置。</p>\n<h4 id=\"优缺点：\"><a href=\"#优缺点：\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h4><p>优点：</p>\n<ul>\n<li>能用于和服务端通信</li>\n<li>当 cookie 快要自动过期时，我们可以重新设置而不是删除</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>增加了文档传输的负载</li>\n<li>只能存储少量的数据</li>\n<li>只能存储字符串</li>\n<li>潜在的 安全问题</li>\n<li>自从有 Web Storage API (Local and Session Storage)，cookies 就不再被推荐用于存储数据了</li>\n</ul>\n<h4 id=\"cookie-的基本操作\"><a href=\"#cookie-的基本操作\" class=\"headerlink\" title=\"cookie 的基本操作\"></a>cookie 的基本操作</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_name=eagleli\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_age=25;max-age=31536000;secure\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Read (All)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">document</span>.cookie );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Update</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_age=24;max-age=31536000;secure\"</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delete</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"user_name=eagleli;expires=Thu, 01 Jan 2018 00:00:01 GMT\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。</p>\n<p>localStorage的优势</p>\n<ol>\n<li><p>localStorage 拓展了cookie 的 4K 限制</p>\n</li>\n<li><p>localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>\n</li>\n</ol>\n<p>localStorage的局限</p>\n<ol>\n<li><p>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</p>\n</li>\n<li><p>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</p>\n</li>\n<li><p>localStorage在浏览器的隐私模式下面是不可读取的</p>\n</li>\n<li><p>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>\n</li>\n<li><p>localStorage不能被爬虫抓取到</p>\n</li>\n</ol>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<h3 id=\"三者的异同\"><a href=\"#三者的异同\" class=\"headerlink\" title=\"三者的异同\"></a>三者的异同</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>一般为5MB</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\"><a href=\"#1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\" class=\"headerlink\" title=\"1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\"></a>1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.localStorage)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览支持localStorage\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.localStorage == <span class=\"string\">'undefined'</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-setItem-存储数据-value（将value存储到key字段）\"><a href=\"#2-setItem-存储数据-value（将value存储到key字段）\" class=\"headerlink\" title=\"2. setItem 存储数据 value（将value存储到key字段）\"></a>2. setItem 存储数据 value（将value存储到key字段）</h4><p>localStorage 只支持 string 类型的存储。</p>\n<p>这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage=<span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法一</span></span><br><span class=\"line\">storage[<span class=\"string\">\"a\"</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法二</span></span><br><span class=\"line\">storage.a=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法三（官方支持）</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">\"site\"</span>, <span class=\"string\">\"js8.in\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage.setItem(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"a\"</span>]);  <span class=\"comment\">// 输出：string，原本存入的值是 int 类型，输出的是 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"b\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"c\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-getItem-获取-value（获取指定key本地存储的值）\"><a href=\"#3-getItem-获取-value（获取指定key本地存储的值）\" class=\"headerlink\" title=\"3. getItem 获取 value（获取指定key本地存储的值）\"></a>3. getItem 获取 value（获取指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = sessionStorage.getItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> site = localStorage.getItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-removeItem-删除-key（删除指定key本地存储的值）\"><a href=\"#4-removeItem-删除-key（删除指定key本地存储的值）\" class=\"headerlink\" title=\"4. removeItem 删除 key（删除指定key本地存储的值）\"></a>4. removeItem 删除 key（删除指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<p>clear 清除所有的 key/value</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://github.com/dwqs/blog/issues/42\" target=\"_blank\" rel=\"noopener\">https://github.com/dwqs/blog/issues/42</a></p>\n"},{"title":"mobile-modal-scroll","date":"2018-07-31T03:03:09.000Z","_content":"\n# 移动端滚动穿透解决方案:\n\n移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。\n\n现在总结一下三种解决方案：\n\n### 1. css 之 `overflow: hidden`\n\n当页面弹出 modal 之后，将 `.HTML_MODAL_OPEN` 添加到 `html` 上，并且禁止 html 和 body 的滚动。\n\n```css\n.HTML_MODAL_OPEN {\n  &, body {\n    overflow: hidden;\n    height: 100vh;\n  }\n}\n```\n\n缺点：\n\n1. 由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。\n2. 页面的背景还是能够有滚的动的效果\n\n### 2. js 之 preventDefault\n\n添加监听事件：\n\n```js\nmodal.addEventListener('touchmove', function(e) {\n  e.preventDefault();\n}, false);\n```\n\n缺点：\n\n1. modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。\n\n### 3. js + css 值 `position: fixed`\n\n参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：\n\ncss 部分：\n\n```css\nbody.BODY_MODAL_OPEN {\n    position: fixed;\n    width: 100%;\n}\n```\n\njs 部分：\n所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。\n\n```js\nconst scrollTop;  // 记录上次的滚动位置\n\nfunction setDocumentScroll(isShowModal) {\n    if (isShowModal) {\n      scrollTop = document.scrollingElement.scrollTop;\n      document.body.classList.add('BODY_MODAL_OPEN');\n      document.body.style.top = -scrollTop + 'px';\n      return;\n    }\n\n    // modal 隐藏回复 body 的原滚动位置\n    document.body.classList.remove('BODY_MODAL_OPEN');\n    document.scrollingElement.scrollTop = scrollTop;\n    document.body.style.top = '0';\n}\n```\n\n优化移动端滑动的 css 属性：\n -webkit-overflow-scrolling: touch;\n\n#### 参考\nhttps://uedsky.com/2016-06/mobile-modal-scroll/","source":"_posts/mobile-modal-scroll.md","raw":"---\ntitle: mobile-modal-scroll\ndate: 2018-07-31 11:03:09\ntags: ['js', 'css']\ncategories: js\n---\n\n# 移动端滚动穿透解决方案:\n\n移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。\n\n现在总结一下三种解决方案：\n\n### 1. css 之 `overflow: hidden`\n\n当页面弹出 modal 之后，将 `.HTML_MODAL_OPEN` 添加到 `html` 上，并且禁止 html 和 body 的滚动。\n\n```css\n.HTML_MODAL_OPEN {\n  &, body {\n    overflow: hidden;\n    height: 100vh;\n  }\n}\n```\n\n缺点：\n\n1. 由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。\n2. 页面的背景还是能够有滚的动的效果\n\n### 2. js 之 preventDefault\n\n添加监听事件：\n\n```js\nmodal.addEventListener('touchmove', function(e) {\n  e.preventDefault();\n}, false);\n```\n\n缺点：\n\n1. modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。\n\n### 3. js + css 值 `position: fixed`\n\n参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：\n\ncss 部分：\n\n```css\nbody.BODY_MODAL_OPEN {\n    position: fixed;\n    width: 100%;\n}\n```\n\njs 部分：\n所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。\n\n```js\nconst scrollTop;  // 记录上次的滚动位置\n\nfunction setDocumentScroll(isShowModal) {\n    if (isShowModal) {\n      scrollTop = document.scrollingElement.scrollTop;\n      document.body.classList.add('BODY_MODAL_OPEN');\n      document.body.style.top = -scrollTop + 'px';\n      return;\n    }\n\n    // modal 隐藏回复 body 的原滚动位置\n    document.body.classList.remove('BODY_MODAL_OPEN');\n    document.scrollingElement.scrollTop = scrollTop;\n    document.body.style.top = '0';\n}\n```\n\n优化移动端滑动的 css 属性：\n -webkit-overflow-scrolling: touch;\n\n#### 参考\nhttps://uedsky.com/2016-06/mobile-modal-scroll/","slug":"mobile-modal-scroll","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbat000jfwvpe9j38921","content":"<h1 id=\"移动端滚动穿透解决方案\"><a href=\"#移动端滚动穿透解决方案\" class=\"headerlink\" title=\"移动端滚动穿透解决方案:\"></a>移动端滚动穿透解决方案:</h1><p>移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。</p>\n<p>现在总结一下三种解决方案：</p>\n<h3 id=\"1-css-之-overflow-hidden\"><a href=\"#1-css-之-overflow-hidden\" class=\"headerlink\" title=\"1. css 之 overflow: hidden\"></a>1. css 之 <code>overflow: hidden</code></h3><p>当页面弹出 modal 之后，将 <code>.HTML_MODAL_OPEN</code> 添加到 <code>html</code> 上，并且禁止 html 和 body 的滚动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.HTML_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">  &amp;, body &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100<span class=\"selector-tag\">vh</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。</li>\n<li>页面的背景还是能够有滚的动的效果</li>\n</ol>\n<h3 id=\"2-js-之-preventDefault\"><a href=\"#2-js-之-preventDefault\" class=\"headerlink\" title=\"2. js 之 preventDefault\"></a>2. js 之 preventDefault</h3><p>添加监听事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modal.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。</li>\n</ol>\n<h3 id=\"3-js-css-值-position-fixed\"><a href=\"#3-js-css-值-position-fixed\" class=\"headerlink\" title=\"3. js + css 值 position: fixed\"></a>3. js + css 值 <code>position: fixed</code></h3><p>参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：</p>\n<p>css 部分：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.BODY_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>js 部分：<br>所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scrollTop;  <span class=\"comment\">// 记录上次的滚动位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setDocumentScroll</span>(<span class=\"params\">isShowModal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isShowModal) &#123;</span><br><span class=\"line\">      scrollTop = <span class=\"built_in\">document</span>.scrollingElement.scrollTop;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.add(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.style.top = -scrollTop + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// modal 隐藏回复 body 的原滚动位置</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.classList.remove(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.style.top = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化移动端滑动的 css 属性：<br> -webkit-overflow-scrolling: touch;</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://uedsky.com/2016-06/mobile-modal-scroll/\" target=\"_blank\" rel=\"noopener\">https://uedsky.com/2016-06/mobile-modal-scroll/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"移动端滚动穿透解决方案\"><a href=\"#移动端滚动穿透解决方案\" class=\"headerlink\" title=\"移动端滚动穿透解决方案:\"></a>移动端滚动穿透解决方案:</h1><p>移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。</p>\n<p>现在总结一下三种解决方案：</p>\n<h3 id=\"1-css-之-overflow-hidden\"><a href=\"#1-css-之-overflow-hidden\" class=\"headerlink\" title=\"1. css 之 overflow: hidden\"></a>1. css 之 <code>overflow: hidden</code></h3><p>当页面弹出 modal 之后，将 <code>.HTML_MODAL_OPEN</code> 添加到 <code>html</code> 上，并且禁止 html 和 body 的滚动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.HTML_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">  &amp;, body &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100<span class=\"selector-tag\">vh</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。</li>\n<li>页面的背景还是能够有滚的动的效果</li>\n</ol>\n<h3 id=\"2-js-之-preventDefault\"><a href=\"#2-js-之-preventDefault\" class=\"headerlink\" title=\"2. js 之 preventDefault\"></a>2. js 之 preventDefault</h3><p>添加监听事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modal.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。</li>\n</ol>\n<h3 id=\"3-js-css-值-position-fixed\"><a href=\"#3-js-css-值-position-fixed\" class=\"headerlink\" title=\"3. js + css 值 position: fixed\"></a>3. js + css 值 <code>position: fixed</code></h3><p>参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：</p>\n<p>css 部分：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.BODY_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>js 部分：<br>所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scrollTop;  <span class=\"comment\">// 记录上次的滚动位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setDocumentScroll</span>(<span class=\"params\">isShowModal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isShowModal) &#123;</span><br><span class=\"line\">      scrollTop = <span class=\"built_in\">document</span>.scrollingElement.scrollTop;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.add(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.style.top = -scrollTop + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// modal 隐藏回复 body 的原滚动位置</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.classList.remove(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.style.top = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化移动端滑动的 css 属性：<br> -webkit-overflow-scrolling: touch;</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://uedsky.com/2016-06/mobile-modal-scroll/\" target=\"_blank\" rel=\"noopener\">https://uedsky.com/2016-06/mobile-modal-scroll/</a></p>\n"},{"title":"nextjs + postcss + typeScript","date":"2018-08-01T02:11:31.000Z","_content":"\n## nextjs + typescript + jest + postcss\n从零开始配置项目\n\n在 github 上 nextjs 的源码中，有集成好的 [examples](https://github.com/zeit/next.js/tree/canary/examples)，在使用过程中可以直接拿来做参考。\n\n## 一、 nextjs + typeScript\n\n[nextjs 官网](https://nextjs.org/)中有 nextjs 使用的文档，配置 ts 的方法有两种，\n\n#### 1. 使用 [with-jest-typescript](https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript)\n\n使用 `create-next-app`，通过 `yarn` 或者 `npx` 进行安装。\n\n```js\n$ npx create-next-app --example with-jest-typescript with-jest-typescript-app\n# 或者\n$ yarn create-next-app --example with-jest-typescript with-jest-typescript-app\n```\n\n运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板\n\n#### 2. 自己配置（未实践）\n\n1. 根据[官网文档](https://nextjs.org/docs/#setup)的 Getting Start 进行初始化项目\n2. 安装 ts ，添加 ts 相关配置。\n3. 安装 jest，添加 jest 相关配置。\n\n配置完之后：next.config.js 文件为：\n```js\nconst withTypescript = require('@zeit/next-typescript')\n\nmodule.exports = withTypescript()\n```\n\n## 二、配置 css\n\n1. 安装 `@zeit/next-css`\n\n```js\n$ npm install --save @zeit/next-css\n# or\n$ yarn add @zeit/next-css\n```\n\n2. 引入编译后的 css 文件\n\n项目运行之后的 css 文件会编译到 `.next/static/style.css`，我们需要在 `_document.js` 引入这个 css 文件 `/_next/static/style.css`\n\n例如：\n```jsx\n// ./pages/_document.js\nimport Document, { Head, Main, NextScript } from 'next/document'\n\nclass MyDocument extends Document {\n  render() {\n    return (\n      <html>\n        <Head>\n          <link rel=\"stylesheet\" href=\"/_next/static/style.css\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </html>\n    )\n  }\n}\n\nexport default MyDocument;\n```\n\n3. 配置 css 解析\n\n在 next.config.js 文件中配置 css 解析。\n\n```js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS())\n```\n\n此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport \"../style.css\"\n\nexport default () => <div className=\"example\">Hello World!</div>\n\n```\n\n4. css modules\n\n配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：\n\n```jsx\n// next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n}))\n```\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n._2Qh9GEqcE104osQujlJkZw {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n\n```\n\n5. 优化 css-loader 配置\n\n `css-loader` 的配置可以通过属性 `cssLoaderOptions` 添加一些其他的配置。\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  }\n}))\n ```\n\n 例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n.style-example-2Qh9G {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n```\n\n## 三、配置 postcss\n\n创建 postcss.config.js 文件：\n\n```js\n// 例如\nmodule.exports = {\n  plugins: {\n    // Illustrational\n    'postcss-css-variables': {}\n  }\n}\n```\n\n配置 postcss 解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n}))\n ```\n\n## 四、图片的加载\n\n#### 方法一\n通过 webpack 配置进行图片解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n  webpack(config) {\n        config.module.rules.push(\n            { test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/, loader: 'url-loader' }\n        )\n        return config;\n    }\n}))\n ```\n\n#### 方法二\n使用 [next-images](https://github.com/arefaslani/next-images)（未实践）\n\n具体配置方法请参考官网\n\n## 五、遇到的问题\n\n问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。\n\n解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：\n\n```jsx\nconst withTypescript = require('@zeit/next-typescript');\nconst withCSS = require('@zeit/next-css');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nconst StylelintPlugin = require('stylelint-webpack-plugin');\nconst webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = withTypescript({\n  webpack(config, options) {\n    const { dev, isServer } = options;\n\n    // Do not run type checking twice:\n    if (!isServer) {\n      config.plugins.push(\n        new ForkTsCheckerWebpackPlugin({\n          tslint: true,\n        }),\n        new StylelintPlugin({\n          files: '**/*.{ts,tsx}',\n          emitErrors: !dev,\n        }),\n      );\n    }\n    // 图片处理\n    config.module.rules.push({\n      test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/,\n      loader: 'url-loader',\n    });\n    // css 处理\n    config.module.rules.push({\n      oneOf: [\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          exclude: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            // Process external/third-party styles\n            {\n              loader: 'css-loader',\n              options: {\n                sourceMap: true,\n                minimize: false,\n                discardComments: { removeAll: true },\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          include: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            {\n              loader: require.resolve('typings-for-css-modules-loader'),\n              options: {\n                modules: true,\n                importLoaders: 1,\n                sourcemap: true,\n                localIdentName: '[name]-[local]-[hash:base64:5]',\n                discardComments: { removeAll: true },\n                namedExport: true,\n                camelCase: true,\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n      ],\n    });\n\n    return config;\n  },\n});\n\n```\n\n注意：原本只是使用 [style-loader](https://github.com/webpack-contrib/style-loader) 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader) 进行服务器端渲染的 css 解析。\n\n## 参考链接\n\n1. [nextjs 官网链接](https://nextjs.org/)\n2. [nextjs github 地址](https://github.com/zeit/next.js)\n3. [next-plugins](https://github.com/zeit/next-plugins)\n4. [next-images](https://github.com/arefaslani/next-images)\n5. [css-loader](https://github.com/webpack-contrib/css-loader)\n6. [style-loader](https://github.com/webpack-contrib/style-loader)\n7. [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader)\n8. [next.js/examples](https://github.com/zeit/next.js/tree/canary/examples)","source":"_posts/nextjs-postcss-typeScript.md","raw":"---\ntitle: nextjs + postcss + typeScript\ndate: 2018-08-01 10:11:31\ntags: ['nextjs', 'js', 'css']\n---\n\n## nextjs + typescript + jest + postcss\n从零开始配置项目\n\n在 github 上 nextjs 的源码中，有集成好的 [examples](https://github.com/zeit/next.js/tree/canary/examples)，在使用过程中可以直接拿来做参考。\n\n## 一、 nextjs + typeScript\n\n[nextjs 官网](https://nextjs.org/)中有 nextjs 使用的文档，配置 ts 的方法有两种，\n\n#### 1. 使用 [with-jest-typescript](https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript)\n\n使用 `create-next-app`，通过 `yarn` 或者 `npx` 进行安装。\n\n```js\n$ npx create-next-app --example with-jest-typescript with-jest-typescript-app\n# 或者\n$ yarn create-next-app --example with-jest-typescript with-jest-typescript-app\n```\n\n运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板\n\n#### 2. 自己配置（未实践）\n\n1. 根据[官网文档](https://nextjs.org/docs/#setup)的 Getting Start 进行初始化项目\n2. 安装 ts ，添加 ts 相关配置。\n3. 安装 jest，添加 jest 相关配置。\n\n配置完之后：next.config.js 文件为：\n```js\nconst withTypescript = require('@zeit/next-typescript')\n\nmodule.exports = withTypescript()\n```\n\n## 二、配置 css\n\n1. 安装 `@zeit/next-css`\n\n```js\n$ npm install --save @zeit/next-css\n# or\n$ yarn add @zeit/next-css\n```\n\n2. 引入编译后的 css 文件\n\n项目运行之后的 css 文件会编译到 `.next/static/style.css`，我们需要在 `_document.js` 引入这个 css 文件 `/_next/static/style.css`\n\n例如：\n```jsx\n// ./pages/_document.js\nimport Document, { Head, Main, NextScript } from 'next/document'\n\nclass MyDocument extends Document {\n  render() {\n    return (\n      <html>\n        <Head>\n          <link rel=\"stylesheet\" href=\"/_next/static/style.css\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </html>\n    )\n  }\n}\n\nexport default MyDocument;\n```\n\n3. 配置 css 解析\n\n在 next.config.js 文件中配置 css 解析。\n\n```js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS())\n```\n\n此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport \"../style.css\"\n\nexport default () => <div className=\"example\">Hello World!</div>\n\n```\n\n4. css modules\n\n配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：\n\n```jsx\n// next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n}))\n```\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n._2Qh9GEqcE104osQujlJkZw {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n\n```\n\n5. 优化 css-loader 配置\n\n `css-loader` 的配置可以通过属性 `cssLoaderOptions` 添加一些其他的配置。\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  }\n}))\n ```\n\n 例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n.style-example-2Qh9G {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n```\n\n## 三、配置 postcss\n\n创建 postcss.config.js 文件：\n\n```js\n// 例如\nmodule.exports = {\n  plugins: {\n    // Illustrational\n    'postcss-css-variables': {}\n  }\n}\n```\n\n配置 postcss 解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n}))\n ```\n\n## 四、图片的加载\n\n#### 方法一\n通过 webpack 配置进行图片解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n  webpack(config) {\n        config.module.rules.push(\n            { test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/, loader: 'url-loader' }\n        )\n        return config;\n    }\n}))\n ```\n\n#### 方法二\n使用 [next-images](https://github.com/arefaslani/next-images)（未实践）\n\n具体配置方法请参考官网\n\n## 五、遇到的问题\n\n问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。\n\n解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：\n\n```jsx\nconst withTypescript = require('@zeit/next-typescript');\nconst withCSS = require('@zeit/next-css');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nconst StylelintPlugin = require('stylelint-webpack-plugin');\nconst webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = withTypescript({\n  webpack(config, options) {\n    const { dev, isServer } = options;\n\n    // Do not run type checking twice:\n    if (!isServer) {\n      config.plugins.push(\n        new ForkTsCheckerWebpackPlugin({\n          tslint: true,\n        }),\n        new StylelintPlugin({\n          files: '**/*.{ts,tsx}',\n          emitErrors: !dev,\n        }),\n      );\n    }\n    // 图片处理\n    config.module.rules.push({\n      test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/,\n      loader: 'url-loader',\n    });\n    // css 处理\n    config.module.rules.push({\n      oneOf: [\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          exclude: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            // Process external/third-party styles\n            {\n              loader: 'css-loader',\n              options: {\n                sourceMap: true,\n                minimize: false,\n                discardComments: { removeAll: true },\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          include: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            {\n              loader: require.resolve('typings-for-css-modules-loader'),\n              options: {\n                modules: true,\n                importLoaders: 1,\n                sourcemap: true,\n                localIdentName: '[name]-[local]-[hash:base64:5]',\n                discardComments: { removeAll: true },\n                namedExport: true,\n                camelCase: true,\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n      ],\n    });\n\n    return config;\n  },\n});\n\n```\n\n注意：原本只是使用 [style-loader](https://github.com/webpack-contrib/style-loader) 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader) 进行服务器端渲染的 css 解析。\n\n## 参考链接\n\n1. [nextjs 官网链接](https://nextjs.org/)\n2. [nextjs github 地址](https://github.com/zeit/next.js)\n3. [next-plugins](https://github.com/zeit/next-plugins)\n4. [next-images](https://github.com/arefaslani/next-images)\n5. [css-loader](https://github.com/webpack-contrib/css-loader)\n6. [style-loader](https://github.com/webpack-contrib/style-loader)\n7. [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader)\n8. [next.js/examples](https://github.com/zeit/next.js/tree/canary/examples)","slug":"nextjs-postcss-typeScript","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbaw000lfwvp9zygqnh6","content":"<h2 id=\"nextjs-typescript-jest-postcss\"><a href=\"#nextjs-typescript-jest-postcss\" class=\"headerlink\" title=\"nextjs + typescript + jest + postcss\"></a>nextjs + typescript + jest + postcss</h2><p>从零开始配置项目</p>\n<p>在 github 上 nextjs 的源码中，有集成好的 <a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">examples</a>，在使用过程中可以直接拿来做参考。</p>\n<h2 id=\"一、-nextjs-typeScript\"><a href=\"#一、-nextjs-typeScript\" class=\"headerlink\" title=\"一、 nextjs + typeScript\"></a>一、 nextjs + typeScript</h2><p><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网</a>中有 nextjs 使用的文档，配置 ts 的方法有两种，</p>\n<h4 id=\"1-使用-with-jest-typescript\"><a href=\"#1-使用-with-jest-typescript\" class=\"headerlink\" title=\"1. 使用 with-jest-typescript\"></a>1. 使用 <a href=\"https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript\" target=\"_blank\" rel=\"noopener\">with-jest-typescript</a></h4><p>使用 <code>create-next-app</code>，通过 <code>yarn</code> 或者 <code>npx</code> 进行安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npx create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ yarn create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br></pre></td></tr></table></figure>\n<p>运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板</p>\n<h4 id=\"2-自己配置（未实践）\"><a href=\"#2-自己配置（未实践）\" class=\"headerlink\" title=\"2. 自己配置（未实践）\"></a>2. 自己配置（未实践）</h4><ol>\n<li>根据<a href=\"https://nextjs.org/docs/#setup\" target=\"_blank\" rel=\"noopener\">官网文档</a>的 Getting Start 进行初始化项目</li>\n<li>安装 ts ，添加 ts 相关配置。</li>\n<li>安装 jest，添加 jest 相关配置。</li>\n</ol>\n<p>配置完之后：next.config.js 文件为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、配置-css\"><a href=\"#二、配置-css\" class=\"headerlink\" title=\"二、配置 css\"></a>二、配置 css</h2><ol>\n<li>安装 <code>@zeit/next-css</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save @zeit/next-css</span><br><span class=\"line\"># or</span><br><span class=\"line\">$ yarn add @zeit/next-css</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>引入编译后的 css 文件</li>\n</ol>\n<p>项目运行之后的 css 文件会编译到 <code>.next/static/style.css</code>，我们需要在 <code>_document.js</code> 引入这个 css 文件 <code>/_next/static/style.css</code></p>\n<p>例如：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./pages/_document.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Document, &#123; Head, Main, NextScript &#125; <span class=\"keyword\">from</span> <span class=\"string\">'next/document'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDocument</span> <span class=\"keyword\">extends</span> <span class=\"title\">Document</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;html&gt;</span><br><span class=\"line\">        &lt;Head&gt;</span><br><span class=\"line\">          &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"/_next/static/style.css\"</span> /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Main /</span>&gt;</span><br><span class=\"line\">          &lt;NextScript /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>html&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyDocument;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>配置 css 解析</li>\n</ol>\n<p>在 next.config.js 文件中配置 css 解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS())</span><br></pre></td></tr></table></figure>\n<p>此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，</p>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=\"example\"&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>css modules</li>\n</ol>\n<p>配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">._2Qh9GEqcE104osQujlJkZw &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li><p>优化 css-loader 配置</p>\n<p><code>css-loader</code> 的配置可以通过属性 <code>cssLoaderOptions</code> 添加一些其他的配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">.style-example<span class=\"number\">-2</span>Qh9G &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、配置-postcss\"><a href=\"#三、配置-postcss\" class=\"headerlink\" title=\"三、配置 postcss\"></a>三、配置 postcss</h2><p>创建 postcss.config.js 文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Illustrational</span></span><br><span class=\"line\">    <span class=\"string\">'postcss-css-variables'</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置 postcss 解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、图片的加载\"><a href=\"#四、图片的加载\" class=\"headerlink\" title=\"四、图片的加载\"></a>四、图片的加载</h2><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>通过 webpack 配置进行图片解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  webpack(config) &#123;</span><br><span class=\"line\">        config.module.rules.push(</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader'</span> &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用 <a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a>（未实践）</p>\n<p>具体配置方法请参考官网</p>\n<h2 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h2><p>问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。</p>\n<p>解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ForkTsCheckerWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'fork-ts-checker-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> StylelintPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'stylelint-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(&#123;</span><br><span class=\"line\">  webpack(config, options) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dev, isServer &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do not run type checking twice:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isServer) &#123;</span><br><span class=\"line\">      config.plugins.push(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class=\"line\">          tslint: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> StylelintPlugin(&#123;</span><br><span class=\"line\">          files: <span class=\"string\">'**/*.&#123;ts,tsx&#125;'</span>,</span><br><span class=\"line\">          emitErrors: !dev,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 图片处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// css 处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      oneOf: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          exclude: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            <span class=\"comment\">// Process external/third-party styles</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                minimize: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          include: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'typings-for-css-modules-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                modules: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                importLoaders: <span class=\"number\">1</span>,</span><br><span class=\"line\">                sourcemap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                namedExport: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                camelCase: <span class=\"literal\">true</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意：原本只是使用 <a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a> 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 <a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a> 进行服务器端渲染的 css 解析。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网链接</a></li>\n<li><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"noopener\">nextjs github 地址</a></li>\n<li><a href=\"https://github.com/zeit/next-plugins\" target=\"_blank\" rel=\"noopener\">next-plugins</a></li>\n<li><a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a></li>\n<li><a href=\"https://github.com/webpack-contrib/css-loader\" target=\"_blank\" rel=\"noopener\">css-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a></li>\n<li><a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a></li>\n<li><a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">next.js/examples</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"nextjs-typescript-jest-postcss\"><a href=\"#nextjs-typescript-jest-postcss\" class=\"headerlink\" title=\"nextjs + typescript + jest + postcss\"></a>nextjs + typescript + jest + postcss</h2><p>从零开始配置项目</p>\n<p>在 github 上 nextjs 的源码中，有集成好的 <a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">examples</a>，在使用过程中可以直接拿来做参考。</p>\n<h2 id=\"一、-nextjs-typeScript\"><a href=\"#一、-nextjs-typeScript\" class=\"headerlink\" title=\"一、 nextjs + typeScript\"></a>一、 nextjs + typeScript</h2><p><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网</a>中有 nextjs 使用的文档，配置 ts 的方法有两种，</p>\n<h4 id=\"1-使用-with-jest-typescript\"><a href=\"#1-使用-with-jest-typescript\" class=\"headerlink\" title=\"1. 使用 with-jest-typescript\"></a>1. 使用 <a href=\"https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript\" target=\"_blank\" rel=\"noopener\">with-jest-typescript</a></h4><p>使用 <code>create-next-app</code>，通过 <code>yarn</code> 或者 <code>npx</code> 进行安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npx create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ yarn create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br></pre></td></tr></table></figure>\n<p>运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板</p>\n<h4 id=\"2-自己配置（未实践）\"><a href=\"#2-自己配置（未实践）\" class=\"headerlink\" title=\"2. 自己配置（未实践）\"></a>2. 自己配置（未实践）</h4><ol>\n<li>根据<a href=\"https://nextjs.org/docs/#setup\" target=\"_blank\" rel=\"noopener\">官网文档</a>的 Getting Start 进行初始化项目</li>\n<li>安装 ts ，添加 ts 相关配置。</li>\n<li>安装 jest，添加 jest 相关配置。</li>\n</ol>\n<p>配置完之后：next.config.js 文件为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、配置-css\"><a href=\"#二、配置-css\" class=\"headerlink\" title=\"二、配置 css\"></a>二、配置 css</h2><ol>\n<li>安装 <code>@zeit/next-css</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save @zeit/next-css</span><br><span class=\"line\"># or</span><br><span class=\"line\">$ yarn add @zeit/next-css</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>引入编译后的 css 文件</li>\n</ol>\n<p>项目运行之后的 css 文件会编译到 <code>.next/static/style.css</code>，我们需要在 <code>_document.js</code> 引入这个 css 文件 <code>/_next/static/style.css</code></p>\n<p>例如：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./pages/_document.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Document, &#123; Head, Main, NextScript &#125; <span class=\"keyword\">from</span> <span class=\"string\">'next/document'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDocument</span> <span class=\"keyword\">extends</span> <span class=\"title\">Document</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;html&gt;</span><br><span class=\"line\">        &lt;Head&gt;</span><br><span class=\"line\">          &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"/_next/static/style.css\"</span> /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Main /</span>&gt;</span><br><span class=\"line\">          &lt;NextScript /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>html&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyDocument;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>配置 css 解析</li>\n</ol>\n<p>在 next.config.js 文件中配置 css 解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS())</span><br></pre></td></tr></table></figure>\n<p>此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，</p>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=\"example\"&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>css modules</li>\n</ol>\n<p>配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">._2Qh9GEqcE104osQujlJkZw &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li><p>优化 css-loader 配置</p>\n<p><code>css-loader</code> 的配置可以通过属性 <code>cssLoaderOptions</code> 添加一些其他的配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">.style-example<span class=\"number\">-2</span>Qh9G &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、配置-postcss\"><a href=\"#三、配置-postcss\" class=\"headerlink\" title=\"三、配置 postcss\"></a>三、配置 postcss</h2><p>创建 postcss.config.js 文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Illustrational</span></span><br><span class=\"line\">    <span class=\"string\">'postcss-css-variables'</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置 postcss 解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、图片的加载\"><a href=\"#四、图片的加载\" class=\"headerlink\" title=\"四、图片的加载\"></a>四、图片的加载</h2><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>通过 webpack 配置进行图片解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  webpack(config) &#123;</span><br><span class=\"line\">        config.module.rules.push(</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader'</span> &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用 <a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a>（未实践）</p>\n<p>具体配置方法请参考官网</p>\n<h2 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h2><p>问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。</p>\n<p>解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ForkTsCheckerWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'fork-ts-checker-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> StylelintPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'stylelint-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(&#123;</span><br><span class=\"line\">  webpack(config, options) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dev, isServer &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do not run type checking twice:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isServer) &#123;</span><br><span class=\"line\">      config.plugins.push(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class=\"line\">          tslint: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> StylelintPlugin(&#123;</span><br><span class=\"line\">          files: <span class=\"string\">'**/*.&#123;ts,tsx&#125;'</span>,</span><br><span class=\"line\">          emitErrors: !dev,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 图片处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// css 处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      oneOf: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          exclude: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            <span class=\"comment\">// Process external/third-party styles</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                minimize: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          include: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'typings-for-css-modules-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                modules: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                importLoaders: <span class=\"number\">1</span>,</span><br><span class=\"line\">                sourcemap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                namedExport: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                camelCase: <span class=\"literal\">true</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意：原本只是使用 <a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a> 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 <a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a> 进行服务器端渲染的 css 解析。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网链接</a></li>\n<li><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"noopener\">nextjs github 地址</a></li>\n<li><a href=\"https://github.com/zeit/next-plugins\" target=\"_blank\" rel=\"noopener\">next-plugins</a></li>\n<li><a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a></li>\n<li><a href=\"https://github.com/webpack-contrib/css-loader\" target=\"_blank\" rel=\"noopener\">css-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a></li>\n<li><a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a></li>\n<li><a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">next.js/examples</a></li>\n</ol>\n"},{"title":"package.json 文件","date":"2018-06-17T14:52:04.000Z","_content":"\n一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 ` npm install ` 会根据这个配置文件自动下载所需模块。\n\n### name\n\n项目的名字\n\n规则：\n 1. 该名称必须小于或等于214个字符。\n 2. 名称不能以点或下划线开头。\n 3. 新包名称中不能包含大写字母。\n 4. 该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。\n\n技巧\n 1. 不要使用与核心节点模块相同的名称。\n 2. 不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）\n 3. 这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。\n 4. 你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。[https://www.npmjs.com/](https://www.npmjs.com/)\n\n 名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 [npm-scope](https://docs.npmjs.com/misc/scope)查看更多\n\n### description\n\n在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search\n\n### version\n\n如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。\n\n版本必须可以由 [node-semver](https://docs.npmjs.com/misc/semver) 解析\n\n### keywords\n\n把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。\n\n### homepage\n\n项目首页的网址\n\n### bugs\n\n如果项目有问题，可以提交的问题的邮箱和 url。\n例如：\n```\n{ \"url\" : \"https://github.com/owner/project/issues\",\n  \"email\" : \"project@hostname.com\"\n}\n```\n\n可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 ` npm bugs ` 命令使用。\n\n### license\n\n项目包的许可证，可以让别人知道你的项目包的限制。[查看详情](https://docs.npmjs.com/files/package.json)\n\n### people fields: author, contributors  \n\nauthor 是一个人，contributors 是一群人。人具有 url 和 email 。\n\n### files\n\n\"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）\n你也可以在模块根目录下创建一个\".npmignore\"文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。\n\n容易被忽略的文件：\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json （改用shrinkwrap）\n\n### main\n\n程序的主要入口，这应该是相对于包文件夹根目录的模块ID。\n\n### browser\n\n如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）\n\n### bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）\n如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n例如：\n```\n{ \"bin\" : { \"myapp\" : \"./cli.js\" } }\n```\n\n模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。\n如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n```\n{ \n    \"name\": \"my-program\",\n    \"version\": \"1.2.5\",\n    \"bin\": \"./path/to/program\",\n}\n```\n\n### man\n\n制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。\n如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : \"./man/doc.1\"\n}\n```\n\n通过 man foo 命令会得到 ./man/doc.1 文件的内容。\n如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ]\n}\n```\n\n会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。\nman文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ]\n}\n```\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n### directories\n\nCommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。\n目前这个配置没有任何作用。\n\ndirectories.lib\n告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\ndirectories.bin\n如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。\n\ndirectories.man\n指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。\n\ndirectories.doc\n在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）\n\ndirectories.example\n放一些示例脚本，或许某一天会有用 - -！\n\n### repository\n\n代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 ` npm docs ` 命令将能够找到你的项目\n\n例如：\n```\n\"repository\" :\n  { \n      \"type\" : \"git\",\n      \"url\" : \"https://github.com/npm/npm.git\"\n  }\n\n\"repository\" :\n  { \n    \"type\" : \"svn\",\n    \"url\" : \"https://v8.googlecode.com/svn/trunk/\"\n  }\n```\n\n该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。\n\n对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法\n\n### scripts\n\n“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。\n[npm-scripts 查看更多](https://docs.npmjs.com/misc/scripts)\n\n### config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。\n用户用的时候可以使用如下用法：\n```\nhttp.createServer(...).listen(process.env.npm_package_config_port) \n```\n\n可以通过npm config set foo:port 80来修改config:\n```\n{ \n    \"name\" : \"foo\",\n    \"config\" : { \"port\" : \"8080\" }\n}\n```\n\n### dependencies 和 devDependencies\n\ndependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。\n它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n对应的版本可以加上各种限定，主要有以下几种：\n\n指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n> 1. 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n> \n> 2. 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n> \n> 3. latest：安装最新版本。\n\npackage.json 文件可以手工编写，也可以使用 ` npm init ` 命令自动生成。项目名称（name）和项目版本（version）是必填的\n\n通过指令安装：\n```\n$ npm install express --save\n$ npm install express --save-dev\n```\n\n` --save ` 参数表示将该模块写入 dependencies 属性\n` --save-dev ` 表示将该模块写入 devDependencies 属性。\n\n### peerDependencies\n\n有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。\n\n大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\n\npeerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。\n\n例如：\n```\n{\n  \"name\": \"tea-latte\",\n  \"version\": \"1.3.5\",\n  \"peerDependencies\": {\n    \"tea\": \"2.x\"\n  }\n}\n```\n\n这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：\n```\n├── tea-latte@1.3.5\n└── tea@2.2.0\n```\n\n注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。\n\n### preferGlobal\n\npreferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n\n### style\n\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。","source":"_posts/package-json文件.md","raw":"---\ntitle: package.json 文件\ndate: 2018-06-17 22:52:04\ntags: package.json\ncategories: json\n---\n\n一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 ` npm install ` 会根据这个配置文件自动下载所需模块。\n\n### name\n\n项目的名字\n\n规则：\n 1. 该名称必须小于或等于214个字符。\n 2. 名称不能以点或下划线开头。\n 3. 新包名称中不能包含大写字母。\n 4. 该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。\n\n技巧\n 1. 不要使用与核心节点模块相同的名称。\n 2. 不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）\n 3. 这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。\n 4. 你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。[https://www.npmjs.com/](https://www.npmjs.com/)\n\n 名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 [npm-scope](https://docs.npmjs.com/misc/scope)查看更多\n\n### description\n\n在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search\n\n### version\n\n如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。\n\n版本必须可以由 [node-semver](https://docs.npmjs.com/misc/semver) 解析\n\n### keywords\n\n把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。\n\n### homepage\n\n项目首页的网址\n\n### bugs\n\n如果项目有问题，可以提交的问题的邮箱和 url。\n例如：\n```\n{ \"url\" : \"https://github.com/owner/project/issues\",\n  \"email\" : \"project@hostname.com\"\n}\n```\n\n可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 ` npm bugs ` 命令使用。\n\n### license\n\n项目包的许可证，可以让别人知道你的项目包的限制。[查看详情](https://docs.npmjs.com/files/package.json)\n\n### people fields: author, contributors  \n\nauthor 是一个人，contributors 是一群人。人具有 url 和 email 。\n\n### files\n\n\"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）\n你也可以在模块根目录下创建一个\".npmignore\"文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。\n\n容易被忽略的文件：\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json （改用shrinkwrap）\n\n### main\n\n程序的主要入口，这应该是相对于包文件夹根目录的模块ID。\n\n### browser\n\n如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）\n\n### bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）\n如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n例如：\n```\n{ \"bin\" : { \"myapp\" : \"./cli.js\" } }\n```\n\n模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。\n如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n```\n{ \n    \"name\": \"my-program\",\n    \"version\": \"1.2.5\",\n    \"bin\": \"./path/to/program\",\n}\n```\n\n### man\n\n制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。\n如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : \"./man/doc.1\"\n}\n```\n\n通过 man foo 命令会得到 ./man/doc.1 文件的内容。\n如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ]\n}\n```\n\n会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。\nman文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ]\n}\n```\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n### directories\n\nCommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。\n目前这个配置没有任何作用。\n\ndirectories.lib\n告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\ndirectories.bin\n如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。\n\ndirectories.man\n指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。\n\ndirectories.doc\n在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）\n\ndirectories.example\n放一些示例脚本，或许某一天会有用 - -！\n\n### repository\n\n代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 ` npm docs ` 命令将能够找到你的项目\n\n例如：\n```\n\"repository\" :\n  { \n      \"type\" : \"git\",\n      \"url\" : \"https://github.com/npm/npm.git\"\n  }\n\n\"repository\" :\n  { \n    \"type\" : \"svn\",\n    \"url\" : \"https://v8.googlecode.com/svn/trunk/\"\n  }\n```\n\n该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。\n\n对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法\n\n### scripts\n\n“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。\n[npm-scripts 查看更多](https://docs.npmjs.com/misc/scripts)\n\n### config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。\n用户用的时候可以使用如下用法：\n```\nhttp.createServer(...).listen(process.env.npm_package_config_port) \n```\n\n可以通过npm config set foo:port 80来修改config:\n```\n{ \n    \"name\" : \"foo\",\n    \"config\" : { \"port\" : \"8080\" }\n}\n```\n\n### dependencies 和 devDependencies\n\ndependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。\n它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n对应的版本可以加上各种限定，主要有以下几种：\n\n指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n> 1. 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n> \n> 2. 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n> \n> 3. latest：安装最新版本。\n\npackage.json 文件可以手工编写，也可以使用 ` npm init ` 命令自动生成。项目名称（name）和项目版本（version）是必填的\n\n通过指令安装：\n```\n$ npm install express --save\n$ npm install express --save-dev\n```\n\n` --save ` 参数表示将该模块写入 dependencies 属性\n` --save-dev ` 表示将该模块写入 devDependencies 属性。\n\n### peerDependencies\n\n有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。\n\n大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\n\npeerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。\n\n例如：\n```\n{\n  \"name\": \"tea-latte\",\n  \"version\": \"1.3.5\",\n  \"peerDependencies\": {\n    \"tea\": \"2.x\"\n  }\n}\n```\n\n这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：\n```\n├── tea-latte@1.3.5\n└── tea@2.2.0\n```\n\n注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。\n\n### preferGlobal\n\npreferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n\n### style\n\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。","slug":"package-json文件","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbaz000qfwvpsnnmc4vg","content":"<p>一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 <code>npm install</code> 会根据这个配置文件自动下载所需模块。</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>项目的名字</p>\n<p>规则：</p>\n<ol>\n<li>该名称必须小于或等于214个字符。</li>\n<li>名称不能以点或下划线开头。</li>\n<li>新包名称中不能包含大写字母。</li>\n<li>该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。</li>\n</ol>\n<p>技巧</p>\n<ol>\n<li>不要使用与核心节点模块相同的名称。</li>\n<li>不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）</li>\n<li>这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。</li>\n<li><p>你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 <a href=\"https://docs.npmjs.com/misc/scope\" target=\"_blank\" rel=\"noopener\">npm-scope</a>查看更多</p>\n</li>\n</ol>\n<h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search</p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p>如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。</p>\n<p>版本必须可以由 <a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">node-semver</a> 解析</p>\n<h3 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h3><p>把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。</p>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><p>项目首页的网址</p>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><p>如果项目有问题，可以提交的问题的邮箱和 url。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">  &quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 <code>npm bugs</code> 命令使用。</p>\n<h3 id=\"license\"><a href=\"#license\" class=\"headerlink\" title=\"license\"></a>license</h3><p>项目包的许可证，可以让别人知道你的项目包的限制。<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">查看详情</a></p>\n<h3 id=\"people-fields-author-contributors\"><a href=\"#people-fields-author-contributors\" class=\"headerlink\" title=\"people fields: author, contributors\"></a>people fields: author, contributors</h3><p>author 是一个人，contributors 是一群人。人具有 url 和 email 。</p>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p>\n<p>容易被忽略的文件：<br>.git<br>CVS<br>.svn<br>.hg<br>.lock-wscript<br>.wafpickle-N<br>.<em>.swp<br>.DS_Store<br>._</em><br>npm-debug.log<br>.npmrc<br>node_modules<br>config.gypi<br>*.orig<br>package-lock.json （改用shrinkwrap）</p>\n<h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><p>程序的主要入口，这应该是相对于包文件夹根目录的模块ID。</p>\n<h3 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h3><p>如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot;: &quot;my-program&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.2.5&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &quot;./path/to/program&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : &quot;./man/doc.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。<br>如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 <a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br>目前这个配置没有任何作用。</p>\n<p>directories.lib<br>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<p>directories.bin<br>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<p>directories.man<br>指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。</p>\n<p>directories.doc<br>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<p>directories.example<br>放一些示例脚本，或许某一天会有用 - -！</p>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><p>代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 <code>npm docs</code> 命令将能够找到你的项目</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">      &quot;type&quot; : &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    &quot;type&quot; : &quot;svn&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。</p>\n<p>对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。<br><a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm-scripts 查看更多</a></p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.createServer(...).listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure></p>\n<p>可以通过npm config set foo:port 80来修改config:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dependencies-和-devDependencies\"><a href=\"#dependencies-和-devDependencies\" class=\"headerlink\" title=\"dependencies 和 devDependencies\"></a>dependencies 和 devDependencies</h3><p>dependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br>对应的版本可以加上各种限定，主要有以下几种：</p>\n<p>指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</p>\n<blockquote>\n<ol>\n<li><p>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</p>\n</li>\n<li><p>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</p>\n</li>\n<li><p>latest：安装最新版本。</p>\n</li>\n</ol>\n</blockquote>\n<p>package.json 文件可以手工编写，也可以使用 <code>npm init</code> 命令自动生成。项目名称（name）和项目版本（version）是必填的</p>\n<p>通过指令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br><span class=\"line\">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><code>--save</code> 参数表示将该模块写入 dependencies 属性<br><code>--save-dev</code> 表示将该模块写入 devDependencies 属性。</p>\n<h3 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。</p>\n<p>大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>\n<p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p>\n<p>peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;tea-latte&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.3.5&quot;,</span><br><span class=\"line\">  &quot;peerDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;tea&quot;: &quot;2.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── tea-latte@1.3.5</span><br><span class=\"line\">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。</p>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 <code>npm install</code> 会根据这个配置文件自动下载所需模块。</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>项目的名字</p>\n<p>规则：</p>\n<ol>\n<li>该名称必须小于或等于214个字符。</li>\n<li>名称不能以点或下划线开头。</li>\n<li>新包名称中不能包含大写字母。</li>\n<li>该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。</li>\n</ol>\n<p>技巧</p>\n<ol>\n<li>不要使用与核心节点模块相同的名称。</li>\n<li>不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）</li>\n<li>这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。</li>\n<li><p>你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 <a href=\"https://docs.npmjs.com/misc/scope\" target=\"_blank\" rel=\"noopener\">npm-scope</a>查看更多</p>\n</li>\n</ol>\n<h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search</p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p>如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。</p>\n<p>版本必须可以由 <a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">node-semver</a> 解析</p>\n<h3 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h3><p>把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。</p>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><p>项目首页的网址</p>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><p>如果项目有问题，可以提交的问题的邮箱和 url。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">  &quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 <code>npm bugs</code> 命令使用。</p>\n<h3 id=\"license\"><a href=\"#license\" class=\"headerlink\" title=\"license\"></a>license</h3><p>项目包的许可证，可以让别人知道你的项目包的限制。<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">查看详情</a></p>\n<h3 id=\"people-fields-author-contributors\"><a href=\"#people-fields-author-contributors\" class=\"headerlink\" title=\"people fields: author, contributors\"></a>people fields: author, contributors</h3><p>author 是一个人，contributors 是一群人。人具有 url 和 email 。</p>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p>\n<p>容易被忽略的文件：<br>.git<br>CVS<br>.svn<br>.hg<br>.lock-wscript<br>.wafpickle-N<br>.<em>.swp<br>.DS_Store<br>._</em><br>npm-debug.log<br>.npmrc<br>node_modules<br>config.gypi<br>*.orig<br>package-lock.json （改用shrinkwrap）</p>\n<h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><p>程序的主要入口，这应该是相对于包文件夹根目录的模块ID。</p>\n<h3 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h3><p>如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot;: &quot;my-program&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.2.5&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &quot;./path/to/program&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : &quot;./man/doc.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。<br>如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 <a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br>目前这个配置没有任何作用。</p>\n<p>directories.lib<br>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<p>directories.bin<br>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<p>directories.man<br>指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。</p>\n<p>directories.doc<br>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<p>directories.example<br>放一些示例脚本，或许某一天会有用 - -！</p>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><p>代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 <code>npm docs</code> 命令将能够找到你的项目</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">      &quot;type&quot; : &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    &quot;type&quot; : &quot;svn&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。</p>\n<p>对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。<br><a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm-scripts 查看更多</a></p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.createServer(...).listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure></p>\n<p>可以通过npm config set foo:port 80来修改config:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dependencies-和-devDependencies\"><a href=\"#dependencies-和-devDependencies\" class=\"headerlink\" title=\"dependencies 和 devDependencies\"></a>dependencies 和 devDependencies</h3><p>dependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br>对应的版本可以加上各种限定，主要有以下几种：</p>\n<p>指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</p>\n<blockquote>\n<ol>\n<li><p>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</p>\n</li>\n<li><p>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</p>\n</li>\n<li><p>latest：安装最新版本。</p>\n</li>\n</ol>\n</blockquote>\n<p>package.json 文件可以手工编写，也可以使用 <code>npm init</code> 命令自动生成。项目名称（name）和项目版本（version）是必填的</p>\n<p>通过指令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br><span class=\"line\">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><code>--save</code> 参数表示将该模块写入 dependencies 属性<br><code>--save-dev</code> 表示将该模块写入 devDependencies 属性。</p>\n<h3 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。</p>\n<p>大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>\n<p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p>\n<p>peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;tea-latte&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.3.5&quot;,</span><br><span class=\"line\">  &quot;peerDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;tea&quot;: &quot;2.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── tea-latte@1.3.5</span><br><span class=\"line\">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。</p>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p>\n"},{"title":"React 生命周期详解","date":"2018-06-28T15:25:26.000Z","_content":"\n## 组件渲染顺序\n\n### 第一次 render\n\n第一次在`客户端`渲染：\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n5.  componentDidMount\n\n第一次在`服务端`渲染\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n\ncomponentDidMount 不会在服务端被渲染的过程中调用。\ngetDefaultProps 相当于 ES6 中 `staticdefaultProps = {}`\ngetInitialState 相当于 constructor 中的 `this.state = {}`\n\n### Props 改变\n\n1.  componentWillReceiveProps\n2.  shouldComponentUpdate\n3.  componentWillUpdate\n4.  render\n5.  componentDidUpdate\n\n### State 改变\n\n1.  shuldComponentDidMount\n2.  componentWillUpdate\n3.  render\n4.  componentDidUpdate\n\n### 组件销毁\n\n1. componentWillUnmount\n\n## 生命周期函数详解\n\n### getDefaultProps\n\n这个方法在组件中只会调用一次，返回的对象可以设置默认的 `props`（properties 的缩写）值。\n\n```jsx\nclass App extends React.Component {\n    getDefaultProps: () => {\n        return {\n            name: 'pomy',\n        }\n    };\n\n    render() {\n        return (\n            <div>\n                Hello {this.props.name}\n            </div>\n        );\n    }\n}\n\nexport default App;\n\n// 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy\n```\n### getInitialState\n\n该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，\n\n> getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。\n> getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。\n\n\n```jsx\nclass App extends React.Component {\n    getInitialState: () => {\n        return {liked: false};\n    };\n\n    handleClick: () => {\n        this.setState({liked: !this.state.liked});\n    };\n    render() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n}\n\nexport default App;\n```\n\n### componentWillMount\n\n该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。\n\n### render\n\n必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。\n\n### componentDidMount\n\n该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。\n\n### componentWillReceiveProps\n\n子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。\n\n### shouldComponentUpdate\n\n该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。\n\n### componentWillUpdate\n\n该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）\n\n### componentDidUpdate\n\n在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。\n\n### componentWillUnmount\n\n组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。\n\n","source":"_posts/react-Lifecycle.md","raw":"---\ntitle: React 生命周期详解\ndate: 2018-06-28 23:25:26\ntags: ['react', 'js']\n---\n\n## 组件渲染顺序\n\n### 第一次 render\n\n第一次在`客户端`渲染：\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n5.  componentDidMount\n\n第一次在`服务端`渲染\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n\ncomponentDidMount 不会在服务端被渲染的过程中调用。\ngetDefaultProps 相当于 ES6 中 `staticdefaultProps = {}`\ngetInitialState 相当于 constructor 中的 `this.state = {}`\n\n### Props 改变\n\n1.  componentWillReceiveProps\n2.  shouldComponentUpdate\n3.  componentWillUpdate\n4.  render\n5.  componentDidUpdate\n\n### State 改变\n\n1.  shuldComponentDidMount\n2.  componentWillUpdate\n3.  render\n4.  componentDidUpdate\n\n### 组件销毁\n\n1. componentWillUnmount\n\n## 生命周期函数详解\n\n### getDefaultProps\n\n这个方法在组件中只会调用一次，返回的对象可以设置默认的 `props`（properties 的缩写）值。\n\n```jsx\nclass App extends React.Component {\n    getDefaultProps: () => {\n        return {\n            name: 'pomy',\n        }\n    };\n\n    render() {\n        return (\n            <div>\n                Hello {this.props.name}\n            </div>\n        );\n    }\n}\n\nexport default App;\n\n// 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy\n```\n### getInitialState\n\n该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，\n\n> getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。\n> getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。\n\n\n```jsx\nclass App extends React.Component {\n    getInitialState: () => {\n        return {liked: false};\n    };\n\n    handleClick: () => {\n        this.setState({liked: !this.state.liked});\n    };\n    render() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n}\n\nexport default App;\n```\n\n### componentWillMount\n\n该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。\n\n### render\n\n必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。\n\n### componentDidMount\n\n该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。\n\n### componentWillReceiveProps\n\n子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。\n\n### shouldComponentUpdate\n\n该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。\n\n### componentWillUpdate\n\n该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）\n\n### componentDidUpdate\n\n在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。\n\n### componentWillUnmount\n\n组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。\n\n","slug":"react-Lifecycle","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbb0000sfwvpy77gz8vy","content":"<h2 id=\"组件渲染顺序\"><a href=\"#组件渲染顺序\" class=\"headerlink\" title=\"组件渲染顺序\"></a>组件渲染顺序</h2><h3 id=\"第一次-render\"><a href=\"#第一次-render\" class=\"headerlink\" title=\"第一次 render\"></a>第一次 render</h3><p>第一次在<code>客户端</code>渲染：</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ol>\n<p>第一次在<code>服务端</code>渲染</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n</ol>\n<p>componentDidMount 不会在服务端被渲染的过程中调用。<br>getDefaultProps 相当于 ES6 中 <code>staticdefaultProps = {}</code><br>getInitialState 相当于 constructor 中的 <code>this.state = {}</code></p>\n<h3 id=\"Props-改变\"><a href=\"#Props-改变\" class=\"headerlink\" title=\"Props 改变\"></a>Props 改变</h3><ol>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"State-改变\"><a href=\"#State-改变\" class=\"headerlink\" title=\"State 改变\"></a>State 改变</h3><ol>\n<li>shuldComponentDidMount</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"组件销毁\"><a href=\"#组件销毁\" class=\"headerlink\" title=\"组件销毁\"></a>组件销毁</h3><ol>\n<li>componentWillUnmount</li>\n</ol>\n<h2 id=\"生命周期函数详解\"><a href=\"#生命周期函数详解\" class=\"headerlink\" title=\"生命周期函数详解\"></a>生命周期函数详解</h2><h3 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a>getDefaultProps</h3><p>这个方法在组件中只会调用一次，返回的对象可以设置默认的 <code>props</code>（properties 的缩写）值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            name: <span class=\"string\">'pomy'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Hello &#123;<span class=\"keyword\">this</span>.props.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"getInitialState\"><a href=\"#getInitialState\" class=\"headerlink\" title=\"getInitialState\"></a>getInitialState</h3><p>该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，</p>\n<blockquote>\n<p>getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。<br>getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">liked</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">liked</span>: !<span class=\"keyword\">this</span>.state.liked&#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.state.liked ? <span class=\"string\">'like'</span> : <span class=\"string\">'haven\\'t liked'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        You &#123;text&#125; <span class=\"keyword\">this</span>. Click to toggle.</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a>componentWillMount</h3><p>该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><p>必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。</p>\n<h3 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h3><p>该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。</p>\n<h3 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h3><p>子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p>该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。</p>\n<h3 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a>componentWillUpdate</h3><p>该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）</p>\n<h3 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h3><p>在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。</p>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"组件渲染顺序\"><a href=\"#组件渲染顺序\" class=\"headerlink\" title=\"组件渲染顺序\"></a>组件渲染顺序</h2><h3 id=\"第一次-render\"><a href=\"#第一次-render\" class=\"headerlink\" title=\"第一次 render\"></a>第一次 render</h3><p>第一次在<code>客户端</code>渲染：</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ol>\n<p>第一次在<code>服务端</code>渲染</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n</ol>\n<p>componentDidMount 不会在服务端被渲染的过程中调用。<br>getDefaultProps 相当于 ES6 中 <code>staticdefaultProps = {}</code><br>getInitialState 相当于 constructor 中的 <code>this.state = {}</code></p>\n<h3 id=\"Props-改变\"><a href=\"#Props-改变\" class=\"headerlink\" title=\"Props 改变\"></a>Props 改变</h3><ol>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"State-改变\"><a href=\"#State-改变\" class=\"headerlink\" title=\"State 改变\"></a>State 改变</h3><ol>\n<li>shuldComponentDidMount</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"组件销毁\"><a href=\"#组件销毁\" class=\"headerlink\" title=\"组件销毁\"></a>组件销毁</h3><ol>\n<li>componentWillUnmount</li>\n</ol>\n<h2 id=\"生命周期函数详解\"><a href=\"#生命周期函数详解\" class=\"headerlink\" title=\"生命周期函数详解\"></a>生命周期函数详解</h2><h3 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a>getDefaultProps</h3><p>这个方法在组件中只会调用一次，返回的对象可以设置默认的 <code>props</code>（properties 的缩写）值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            name: <span class=\"string\">'pomy'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Hello &#123;<span class=\"keyword\">this</span>.props.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"getInitialState\"><a href=\"#getInitialState\" class=\"headerlink\" title=\"getInitialState\"></a>getInitialState</h3><p>该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，</p>\n<blockquote>\n<p>getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。<br>getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">liked</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">liked</span>: !<span class=\"keyword\">this</span>.state.liked&#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.state.liked ? <span class=\"string\">'like'</span> : <span class=\"string\">'haven\\'t liked'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        You &#123;text&#125; <span class=\"keyword\">this</span>. Click to toggle.</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a>componentWillMount</h3><p>该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><p>必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。</p>\n<h3 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h3><p>该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。</p>\n<h3 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h3><p>子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p>该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。</p>\n<h3 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a>componentWillUpdate</h3><p>该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）</p>\n<h3 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h3><p>在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。</p>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</p>\n"},{"title":"react-高阶组件（HOC）","date":"2018-08-09T10:43:09.000Z","_content":"使用 react 很久了，也使用 react 高阶组件很多次了，但是总也没有特别清楚的去总结一下高阶组件，现在终于有时间总结如下：\n\n\n## 是什么\n高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n对比组件将props属性转变成UI，高阶组件则是将一个组件转换成另一个新组件。\n\n例如 [`Redux`](https://redux.js.org/) 的 `connect` 方法，就是典型的高阶组件。\n\n## 做什么\n\n[react 官方文档](https://doc.react-china.org/docs/higher-order-components.html)上说是解决交叉问题的。\n直白了说就是解决了同一个数据在不同组件中渲染的问题\n\n详细了说：\n\n```jsx\nclass CommentList extends React.Component {\n  constructor() {\n    super();\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      // \"DataSource\" 就是全局的数据源\n      comments: DataSource.getComments()\n    };\n  }\n\n  componentDidMount() {\n    // 添加事件处理函数订阅数据\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    // 清除事件处理函数\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    // 任何时候数据发生改变就更新组件\n    this.setState({\n      comments: DataSource.getComments()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        {this.state.comments.map((comment) => (\n          <Comment comment={comment} key={comment.id} />\n        ))}\n      </div>\n    );\n  }\n}\n```\n```jsx\nclass BlogPost extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    this.setState({\n      blogPost: DataSource.getBlogPost(this.props.id)\n    });\n  }\n\n  render() {\n    return <TextBlock text={this.state.blogPost} />;\n  }\n}\n```\n\n以上两个组件 `CommentList` 和 `BlogPost` 都调用了 `DataSource` 的不同方法获取数据，渲染出不同的结果。但是整体相同的路由有：\n1. 挂载组件时， 向 DataSource 添加一个监听函数。\n2. 在监听函数内， 每当数据源发生变化，都是调用 setState函数设置新数据。\n3. 卸载组件时， 移除监听函数。\n\n高阶组件的精华就是：\n在一个大型应用中，在 `DataSource` 中获取数据，通过 `setState` 模式修改的情况会发生好多次，这个时候我们就可以抽象出一个模式，该模式允许我们在同一个地方写一个逻辑，在多个组件中都能使用。\n\n所以我们是使用高级组件解决以上例子为：\n```jsx\n// 函数接受一个组件参数……\nfunction withSubscription(WrappedComponent, selectData) {\n    // WrappedComponent: 包裹的组件\n    // selectData: 组件中需要修改的数据\n  // ……返回另一个新组件……\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ……注意订阅数据……\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ……使用最新的数据渲染组件\n      // 注意此处将已有的props属性传递给原组件\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n```\n```jsx\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id)\n);\n```\n\n> 注意：高阶组件既不会修改原组件，也不会使用继承复制原组件的行为。相反，高阶组件是通过将原组件包裹（wrapping）在容器组件（container component）里面的方式来 组合（composes） 使用原组件。高阶组件就是一个没有副作用的纯函数。\n\n包裹组件不关心数据是如何被使用的，你可以在 `withSubscription` 中添加任何参数进行更多的配置，包裹组件和 `withSubscription` 之间的传递也完全是通过 `props` 传递的。\n\n## 注意点\n\n不要在高阶组件内部修改（或以其它方式修改）原组件的原型属性。\n如下的错误事例：\n```jsx\nfunction logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  }\n  // 我们返回的原始组件实际上已经\n  // 被修改了。\n  return InputComponent;\n}\n\n// EnhancedComponent会记录下所有的props属性\nconst EnhancedComponent = logProps(InputComponent);\n```\n\n问题：\n1. input组件不能够脱离增强型组件（enhanced component）被重用。（复用性底）\n2. 如果你用另一个高阶组件来转变 EnhancedComponent ，同样的也去改变 componentWillReceiveProps 函数时，第一个高阶组件（即EnhancedComponent）转换的功能就会被覆盖。\n\n正确的写法：\n```jsx\nfunction logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      // 用容器组件组合包裹组件且不修改包裹组件，这才是正确的打开方式。\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n```\n\n优点：\n1. 复用性高，可以重复使用。\n\n综上总结：高阶组件就是容器组件的一部分，也可以认为高阶组件就是参数化的容器组件定义\n\n## 约定\n\n### 1. 不传不相关的 props\n\n高阶组件应该传递与它要实现的功能点无关的props属性。\n\n例如：\n```js\nrender() {\n  // 过滤掉与高阶函数功能相关的props属性，\n  // 不再传递\n  const { extraProp, ...passThroughProps } = this.props;\n\n  // 向包裹组件注入props属性，一般都是高阶组件的state状态\n  // 或实例方法\n  const injectedProp = someStateOrInstanceMethod;\n\n  // 向包裹组件传递props属性\n  return (\n    <WrappedComponent\n      injectedProp={injectedProp}\n      {...passThroughProps}\n    />\n  );\n}\n```\n\n原因：确保高阶组件最大程度的 灵活性 和 可重用性。\n\n### 2. 最大化使用组合\n\n并不是所有的高阶组件看起来都是一样的。有时，它们仅仅接收一个参数，即包裹组件：\n\n```js\nconst NavbarWithRouter = withRouter(Navbar);\n```\n\n一般而言，高阶组件会接收额外的参数。例如 Relay 的一个例子：\n\n```jsx\nconst CommentWithRelay = Relay.createContainer(Comment, config);\n```\n\n我们常用的 `redux` 的 `connect` 就是一个很典型的例子\n```jsx\n// React Redux's `connect`\nconst ConnectedComment = connect(commentSelector, commentActions)(Comment);\n```\n拨开之后：\n```jsx\n// connect是一个返回函数的函数（译者注：就是个高阶函数）\nconst enhance = connect(commentListSelector, commentListActions);\n// 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store\n// 关联起来的新组件\nconst ConnectedComment = enhance(CommentList);\n```\n\n拨开之后是不是瞬间清晰了很多，说到底  `connect` 就是一个返回了高阶组件的函数\n\n这种形式有点让人迷惑，有点多余，但是它有一个有用的属性。那就是，类似 connect 函数返回的单参数的高阶组件有着这样的签名格式， `Component => Component` .输入和输出类型相同的函数是很容易组合在一起。\n\n```js\n// 不要这样做……\nconst EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))\n\n// ……你可以使用一个功能组合工具\n// compose(f, g, h) 和 (...args) => f(g(h(...args)))是一样的\nconst enhance = compose(\n  // 这些都是单参数的高阶组件\n  withRouter,\n  connect(commentSelector)\n)\nconst EnhancedComponent = enhance(WrappedComponent)\n```\n\n同样做法发还有 [`lodash`](https://lodash.com/docs/#flowRight) 和 [` Ramda`](https://ramdajs.com/docs/#compose) 他们均有 `compose` 这种组合函数。\n\n\n### 3. 包装显示名字以便于调试\n\n我们一般给高阶组件起名字都是 `with*`，例如：高阶组件名字`withSubscription` ，包裹组件名字 `CommentList`，使用时为 `WithSubscription(CommentList)`\n\n原因：区分高阶组件和普通组件\n\n## 注意事项\n\n### 1. 不要再render函数中使用高阶组件\n\n```jsx\nrender() {\n  // 每一次render函数调用都会创建一个新的EnhancedComponent实例\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // 每一次都会使子对象树完全被卸载或移除\n  return <EnhancedComponent />;\n}\n```\n\n如上使用的话问题：\n1. 性能问题\n2. 重新加载一个组件会引起原有组件的所有状态和子组件丢失。\n\n如果需要动态调用高阶组件，那么可以在组件的构造函数或生命周期函数中调用。\n\n### 2. 必须将静态方法做拷贝\n\n当使用高阶组件时，原始组件呗容器组件包裹之后就会失去原始组件原来的方法。解决这个问题就是需要我们把静态方法全部拷贝。\n\n方法：\n1. 使用 [`hoist-non-react-statics`](https://github.com/mridgway/hoist-non-react-statics)\n\n```jsx\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n```\n2. 分别导出组件自身的静态方法\n\n```jsx\n// 替代……\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ……分别导出……\nexport { someFunction };\n\n// ……在要使用的组件中导入\nimport MyComponent, { someFunction } from './MyComponent.js';\n```\n\n### 3. Refs属性不能传递\n\n高阶组件可以传递所有的props属性给包裹的组件，但是不能传递refs引用。\nrefs是一个伪属性，React对它进行了特殊处理。如果你向一个由高阶组件创建的组件的元素添加ref应用，那么ref指向的是最外层容器组件实例的，而不是包裹组件。\n\n","source":"_posts/react-高阶组件.md","raw":"---\ntitle: react-高阶组件（HOC）\ndate: 2018-08-09 18:43:09\ntags: ['js', 'react']\n---\n使用 react 很久了，也使用 react 高阶组件很多次了，但是总也没有特别清楚的去总结一下高阶组件，现在终于有时间总结如下：\n\n\n## 是什么\n高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n对比组件将props属性转变成UI，高阶组件则是将一个组件转换成另一个新组件。\n\n例如 [`Redux`](https://redux.js.org/) 的 `connect` 方法，就是典型的高阶组件。\n\n## 做什么\n\n[react 官方文档](https://doc.react-china.org/docs/higher-order-components.html)上说是解决交叉问题的。\n直白了说就是解决了同一个数据在不同组件中渲染的问题\n\n详细了说：\n\n```jsx\nclass CommentList extends React.Component {\n  constructor() {\n    super();\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      // \"DataSource\" 就是全局的数据源\n      comments: DataSource.getComments()\n    };\n  }\n\n  componentDidMount() {\n    // 添加事件处理函数订阅数据\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    // 清除事件处理函数\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    // 任何时候数据发生改变就更新组件\n    this.setState({\n      comments: DataSource.getComments()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        {this.state.comments.map((comment) => (\n          <Comment comment={comment} key={comment.id} />\n        ))}\n      </div>\n    );\n  }\n}\n```\n```jsx\nclass BlogPost extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange() {\n    this.setState({\n      blogPost: DataSource.getBlogPost(this.props.id)\n    });\n  }\n\n  render() {\n    return <TextBlock text={this.state.blogPost} />;\n  }\n}\n```\n\n以上两个组件 `CommentList` 和 `BlogPost` 都调用了 `DataSource` 的不同方法获取数据，渲染出不同的结果。但是整体相同的路由有：\n1. 挂载组件时， 向 DataSource 添加一个监听函数。\n2. 在监听函数内， 每当数据源发生变化，都是调用 setState函数设置新数据。\n3. 卸载组件时， 移除监听函数。\n\n高阶组件的精华就是：\n在一个大型应用中，在 `DataSource` 中获取数据，通过 `setState` 模式修改的情况会发生好多次，这个时候我们就可以抽象出一个模式，该模式允许我们在同一个地方写一个逻辑，在多个组件中都能使用。\n\n所以我们是使用高级组件解决以上例子为：\n```jsx\n// 函数接受一个组件参数……\nfunction withSubscription(WrappedComponent, selectData) {\n    // WrappedComponent: 包裹的组件\n    // selectData: 组件中需要修改的数据\n  // ……返回另一个新组件……\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ……注意订阅数据……\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ……使用最新的数据渲染组件\n      // 注意此处将已有的props属性传递给原组件\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n```\n```jsx\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id)\n);\n```\n\n> 注意：高阶组件既不会修改原组件，也不会使用继承复制原组件的行为。相反，高阶组件是通过将原组件包裹（wrapping）在容器组件（container component）里面的方式来 组合（composes） 使用原组件。高阶组件就是一个没有副作用的纯函数。\n\n包裹组件不关心数据是如何被使用的，你可以在 `withSubscription` 中添加任何参数进行更多的配置，包裹组件和 `withSubscription` 之间的传递也完全是通过 `props` 传递的。\n\n## 注意点\n\n不要在高阶组件内部修改（或以其它方式修改）原组件的原型属性。\n如下的错误事例：\n```jsx\nfunction logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  }\n  // 我们返回的原始组件实际上已经\n  // 被修改了。\n  return InputComponent;\n}\n\n// EnhancedComponent会记录下所有的props属性\nconst EnhancedComponent = logProps(InputComponent);\n```\n\n问题：\n1. input组件不能够脱离增强型组件（enhanced component）被重用。（复用性底）\n2. 如果你用另一个高阶组件来转变 EnhancedComponent ，同样的也去改变 componentWillReceiveProps 函数时，第一个高阶组件（即EnhancedComponent）转换的功能就会被覆盖。\n\n正确的写法：\n```jsx\nfunction logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      // 用容器组件组合包裹组件且不修改包裹组件，这才是正确的打开方式。\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n```\n\n优点：\n1. 复用性高，可以重复使用。\n\n综上总结：高阶组件就是容器组件的一部分，也可以认为高阶组件就是参数化的容器组件定义\n\n## 约定\n\n### 1. 不传不相关的 props\n\n高阶组件应该传递与它要实现的功能点无关的props属性。\n\n例如：\n```js\nrender() {\n  // 过滤掉与高阶函数功能相关的props属性，\n  // 不再传递\n  const { extraProp, ...passThroughProps } = this.props;\n\n  // 向包裹组件注入props属性，一般都是高阶组件的state状态\n  // 或实例方法\n  const injectedProp = someStateOrInstanceMethod;\n\n  // 向包裹组件传递props属性\n  return (\n    <WrappedComponent\n      injectedProp={injectedProp}\n      {...passThroughProps}\n    />\n  );\n}\n```\n\n原因：确保高阶组件最大程度的 灵活性 和 可重用性。\n\n### 2. 最大化使用组合\n\n并不是所有的高阶组件看起来都是一样的。有时，它们仅仅接收一个参数，即包裹组件：\n\n```js\nconst NavbarWithRouter = withRouter(Navbar);\n```\n\n一般而言，高阶组件会接收额外的参数。例如 Relay 的一个例子：\n\n```jsx\nconst CommentWithRelay = Relay.createContainer(Comment, config);\n```\n\n我们常用的 `redux` 的 `connect` 就是一个很典型的例子\n```jsx\n// React Redux's `connect`\nconst ConnectedComment = connect(commentSelector, commentActions)(Comment);\n```\n拨开之后：\n```jsx\n// connect是一个返回函数的函数（译者注：就是个高阶函数）\nconst enhance = connect(commentListSelector, commentListActions);\n// 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store\n// 关联起来的新组件\nconst ConnectedComment = enhance(CommentList);\n```\n\n拨开之后是不是瞬间清晰了很多，说到底  `connect` 就是一个返回了高阶组件的函数\n\n这种形式有点让人迷惑，有点多余，但是它有一个有用的属性。那就是，类似 connect 函数返回的单参数的高阶组件有着这样的签名格式， `Component => Component` .输入和输出类型相同的函数是很容易组合在一起。\n\n```js\n// 不要这样做……\nconst EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))\n\n// ……你可以使用一个功能组合工具\n// compose(f, g, h) 和 (...args) => f(g(h(...args)))是一样的\nconst enhance = compose(\n  // 这些都是单参数的高阶组件\n  withRouter,\n  connect(commentSelector)\n)\nconst EnhancedComponent = enhance(WrappedComponent)\n```\n\n同样做法发还有 [`lodash`](https://lodash.com/docs/#flowRight) 和 [` Ramda`](https://ramdajs.com/docs/#compose) 他们均有 `compose` 这种组合函数。\n\n\n### 3. 包装显示名字以便于调试\n\n我们一般给高阶组件起名字都是 `with*`，例如：高阶组件名字`withSubscription` ，包裹组件名字 `CommentList`，使用时为 `WithSubscription(CommentList)`\n\n原因：区分高阶组件和普通组件\n\n## 注意事项\n\n### 1. 不要再render函数中使用高阶组件\n\n```jsx\nrender() {\n  // 每一次render函数调用都会创建一个新的EnhancedComponent实例\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // 每一次都会使子对象树完全被卸载或移除\n  return <EnhancedComponent />;\n}\n```\n\n如上使用的话问题：\n1. 性能问题\n2. 重新加载一个组件会引起原有组件的所有状态和子组件丢失。\n\n如果需要动态调用高阶组件，那么可以在组件的构造函数或生命周期函数中调用。\n\n### 2. 必须将静态方法做拷贝\n\n当使用高阶组件时，原始组件呗容器组件包裹之后就会失去原始组件原来的方法。解决这个问题就是需要我们把静态方法全部拷贝。\n\n方法：\n1. 使用 [`hoist-non-react-statics`](https://github.com/mridgway/hoist-non-react-statics)\n\n```jsx\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n```\n2. 分别导出组件自身的静态方法\n\n```jsx\n// 替代……\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ……分别导出……\nexport { someFunction };\n\n// ……在要使用的组件中导入\nimport MyComponent, { someFunction } from './MyComponent.js';\n```\n\n### 3. Refs属性不能传递\n\n高阶组件可以传递所有的props属性给包裹的组件，但是不能传递refs引用。\nrefs是一个伪属性，React对它进行了特殊处理。如果你向一个由高阶组件创建的组件的元素添加ref应用，那么ref指向的是最外层容器组件实例的，而不是包裹组件。\n\n","slug":"react-高阶组件","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbb4000wfwvp1uuvuste","content":"<p>使用 react 很久了，也使用 react 高阶组件很多次了，但是总也没有特别清楚的去总结一下高阶组件，现在终于有时间总结如下：</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。<br>对比组件将props属性转变成UI，高阶组件则是将一个组件转换成另一个新组件。</p>\n<p>例如 <a href=\"https://redux.js.org/\" target=\"_blank\" rel=\"noopener\"><code>Redux</code></a> 的 <code>connect</code> 方法，就是典型的高阶组件。</p>\n<h2 id=\"做什么\"><a href=\"#做什么\" class=\"headerlink\" title=\"做什么\"></a>做什么</h2><p><a href=\"https://doc.react-china.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">react 官方文档</a>上说是解决交叉问题的。<br>直白了说就是解决了同一个数据在不同组件中渲染的问题</p>\n<p>详细了说：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentList</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      <span class=\"comment\">// \"DataSource\" 就是全局的数据源</span></span><br><span class=\"line\">      comments: DataSource.getComments()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加事件处理函数订阅数据</span></span><br><span class=\"line\">    DataSource.addChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除事件处理函数</span></span><br><span class=\"line\">    DataSource.removeChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任何时候数据发生改变就更新组件</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      comments: DataSource.getComments()</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.comments.map(<span class=\"function\">(<span class=\"params\">comment</span>) =&gt;</span> (</span><br><span class=\"line\">          &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class=\"line\">        ))&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlogPost</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    DataSource.addChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    DataSource.removeChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上两个组件 <code>CommentList</code> 和 <code>BlogPost</code> 都调用了 <code>DataSource</code> 的不同方法获取数据，渲染出不同的结果。但是整体相同的路由有：</p>\n<ol>\n<li>挂载组件时， 向 DataSource 添加一个监听函数。</li>\n<li>在监听函数内， 每当数据源发生变化，都是调用 setState函数设置新数据。</li>\n<li>卸载组件时， 移除监听函数。</li>\n</ol>\n<p>高阶组件的精华就是：<br>在一个大型应用中，在 <code>DataSource</code> 中获取数据，通过 <code>setState</code> 模式修改的情况会发生好多次，这个时候我们就可以抽象出一个模式，该模式允许我们在同一个地方写一个逻辑，在多个组件中都能使用。</p>\n<p>所以我们是使用高级组件解决以上例子为：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数接受一个组件参数……</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withSubscription</span>(<span class=\"params\">WrappedComponent, selectData</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// WrappedComponent: 包裹的组件</span></span><br><span class=\"line\">    <span class=\"comment\">// selectData: 组件中需要修改的数据</span></span><br><span class=\"line\">  <span class=\"comment\">// ……返回另一个新组件……</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ……注意订阅数据……</span></span><br><span class=\"line\">      DataSource.addChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, <span class=\"keyword\">this</span>.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ……使用最新的数据渲染组件</span></span><br><span class=\"line\">      <span class=\"comment\">// 注意此处将已有的props属性传递给原组件</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommentListWithSubscription = withSubscription(</span><br><span class=\"line\">  CommentList,</span><br><span class=\"line\">  (DataSource) =&gt; DataSource.getComments()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> BlogPostWithSubscription = withSubscription(</span><br><span class=\"line\">  BlogPost,</span><br><span class=\"line\">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：高阶组件既不会修改原组件，也不会使用继承复制原组件的行为。相反，高阶组件是通过将原组件包裹（wrapping）在容器组件（container component）里面的方式来 组合（composes） 使用原组件。高阶组件就是一个没有副作用的纯函数。</p>\n</blockquote>\n<p>包裹组件不关心数据是如何被使用的，你可以在 <code>withSubscription</code> 中添加任何参数进行更多的配置，包裹组件和 <code>withSubscription</code> 之间的传递也完全是通过 <code>props</code> 传递的。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>不要在高阶组件内部修改（或以其它方式修改）原组件的原型属性。<br>如下的错误事例：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">InputComponent</span>) </span>&#123;</span><br><span class=\"line\">  InputComponent.prototype.componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 我们返回的原始组件实际上已经</span></span><br><span class=\"line\">  <span class=\"comment\">// 被修改了。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> InputComponent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EnhancedComponent会记录下所有的props属性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure></p>\n<p>问题：</p>\n<ol>\n<li>input组件不能够脱离增强型组件（enhanced component）被重用。（复用性底）</li>\n<li>如果你用另一个高阶组件来转变 EnhancedComponent ，同样的也去改变 componentWillReceiveProps 函数时，第一个高阶组件（即EnhancedComponent）转换的功能就会被覆盖。</li>\n</ol>\n<p>正确的写法：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用容器组件组合包裹组件且不修改包裹组件，这才是正确的打开方式。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>复用性高，可以重复使用。</li>\n</ol>\n<p>综上总结：高阶组件就是容器组件的一部分，也可以认为高阶组件就是参数化的容器组件定义</p>\n<h2 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h2><h3 id=\"1-不传不相关的-props\"><a href=\"#1-不传不相关的-props\" class=\"headerlink\" title=\"1. 不传不相关的 props\"></a>1. 不传不相关的 props</h3><p>高阶组件应该传递与它要实现的功能点无关的props属性。</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 过滤掉与高阶函数功能相关的props属性，</span></span><br><span class=\"line\">  <span class=\"comment\">// 不再传递</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向包裹组件注入props属性，一般都是高阶组件的state状态</span></span><br><span class=\"line\">  <span class=\"comment\">// 或实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向包裹组件传递props属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;WrappedComponent</span><br><span class=\"line\">      injectedProp=&#123;injectedProp&#125;</span><br><span class=\"line\">      &#123;...passThroughProps&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原因：确保高阶组件最大程度的 灵活性 和 可重用性。</p>\n<h3 id=\"2-最大化使用组合\"><a href=\"#2-最大化使用组合\" class=\"headerlink\" title=\"2. 最大化使用组合\"></a>2. 最大化使用组合</h3><p>并不是所有的高阶组件看起来都是一样的。有时，它们仅仅接收一个参数，即包裹组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> NavbarWithRouter = withRouter(Navbar);</span><br></pre></td></tr></table></figure>\n<p>一般而言，高阶组件会接收额外的参数。例如 Relay 的一个例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommentWithRelay = Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure>\n<p>我们常用的 <code>redux</code> 的 <code>connect</code> 就是一个很典型的例子<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// React Redux's `connect`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ConnectedComment = connect(commentSelector, commentActions)(Comment);</span><br></pre></td></tr></table></figure></p>\n<p>拨开之后：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// connect是一个返回函数的函数（译者注：就是个高阶函数）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhance = connect(commentListSelector, commentListActions);</span><br><span class=\"line\"><span class=\"comment\">// 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store</span></span><br><span class=\"line\"><span class=\"comment\">// 关联起来的新组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure></p>\n<p>拨开之后是不是瞬间清晰了很多，说到底  <code>connect</code> 就是一个返回了高阶组件的函数</p>\n<p>这种形式有点让人迷惑，有点多余，但是它有一个有用的属性。那就是，类似 connect 函数返回的单参数的高阶组件有着这样的签名格式， <code>Component =&gt; Component</code> .输入和输出类型相同的函数是很容易组合在一起。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不要这样做……</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ……你可以使用一个功能组合工具</span></span><br><span class=\"line\"><span class=\"comment\">// compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhance = compose(</span><br><span class=\"line\">  <span class=\"comment\">// 这些都是单参数的高阶组件</span></span><br><span class=\"line\">  withRouter,</span><br><span class=\"line\">  connect(commentSelector)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>\n<p>同样做法发还有 <a href=\"https://lodash.com/docs/#flowRight\" target=\"_blank\" rel=\"noopener\"><code>lodash</code></a> 和 <a href=\"https://ramdajs.com/docs/#compose\" target=\"_blank\" rel=\"noopener\"><code>Ramda</code></a> 他们均有 <code>compose</code> 这种组合函数。</p>\n<h3 id=\"3-包装显示名字以便于调试\"><a href=\"#3-包装显示名字以便于调试\" class=\"headerlink\" title=\"3. 包装显示名字以便于调试\"></a>3. 包装显示名字以便于调试</h3><p>我们一般给高阶组件起名字都是 <code>with*</code>，例如：高阶组件名字<code>withSubscription</code> ，包裹组件名字 <code>CommentList</code>，使用时为 <code>WithSubscription(CommentList)</code></p>\n<p>原因：区分高阶组件和普通组件</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"1-不要再render函数中使用高阶组件\"><a href=\"#1-不要再render函数中使用高阶组件\" class=\"headerlink\" title=\"1. 不要再render函数中使用高阶组件\"></a>1. 不要再render函数中使用高阶组件</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 每一次render函数调用都会创建一个新的EnhancedComponent实例</span></span><br><span class=\"line\">  <span class=\"comment\">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class=\"line\">  <span class=\"comment\">// 每一次都会使子对象树完全被卸载或移除</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;EnhancedComponent /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上使用的话问题：</p>\n<ol>\n<li>性能问题</li>\n<li>重新加载一个组件会引起原有组件的所有状态和子组件丢失。</li>\n</ol>\n<p>如果需要动态调用高阶组件，那么可以在组件的构造函数或生命周期函数中调用。</p>\n<h3 id=\"2-必须将静态方法做拷贝\"><a href=\"#2-必须将静态方法做拷贝\" class=\"headerlink\" title=\"2. 必须将静态方法做拷贝\"></a>2. 必须将静态方法做拷贝</h3><p>当使用高阶组件时，原始组件呗容器组件包裹之后就会失去原始组件原来的方法。解决这个问题就是需要我们把静态方法全部拷贝。</p>\n<p>方法：</p>\n<ol>\n<li>使用 <a href=\"https://github.com/mridgway/hoist-non-react-statics\" target=\"_blank\" rel=\"noopener\"><code>hoist-non-react-statics</code></a></li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hoistNonReactStatic <span class=\"keyword\">from</span> <span class=\"string\">'hoist-non-react-statics'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>分别导出组件自身的静态方法</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 替代……</span></span><br><span class=\"line\">MyComponent.someFunction = someFunction;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ……分别导出……</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; someFunction &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ……在要使用的组件中导入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> MyComponent, &#123; someFunction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./MyComponent.js'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-Refs属性不能传递\"><a href=\"#3-Refs属性不能传递\" class=\"headerlink\" title=\"3. Refs属性不能传递\"></a>3. Refs属性不能传递</h3><p>高阶组件可以传递所有的props属性给包裹的组件，但是不能传递refs引用。<br>refs是一个伪属性，React对它进行了特殊处理。如果你向一个由高阶组件创建的组件的元素添加ref应用，那么ref指向的是最外层容器组件实例的，而不是包裹组件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用 react 很久了，也使用 react 高阶组件很多次了，但是总也没有特别清楚的去总结一下高阶组件，现在终于有时间总结如下：</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。<br>对比组件将props属性转变成UI，高阶组件则是将一个组件转换成另一个新组件。</p>\n<p>例如 <a href=\"https://redux.js.org/\" target=\"_blank\" rel=\"noopener\"><code>Redux</code></a> 的 <code>connect</code> 方法，就是典型的高阶组件。</p>\n<h2 id=\"做什么\"><a href=\"#做什么\" class=\"headerlink\" title=\"做什么\"></a>做什么</h2><p><a href=\"https://doc.react-china.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">react 官方文档</a>上说是解决交叉问题的。<br>直白了说就是解决了同一个数据在不同组件中渲染的问题</p>\n<p>详细了说：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentList</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      <span class=\"comment\">// \"DataSource\" 就是全局的数据源</span></span><br><span class=\"line\">      comments: DataSource.getComments()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加事件处理函数订阅数据</span></span><br><span class=\"line\">    DataSource.addChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除事件处理函数</span></span><br><span class=\"line\">    DataSource.removeChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任何时候数据发生改变就更新组件</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      comments: DataSource.getComments()</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.comments.map(<span class=\"function\">(<span class=\"params\">comment</span>) =&gt;</span> (</span><br><span class=\"line\">          &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class=\"line\">        ))&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlogPost</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    DataSource.addChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    DataSource.removeChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上两个组件 <code>CommentList</code> 和 <code>BlogPost</code> 都调用了 <code>DataSource</code> 的不同方法获取数据，渲染出不同的结果。但是整体相同的路由有：</p>\n<ol>\n<li>挂载组件时， 向 DataSource 添加一个监听函数。</li>\n<li>在监听函数内， 每当数据源发生变化，都是调用 setState函数设置新数据。</li>\n<li>卸载组件时， 移除监听函数。</li>\n</ol>\n<p>高阶组件的精华就是：<br>在一个大型应用中，在 <code>DataSource</code> 中获取数据，通过 <code>setState</code> 模式修改的情况会发生好多次，这个时候我们就可以抽象出一个模式，该模式允许我们在同一个地方写一个逻辑，在多个组件中都能使用。</p>\n<p>所以我们是使用高级组件解决以上例子为：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数接受一个组件参数……</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withSubscription</span>(<span class=\"params\">WrappedComponent, selectData</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// WrappedComponent: 包裹的组件</span></span><br><span class=\"line\">    <span class=\"comment\">// selectData: 组件中需要修改的数据</span></span><br><span class=\"line\">  <span class=\"comment\">// ……返回另一个新组件……</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ……注意订阅数据……</span></span><br><span class=\"line\">      DataSource.addChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(<span class=\"keyword\">this</span>.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, <span class=\"keyword\">this</span>.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ……使用最新的数据渲染组件</span></span><br><span class=\"line\">      <span class=\"comment\">// 注意此处将已有的props属性传递给原组件</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommentListWithSubscription = withSubscription(</span><br><span class=\"line\">  CommentList,</span><br><span class=\"line\">  (DataSource) =&gt; DataSource.getComments()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> BlogPostWithSubscription = withSubscription(</span><br><span class=\"line\">  BlogPost,</span><br><span class=\"line\">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：高阶组件既不会修改原组件，也不会使用继承复制原组件的行为。相反，高阶组件是通过将原组件包裹（wrapping）在容器组件（container component）里面的方式来 组合（composes） 使用原组件。高阶组件就是一个没有副作用的纯函数。</p>\n</blockquote>\n<p>包裹组件不关心数据是如何被使用的，你可以在 <code>withSubscription</code> 中添加任何参数进行更多的配置，包裹组件和 <code>withSubscription</code> 之间的传递也完全是通过 <code>props</code> 传递的。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>不要在高阶组件内部修改（或以其它方式修改）原组件的原型属性。<br>如下的错误事例：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">InputComponent</span>) </span>&#123;</span><br><span class=\"line\">  InputComponent.prototype.componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 我们返回的原始组件实际上已经</span></span><br><span class=\"line\">  <span class=\"comment\">// 被修改了。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> InputComponent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EnhancedComponent会记录下所有的props属性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure></p>\n<p>问题：</p>\n<ol>\n<li>input组件不能够脱离增强型组件（enhanced component）被重用。（复用性底）</li>\n<li>如果你用另一个高阶组件来转变 EnhancedComponent ，同样的也去改变 componentWillReceiveProps 函数时，第一个高阶组件（即EnhancedComponent）转换的功能就会被覆盖。</li>\n</ol>\n<p>正确的写法：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logProps</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props: '</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props: '</span>, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 用容器组件组合包裹组件且不修改包裹组件，这才是正确的打开方式。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>复用性高，可以重复使用。</li>\n</ol>\n<p>综上总结：高阶组件就是容器组件的一部分，也可以认为高阶组件就是参数化的容器组件定义</p>\n<h2 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h2><h3 id=\"1-不传不相关的-props\"><a href=\"#1-不传不相关的-props\" class=\"headerlink\" title=\"1. 不传不相关的 props\"></a>1. 不传不相关的 props</h3><p>高阶组件应该传递与它要实现的功能点无关的props属性。</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 过滤掉与高阶函数功能相关的props属性，</span></span><br><span class=\"line\">  <span class=\"comment\">// 不再传递</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向包裹组件注入props属性，一般都是高阶组件的state状态</span></span><br><span class=\"line\">  <span class=\"comment\">// 或实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向包裹组件传递props属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;WrappedComponent</span><br><span class=\"line\">      injectedProp=&#123;injectedProp&#125;</span><br><span class=\"line\">      &#123;...passThroughProps&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原因：确保高阶组件最大程度的 灵活性 和 可重用性。</p>\n<h3 id=\"2-最大化使用组合\"><a href=\"#2-最大化使用组合\" class=\"headerlink\" title=\"2. 最大化使用组合\"></a>2. 最大化使用组合</h3><p>并不是所有的高阶组件看起来都是一样的。有时，它们仅仅接收一个参数，即包裹组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> NavbarWithRouter = withRouter(Navbar);</span><br></pre></td></tr></table></figure>\n<p>一般而言，高阶组件会接收额外的参数。例如 Relay 的一个例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommentWithRelay = Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure>\n<p>我们常用的 <code>redux</code> 的 <code>connect</code> 就是一个很典型的例子<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// React Redux's `connect`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ConnectedComment = connect(commentSelector, commentActions)(Comment);</span><br></pre></td></tr></table></figure></p>\n<p>拨开之后：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// connect是一个返回函数的函数（译者注：就是个高阶函数）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhance = connect(commentListSelector, commentListActions);</span><br><span class=\"line\"><span class=\"comment\">// 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store</span></span><br><span class=\"line\"><span class=\"comment\">// 关联起来的新组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure></p>\n<p>拨开之后是不是瞬间清晰了很多，说到底  <code>connect</code> 就是一个返回了高阶组件的函数</p>\n<p>这种形式有点让人迷惑，有点多余，但是它有一个有用的属性。那就是，类似 connect 函数返回的单参数的高阶组件有着这样的签名格式， <code>Component =&gt; Component</code> .输入和输出类型相同的函数是很容易组合在一起。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不要这样做……</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ……你可以使用一个功能组合工具</span></span><br><span class=\"line\"><span class=\"comment\">// compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhance = compose(</span><br><span class=\"line\">  <span class=\"comment\">// 这些都是单参数的高阶组件</span></span><br><span class=\"line\">  withRouter,</span><br><span class=\"line\">  connect(commentSelector)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>\n<p>同样做法发还有 <a href=\"https://lodash.com/docs/#flowRight\" target=\"_blank\" rel=\"noopener\"><code>lodash</code></a> 和 <a href=\"https://ramdajs.com/docs/#compose\" target=\"_blank\" rel=\"noopener\"><code>Ramda</code></a> 他们均有 <code>compose</code> 这种组合函数。</p>\n<h3 id=\"3-包装显示名字以便于调试\"><a href=\"#3-包装显示名字以便于调试\" class=\"headerlink\" title=\"3. 包装显示名字以便于调试\"></a>3. 包装显示名字以便于调试</h3><p>我们一般给高阶组件起名字都是 <code>with*</code>，例如：高阶组件名字<code>withSubscription</code> ，包裹组件名字 <code>CommentList</code>，使用时为 <code>WithSubscription(CommentList)</code></p>\n<p>原因：区分高阶组件和普通组件</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"1-不要再render函数中使用高阶组件\"><a href=\"#1-不要再render函数中使用高阶组件\" class=\"headerlink\" title=\"1. 不要再render函数中使用高阶组件\"></a>1. 不要再render函数中使用高阶组件</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 每一次render函数调用都会创建一个新的EnhancedComponent实例</span></span><br><span class=\"line\">  <span class=\"comment\">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class=\"line\">  <span class=\"comment\">// 每一次都会使子对象树完全被卸载或移除</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;EnhancedComponent /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上使用的话问题：</p>\n<ol>\n<li>性能问题</li>\n<li>重新加载一个组件会引起原有组件的所有状态和子组件丢失。</li>\n</ol>\n<p>如果需要动态调用高阶组件，那么可以在组件的构造函数或生命周期函数中调用。</p>\n<h3 id=\"2-必须将静态方法做拷贝\"><a href=\"#2-必须将静态方法做拷贝\" class=\"headerlink\" title=\"2. 必须将静态方法做拷贝\"></a>2. 必须将静态方法做拷贝</h3><p>当使用高阶组件时，原始组件呗容器组件包裹之后就会失去原始组件原来的方法。解决这个问题就是需要我们把静态方法全部拷贝。</p>\n<p>方法：</p>\n<ol>\n<li>使用 <a href=\"https://github.com/mridgway/hoist-non-react-statics\" target=\"_blank\" rel=\"noopener\"><code>hoist-non-react-statics</code></a></li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hoistNonReactStatic <span class=\"keyword\">from</span> <span class=\"string\">'hoist-non-react-statics'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>分别导出组件自身的静态方法</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 替代……</span></span><br><span class=\"line\">MyComponent.someFunction = someFunction;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ……分别导出……</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; someFunction &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ……在要使用的组件中导入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> MyComponent, &#123; someFunction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./MyComponent.js'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-Refs属性不能传递\"><a href=\"#3-Refs属性不能传递\" class=\"headerlink\" title=\"3. Refs属性不能传递\"></a>3. Refs属性不能传递</h3><p>高阶组件可以传递所有的props属性给包裹的组件，但是不能传递refs引用。<br>refs是一个伪属性，React对它进行了特殊处理。如果你向一个由高阶组件创建的组件的元素添加ref应用，那么ref指向的是最外层容器组件实例的，而不是包裹组件。</p>\n"},{"title":"typesSript（二）类","date":"2018-09-25T09:09:43.000Z","_content":"\n\n### 类的继承\n\n类的继承是使用 extends：\n```js\nclass Animal {\n    name: string;\n    constructor(theName: string) { this.name = theName; }\n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 5) {\n        console.log(\"Slithering...\");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 45) {\n        console.log(\"Galloping...\");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n\nsam.move();\ntom.move(34);\n```\n执行结果：\n```js\nSlithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\n```\n\n以上的例子是 Snake 和 Horse 继承自 Animal，而 Snake 和 Horse 就称为 <b>派生类 / 子类</b>，而 Animal 就被称为 <b>基类 / 超类</b>。\n\n如果派生类内包含了构造函数，在构造函数中必须访问 `super()`，它会执行基类的构造函数。尤其是在调用 `this` 之前，使用`super` 进行重写了基类的 move 方法。\n\n\n\n### Public, private, and protected modifiers\n\n#### public 默认值\n```\nclass Animal {\n    public name: string;\n    public constructor(theName: string) { this.name = theName; }\n    public move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n#### private\n\n当成员被标记成 private时，它就不能在声明它的类的外部访问。\n\n```js\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nnew Animal(\"Cat\").name; // 错误: 'name' 是私有的.\n```\n\n#### protected\n\n1. protected 和 private 很相似，唯一不同的地方是 protected 成员在派生类中是可以被访问的。\n\n```js\nclass Person {\n    protected name: string;\n    constructor(name: string) { this.name = name; }\n}\n\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name)\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n    <!--在这里访问 this.name 是继承自基类的 name -->\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee(\"Howard\", \"Sales\");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name); // 错误，因为 name 是 Person  中的 name 被标识了 protected\n```\n\n2. 构造函数也可以被标记为 protected，这样的话这个类只能被继承，不能被包含他的类外面实例化。\n\n对于 private 和 protected 申明的成员，如果要比较两个类型是否一样时就会出现不同。\n例如：\n\n```js\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nclass Rhino extends Animal {\n    constructor() { super(\"Rhino\"); }\n}\n\nclass Employee {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nlet animal = new Animal(\"Goat\");\nlet rhino = new Rhino();\nlet employee = new Employee(\"Bob\");\n\nanimal = rhino;\nanimal = employee; // 错误: Animal 与 Employee 不兼容.\n```\n因为 Employee 和 Animal 的 name 不是同一个 name\n\n### readonly 修饰符\n\n只读属性必须在声明时或构造函数里被初始化。\n\n```js\nclass Octopus {\n    readonly name: string;\n    readonly numberOfLegs: number = 8;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\nlet dad = new Octopus(\"Man with the 8 strong legs\");\ndad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的.\n```\n\n#### 参数属性\n\n```js\n/**\n原来 name 的声明方式\n*/\nclass Animal {\n    private name：string;\n    constructor(theName) { \n        this.name = thieName;\n    }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\n/**\n使用 参数属性声明变量\n*/\nclass Animal {\n    constructor(private name: string) { }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n\n在构造函数里使用 ` private name: string ` 参数来创建和初始化 ` name ` 成员，把声明和赋值合并至一处\n\n### 存取器\n\n使用 `get` 和 `set` 设置成为一个存取器\n\n```js\n/*\n    没有存取器\n*/\nclass Employee {\n    fullName: string;\n}\n\nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\nif (employee.fullName) {\n    console.log(employee.fullName);\n}\n\n/*\n    通过 set 和 get 设置 存取器\n*/\nlet passcode = \"secret passcode\";\n\nclass Employee {\n    private _fullName: string;\n\n    get fullName(): string {\n        return this._fullName;\n    }\n\n    set fullName(newName: string) {\n        if (passcode && passcode == \"secret passcode\") {\n            this._fullName = newName;\n        }\n        else {\n            console.log(\"Error: Unauthorized update of employee!\");\n        }\n    }\n}\n\nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\nif (employee.fullName) {\n    alert(employee.fullName);\n}\n\n```\n1. 存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。\n2. 只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n### 静态属性\n\n通过 static 关键字来设置，上面说的时只有在实例化之后才会初始化的值，静态属性是在类本身里面，它也可以通过 `this.` 来进行方法问。\n\n例如：\n```js\nclass Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n```\n\n### 抽象类\n\n使用 abstract 声明。\n```js\n/* \n抽象类内部定义的抽象方法\n*/\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n\n```js\nabstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log('Department name: ' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()\n    }\n\n    printMeeting(): void {\n        console.log('The Accounting Department meets each Monday at 10am.');\n    }\n\n    generateReports(): void {\n        console.log('Generating accounting reports...');\n    }\n}\n\nlet department: Department; // 允许创建一个对抽象类型的引用\ndepartment = new Department(); // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // 错误: 方法在声明的抽象类中不存在\n```\n注意点：\n\n1. 允许创建一个抽象对象类型\n2. 抽象类不允许实例化\n3. 允许对抽象类的子类进行实例化和赋值\n4. 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。定义方法签名但不包含方法体。\n5. 抽象方法必须包含 abstract关键字并且可以包含访问修饰符。\n\n\n### 高级技巧\n\n1. 构造函数\n\n当你在 ts 中声明了一个类时，就同时声明了很多东西，\n\n例如：\n- 类的实例的 <b>类型</b>\n- 构造函数，这个函数在这个类被 new 的时候调用\n```js\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return \"Hello, \" + this.greeting;\n    }\n}\n\nlet greeter: Greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet());\n\n/* 编译成 js 之后 */\nlet Greeter = (function () {\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    Greeter.prototype.greet = function () {\n        return \"Hello, \" + this.greeting;\n    };\n    return Greeter;\n})();\n\nlet greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet());\n```\n\n2. 把类当做接口使用\n```js\nclass Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n```\n","source":"_posts/typeScript（二）类.md","raw":"---\ntitle: typesSript（二）类\ndate: 2018-09-25 17:09:43\ntags: \"ts\"\n---\n\n\n### 类的继承\n\n类的继承是使用 extends：\n```js\nclass Animal {\n    name: string;\n    constructor(theName: string) { this.name = theName; }\n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 5) {\n        console.log(\"Slithering...\");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 45) {\n        console.log(\"Galloping...\");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n\nsam.move();\ntom.move(34);\n```\n执行结果：\n```js\nSlithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\n```\n\n以上的例子是 Snake 和 Horse 继承自 Animal，而 Snake 和 Horse 就称为 <b>派生类 / 子类</b>，而 Animal 就被称为 <b>基类 / 超类</b>。\n\n如果派生类内包含了构造函数，在构造函数中必须访问 `super()`，它会执行基类的构造函数。尤其是在调用 `this` 之前，使用`super` 进行重写了基类的 move 方法。\n\n\n\n### Public, private, and protected modifiers\n\n#### public 默认值\n```\nclass Animal {\n    public name: string;\n    public constructor(theName: string) { this.name = theName; }\n    public move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n#### private\n\n当成员被标记成 private时，它就不能在声明它的类的外部访问。\n\n```js\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nnew Animal(\"Cat\").name; // 错误: 'name' 是私有的.\n```\n\n#### protected\n\n1. protected 和 private 很相似，唯一不同的地方是 protected 成员在派生类中是可以被访问的。\n\n```js\nclass Person {\n    protected name: string;\n    constructor(name: string) { this.name = name; }\n}\n\nclass Employee extends Person {\n    private department: string;\n\n    constructor(name: string, department: string) {\n        super(name)\n        this.department = department;\n    }\n\n    public getElevatorPitch() {\n    <!--在这里访问 this.name 是继承自基类的 name -->\n        return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n    }\n}\n\nlet howard = new Employee(\"Howard\", \"Sales\");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name); // 错误，因为 name 是 Person  中的 name 被标识了 protected\n```\n\n2. 构造函数也可以被标记为 protected，这样的话这个类只能被继承，不能被包含他的类外面实例化。\n\n对于 private 和 protected 申明的成员，如果要比较两个类型是否一样时就会出现不同。\n例如：\n\n```js\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nclass Rhino extends Animal {\n    constructor() { super(\"Rhino\"); }\n}\n\nclass Employee {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nlet animal = new Animal(\"Goat\");\nlet rhino = new Rhino();\nlet employee = new Employee(\"Bob\");\n\nanimal = rhino;\nanimal = employee; // 错误: Animal 与 Employee 不兼容.\n```\n因为 Employee 和 Animal 的 name 不是同一个 name\n\n### readonly 修饰符\n\n只读属性必须在声明时或构造函数里被初始化。\n\n```js\nclass Octopus {\n    readonly name: string;\n    readonly numberOfLegs: number = 8;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\nlet dad = new Octopus(\"Man with the 8 strong legs\");\ndad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的.\n```\n\n#### 参数属性\n\n```js\n/**\n原来 name 的声明方式\n*/\nclass Animal {\n    private name：string;\n    constructor(theName) { \n        this.name = thieName;\n    }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\n/**\n使用 参数属性声明变量\n*/\nclass Animal {\n    constructor(private name: string) { }\n    move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n```\n\n在构造函数里使用 ` private name: string ` 参数来创建和初始化 ` name ` 成员，把声明和赋值合并至一处\n\n### 存取器\n\n使用 `get` 和 `set` 设置成为一个存取器\n\n```js\n/*\n    没有存取器\n*/\nclass Employee {\n    fullName: string;\n}\n\nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\nif (employee.fullName) {\n    console.log(employee.fullName);\n}\n\n/*\n    通过 set 和 get 设置 存取器\n*/\nlet passcode = \"secret passcode\";\n\nclass Employee {\n    private _fullName: string;\n\n    get fullName(): string {\n        return this._fullName;\n    }\n\n    set fullName(newName: string) {\n        if (passcode && passcode == \"secret passcode\") {\n            this._fullName = newName;\n        }\n        else {\n            console.log(\"Error: Unauthorized update of employee!\");\n        }\n    }\n}\n\nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\nif (employee.fullName) {\n    alert(employee.fullName);\n}\n\n```\n1. 存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。\n2. 只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n### 静态属性\n\n通过 static 关键字来设置，上面说的时只有在实例化之后才会初始化的值，静态属性是在类本身里面，它也可以通过 `this.` 来进行方法问。\n\n例如：\n```js\nclass Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n```\n\n### 抽象类\n\n使用 abstract 声明。\n```js\n/* \n抽象类内部定义的抽象方法\n*/\nabstract class Animal {\n    abstract makeSound(): void;\n    move(): void {\n        console.log('roaming the earch...');\n    }\n}\n```\n\n```js\nabstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log('Department name: ' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()\n    }\n\n    printMeeting(): void {\n        console.log('The Accounting Department meets each Monday at 10am.');\n    }\n\n    generateReports(): void {\n        console.log('Generating accounting reports...');\n    }\n}\n\nlet department: Department; // 允许创建一个对抽象类型的引用\ndepartment = new Department(); // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // 错误: 方法在声明的抽象类中不存在\n```\n注意点：\n\n1. 允许创建一个抽象对象类型\n2. 抽象类不允许实例化\n3. 允许对抽象类的子类进行实例化和赋值\n4. 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。定义方法签名但不包含方法体。\n5. 抽象方法必须包含 abstract关键字并且可以包含访问修饰符。\n\n\n### 高级技巧\n\n1. 构造函数\n\n当你在 ts 中声明了一个类时，就同时声明了很多东西，\n\n例如：\n- 类的实例的 <b>类型</b>\n- 构造函数，这个函数在这个类被 new 的时候调用\n```js\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return \"Hello, \" + this.greeting;\n    }\n}\n\nlet greeter: Greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet());\n\n/* 编译成 js 之后 */\nlet Greeter = (function () {\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    Greeter.prototype.greet = function () {\n        return \"Hello, \" + this.greeting;\n    };\n    return Greeter;\n})();\n\nlet greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet());\n```\n\n2. 把类当做接口使用\n```js\nclass Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n```\n","slug":"typeScript（二）类","published":1,"updated":"2018-09-25T10:18:16.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbb6000zfwvpkniylmbx","content":"<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>类的继承是使用 extends：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">    move(distanceInMeters: number = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snake</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string) &#123; <span class=\"keyword\">super</span>(name); &#125;</span><br><span class=\"line\">    move(distanceInMeters = <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Slithering...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Horse</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string) &#123; <span class=\"keyword\">super</span>(name); &#125;</span><br><span class=\"line\">    move(distanceInMeters = <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Galloping...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">\"Sammy the Python\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">\"Tommy the Palomino\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move();</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>);</span><br></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slithering...</span><br><span class=\"line\">Sammy the Python moved <span class=\"number\">5</span>m.</span><br><span class=\"line\">Galloping...</span><br><span class=\"line\">Tommy the Palomino moved <span class=\"number\">34</span>m.</span><br></pre></td></tr></table></figure></p>\n<p>以上的例子是 Snake 和 Horse 继承自 Animal，而 Snake 和 Horse 就称为 <b>派生类 / 子类</b>，而 Animal 就被称为 <b>基类 / 超类</b>。</p>\n<p>如果派生类内包含了构造函数，在构造函数中必须访问 <code>super()</code>，它会执行基类的构造函数。尤其是在调用 <code>this</code> 之前，使用<code>super</code> 进行重写了基类的 move 方法。</p>\n<h3 id=\"Public-private-and-protected-modifiers\"><a href=\"#Public-private-and-protected-modifiers\" class=\"headerlink\" title=\"Public, private, and protected modifiers\"></a>Public, private, and protected modifiers</h3><h4 id=\"public-默认值\"><a href=\"#public-默认值\" class=\"headerlink\" title=\"public 默认值\"></a>public 默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    public name: string;</span><br><span class=\"line\">    public constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class=\"line\">    public move(distanceInMeters: number) &#123;</span><br><span class=\"line\">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><p>当成员被标记成 private时，它就不能在声明它的类的外部访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    private name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal(<span class=\"string\">\"Cat\"</span>).name; <span class=\"comment\">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h4><ol>\n<li>protected 和 private 很相似，唯一不同的地方是 protected 成员在派生类中是可以被访问的。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    protected name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string) &#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    private department: string;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string, department: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.department = department;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public getElevatorPitch() &#123;</span><br><span class=\"line\">    &lt;!--在这里访问 <span class=\"keyword\">this</span>.name 是继承自基类的 name --&gt;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> and I work in <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.department&#125;</span>.`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"Howard\"</span>, <span class=\"string\">\"Sales\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.name); <span class=\"comment\">// 错误，因为 name 是 Person  中的 name 被标识了 protected</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>构造函数也可以被标记为 protected，这样的话这个类只能被继承，不能被包含他的类外面实例化。</li>\n</ol>\n<p>对于 private 和 protected 申明的成员，如果要比较两个类型是否一样时就会出现不同。<br>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    private name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rhino</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123; <span class=\"keyword\">super</span>(<span class=\"string\">\"Rhino\"</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    private name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"Goat\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino();</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"Bob\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino;</span><br><span class=\"line\">animal = employee; <span class=\"comment\">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>\n<p>因为 Employee 和 Animal 的 name 不是同一个 name</p>\n<h3 id=\"readonly-修饰符\"><a href=\"#readonly-修饰符\" class=\"headerlink\" title=\"readonly 修饰符\"></a>readonly 修饰符</h3><p>只读属性必须在声明时或构造函数里被初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Octopus</span> </span>&#123;</span><br><span class=\"line\">    readonly name: string;</span><br><span class=\"line\">    readonly numberOfLegs: number = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (theName: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = theName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dad = <span class=\"keyword\">new</span> Octopus(<span class=\"string\">\"Man with the 8 strong legs\"</span>);</span><br><span class=\"line\">dad.name = <span class=\"string\">\"Man with the 3-piece suit\"</span>; <span class=\"comment\">// 错误! name 是只读的.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">原来 name 的声明方式</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    private name：string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = thieName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    move(distanceInMeters: number) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">使用 参数属性声明变量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(private name: string) &#123; &#125;</span><br><span class=\"line\">    move(distanceInMeters: number) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在构造函数里使用 <code>private name: string</code> 参数来创建和初始化 <code>name</code> 成员，把声明和赋值合并至一处</p>\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><p>使用 <code>get</code> 和 <code>set</code> 设置成为一个存取器</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    没有存取器</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    fullName: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">employee.fullName = <span class=\"string\">\"Bob Smith\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(employee.fullName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    通过 set 和 get 设置 存取器</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">\"secret passcode\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    private _fullName: string;</span><br><span class=\"line\"></span><br><span class=\"line\">    get fullName(): string &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._fullName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set fullName(newName: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode == <span class=\"string\">\"secret passcode\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._fullName = newName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Error: Unauthorized update of employee!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">employee.fullName = <span class=\"string\">\"Bob Smith\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">    alert(employee.fullName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。</li>\n<li>只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</li>\n</ol>\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>通过 static 关键字来设置，上面说的时只有在实例化之后才会初始化的值，静态属性是在类本身里面，它也可以通过 <code>this.</code> 来进行方法问。</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grid</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> origin = &#123;<span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    calculateDistanceFromOrigin(point: &#123;<span class=\"attr\">x</span>: number; y: number;&#125;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> xDist = (point.x - Grid.origin.x);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> yDist = (point.y - Grid.origin.y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class=\"keyword\">this</span>.scale;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (public scale: number) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">1.0</span>);  <span class=\"comment\">// 1x scale</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid2 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">5.0</span>);  <span class=\"comment\">// 5x scale</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span>&#125;));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span>&#125;));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>使用 abstract 声明。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">抽象类内部定义的抽象方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    abstract makeSound(): <span class=\"keyword\">void</span>;</span><br><span class=\"line\">    move(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'roaming the earch...'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(public name: string) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printName(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Department name: '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    abstract printMeeting(): <span class=\"keyword\">void</span>; <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingDepartment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">'Accounting and Auditing'</span>); <span class=\"comment\">// 在派生类的构造函数中必须调用 super()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printMeeting(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'The Accounting Department meets each Monday at 10am.'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    generateReports(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Generating accounting reports...'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department; <span class=\"comment\">// 允许创建一个对抽象类型的引用</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> Department(); <span class=\"comment\">// 错误: 不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment(); <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName();</span><br><span class=\"line\">department.printMeeting();</span><br><span class=\"line\">department.generateReports(); <span class=\"comment\">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n<p>注意点：</p>\n<ol>\n<li>允许创建一个抽象对象类型</li>\n<li>抽象类不允许实例化</li>\n<li>允许对抽象类的子类进行实例化和赋值</li>\n<li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。定义方法签名但不包含方法体。</li>\n<li>抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</li>\n</ol>\n<h3 id=\"高级技巧\"><a href=\"#高级技巧\" class=\"headerlink\" title=\"高级技巧\"></a>高级技巧</h3><ol>\n<li>构造函数</li>\n</ol>\n<p>当你在 ts 中声明了一个类时，就同时声明了很多东西，</p>\n<p>例如：</p>\n<ul>\n<li>类的实例的 <b>类型</b></li>\n<li>构造函数，这个函数在这个类被 new 的时候调用<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">    greeting: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(message: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    greet() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello, \"</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 编译成 js 之后 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Greeter = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeter</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Greeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello, \"</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Greeter;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>把类当做接口使用<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    x: number;</span><br><span class=\"line\">    y: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Point3d extends Point &#123;</span><br><span class=\"line\">    z: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">z</span>: <span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>类的继承是使用 extends：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">    move(distanceInMeters: number = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snake</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string) &#123; <span class=\"keyword\">super</span>(name); &#125;</span><br><span class=\"line\">    move(distanceInMeters = <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Slithering...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Horse</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string) &#123; <span class=\"keyword\">super</span>(name); &#125;</span><br><span class=\"line\">    move(distanceInMeters = <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Galloping...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">\"Sammy the Python\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">\"Tommy the Palomino\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move();</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>);</span><br></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slithering...</span><br><span class=\"line\">Sammy the Python moved <span class=\"number\">5</span>m.</span><br><span class=\"line\">Galloping...</span><br><span class=\"line\">Tommy the Palomino moved <span class=\"number\">34</span>m.</span><br></pre></td></tr></table></figure></p>\n<p>以上的例子是 Snake 和 Horse 继承自 Animal，而 Snake 和 Horse 就称为 <b>派生类 / 子类</b>，而 Animal 就被称为 <b>基类 / 超类</b>。</p>\n<p>如果派生类内包含了构造函数，在构造函数中必须访问 <code>super()</code>，它会执行基类的构造函数。尤其是在调用 <code>this</code> 之前，使用<code>super</code> 进行重写了基类的 move 方法。</p>\n<h3 id=\"Public-private-and-protected-modifiers\"><a href=\"#Public-private-and-protected-modifiers\" class=\"headerlink\" title=\"Public, private, and protected modifiers\"></a>Public, private, and protected modifiers</h3><h4 id=\"public-默认值\"><a href=\"#public-默认值\" class=\"headerlink\" title=\"public 默认值\"></a>public 默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    public name: string;</span><br><span class=\"line\">    public constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class=\"line\">    public move(distanceInMeters: number) &#123;</span><br><span class=\"line\">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><p>当成员被标记成 private时，它就不能在声明它的类的外部访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    private name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal(<span class=\"string\">\"Cat\"</span>).name; <span class=\"comment\">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h4><ol>\n<li>protected 和 private 很相似，唯一不同的地方是 protected 成员在派生类中是可以被访问的。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    protected name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string) &#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    private department: string;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: string, department: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.department = department;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public getElevatorPitch() &#123;</span><br><span class=\"line\">    &lt;!--在这里访问 <span class=\"keyword\">this</span>.name 是继承自基类的 name --&gt;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> and I work in <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.department&#125;</span>.`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"Howard\"</span>, <span class=\"string\">\"Sales\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.name); <span class=\"comment\">// 错误，因为 name 是 Person  中的 name 被标识了 protected</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>构造函数也可以被标记为 protected，这样的话这个类只能被继承，不能被包含他的类外面实例化。</li>\n</ol>\n<p>对于 private 和 protected 申明的成员，如果要比较两个类型是否一样时就会出现不同。<br>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    private name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rhino</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123; <span class=\"keyword\">super</span>(<span class=\"string\">\"Rhino\"</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    private name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName: string) &#123; <span class=\"keyword\">this</span>.name = theName; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"Goat\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino();</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"Bob\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino;</span><br><span class=\"line\">animal = employee; <span class=\"comment\">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>\n<p>因为 Employee 和 Animal 的 name 不是同一个 name</p>\n<h3 id=\"readonly-修饰符\"><a href=\"#readonly-修饰符\" class=\"headerlink\" title=\"readonly 修饰符\"></a>readonly 修饰符</h3><p>只读属性必须在声明时或构造函数里被初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Octopus</span> </span>&#123;</span><br><span class=\"line\">    readonly name: string;</span><br><span class=\"line\">    readonly numberOfLegs: number = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (theName: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = theName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dad = <span class=\"keyword\">new</span> Octopus(<span class=\"string\">\"Man with the 8 strong legs\"</span>);</span><br><span class=\"line\">dad.name = <span class=\"string\">\"Man with the 3-piece suit\"</span>; <span class=\"comment\">// 错误! name 是只读的.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">原来 name 的声明方式</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    private name：string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(theName) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = thieName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    move(distanceInMeters: number) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">使用 参数属性声明变量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(private name: string) &#123; &#125;</span><br><span class=\"line\">    move(distanceInMeters: number) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在构造函数里使用 <code>private name: string</code> 参数来创建和初始化 <code>name</code> 成员，把声明和赋值合并至一处</p>\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><p>使用 <code>get</code> 和 <code>set</code> 设置成为一个存取器</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    没有存取器</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    fullName: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">employee.fullName = <span class=\"string\">\"Bob Smith\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(employee.fullName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    通过 set 和 get 设置 存取器</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">\"secret passcode\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    private _fullName: string;</span><br><span class=\"line\"></span><br><span class=\"line\">    get fullName(): string &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._fullName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set fullName(newName: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode == <span class=\"string\">\"secret passcode\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._fullName = newName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Error: Unauthorized update of employee!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">employee.fullName = <span class=\"string\">\"Bob Smith\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">    alert(employee.fullName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。</li>\n<li>只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</li>\n</ol>\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>通过 static 关键字来设置，上面说的时只有在实例化之后才会初始化的值，静态属性是在类本身里面，它也可以通过 <code>this.</code> 来进行方法问。</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grid</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> origin = &#123;<span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    calculateDistanceFromOrigin(point: &#123;<span class=\"attr\">x</span>: number; y: number;&#125;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> xDist = (point.x - Grid.origin.x);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> yDist = (point.y - Grid.origin.y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class=\"keyword\">this</span>.scale;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (public scale: number) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">1.0</span>);  <span class=\"comment\">// 1x scale</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid2 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">5.0</span>);  <span class=\"comment\">// 5x scale</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span>&#125;));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span>&#125;));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>使用 abstract 声明。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">抽象类内部定义的抽象方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    abstract makeSound(): <span class=\"keyword\">void</span>;</span><br><span class=\"line\">    move(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'roaming the earch...'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(public name: string) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printName(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Department name: '</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    abstract printMeeting(): <span class=\"keyword\">void</span>; <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingDepartment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">'Accounting and Auditing'</span>); <span class=\"comment\">// 在派生类的构造函数中必须调用 super()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printMeeting(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'The Accounting Department meets each Monday at 10am.'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    generateReports(): <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Generating accounting reports...'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department; <span class=\"comment\">// 允许创建一个对抽象类型的引用</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> Department(); <span class=\"comment\">// 错误: 不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment(); <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName();</span><br><span class=\"line\">department.printMeeting();</span><br><span class=\"line\">department.generateReports(); <span class=\"comment\">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n<p>注意点：</p>\n<ol>\n<li>允许创建一个抽象对象类型</li>\n<li>抽象类不允许实例化</li>\n<li>允许对抽象类的子类进行实例化和赋值</li>\n<li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。定义方法签名但不包含方法体。</li>\n<li>抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</li>\n</ol>\n<h3 id=\"高级技巧\"><a href=\"#高级技巧\" class=\"headerlink\" title=\"高级技巧\"></a>高级技巧</h3><ol>\n<li>构造函数</li>\n</ol>\n<p>当你在 ts 中声明了一个类时，就同时声明了很多东西，</p>\n<p>例如：</p>\n<ul>\n<li>类的实例的 <b>类型</b></li>\n<li>构造函数，这个函数在这个类被 new 的时候调用<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">    greeting: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(message: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    greet() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello, \"</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 编译成 js 之后 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Greeter = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeter</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Greeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello, \"</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Greeter;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>把类当做接口使用<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    x: number;</span><br><span class=\"line\">    y: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Point3d extends Point &#123;</span><br><span class=\"line\">    z: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">z</span>: <span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"typesSript（一）接口","date":"2018-09-25T07:09:43.000Z","_content":"\n#### interface：\n类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n1. 可选属性：？\n<br />\n例如：\n```js\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n```\n\n2. 只读属性\n\n例如：\n\n```js\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n只读中有：\n` ReadonlyArray<T> `类型，它与 ` Array<T> ` 相似，但是他会所以可变的方法都去掉了，以确保数组不能被修改，例如：array[0] = 1、array.push('test')、array.length = 10 等；\n\n需要注意的是：把 `ReadonlyArray` 赋给普通数组也不信，但是可以断言重写：\n例如：\n```js\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n<!--错误-->\na = ro; // error!\n<!--正确-->\na = ro as number[];\n```\n\n3. 定义额外的属性\n\n有时候需要传一些已经定义好的额外的属性，这些额外的属性又不确定\n有三种方法：\n- 第一：通过类型断言的方式;(as)\n```js\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    // ...\n}\n\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n\n```\n\n- 第二：添加字符串索引签名（最佳）\n\n```js\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n```\n\n意思是 `SquareConfig` 可以有任意数量属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。\n\n- 第三：赋值新变量\n\n```js\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。\n\n#### 继承类型\n\n一个类型可以继承多个类型，使用 extends\n\n```js\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n#### 混合类型\n\n一个对象可以同时做为函数和对象使用，并带有额外的属性。\n```js\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { };\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```","source":"_posts/typesSript（一）接口.md","raw":"---\ntitle: typesSript（一）接口\ndate: 2018-09-25 15:09:43\ntags: \"ts\"\n---\n\n#### interface：\n类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n1. 可选属性：？\n<br />\n例如：\n```js\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n```\n\n2. 只读属性\n\n例如：\n\n```js\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n只读中有：\n` ReadonlyArray<T> `类型，它与 ` Array<T> ` 相似，但是他会所以可变的方法都去掉了，以确保数组不能被修改，例如：array[0] = 1、array.push('test')、array.length = 10 等；\n\n需要注意的是：把 `ReadonlyArray` 赋给普通数组也不信，但是可以断言重写：\n例如：\n```js\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n<!--错误-->\na = ro; // error!\n<!--正确-->\na = ro as number[];\n```\n\n3. 定义额外的属性\n\n有时候需要传一些已经定义好的额外的属性，这些额外的属性又不确定\n有三种方法：\n- 第一：通过类型断言的方式;(as)\n```js\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    // ...\n}\n\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n\n```\n\n- 第二：添加字符串索引签名（最佳）\n\n```js\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n```\n\n意思是 `SquareConfig` 可以有任意数量属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。\n\n- 第三：赋值新变量\n\n```js\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。\n\n#### 继承类型\n\n一个类型可以继承多个类型，使用 extends\n\n```js\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n#### 混合类型\n\n一个对象可以同时做为函数和对象使用，并带有额外的属性。\n```js\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { };\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```","slug":"typesSript（一）接口","published":1,"updated":"2018-09-25T09:18:36.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbb80012fwvpmtjehaim","content":"<h4 id=\"interface：\"><a href=\"#interface：\" class=\"headerlink\" title=\"interface：\"></a>interface：</h4><p>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<ol>\n<li><p>可选属性：？<br><br><br>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface SquareConfig &#123;</span><br><span class=\"line\">  color?: string;</span><br><span class=\"line\">  width?: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只读属性</p>\n</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只读中有：<br><code>ReadonlyArray&lt;T&gt;</code>类型，它与 <code>Array&lt;T&gt;</code> 相似，但是他会所以可变的方法都去掉了，以确保数组不能被修改，例如：array[0] = 1、array.push(‘test’)、array.length = 10 等；</p>\n<p>需要注意的是：把 <code>ReadonlyArray</code> 赋给普通数组也不信，但是可以断言重写：<br>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: number[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class=\"line\">&lt;!--错误--&gt;</span><br><span class=\"line\">a = ro; <span class=\"comment\">// error!</span></span><br><span class=\"line\">&lt;!--正确--&gt;</span><br><span class=\"line\">a = ro <span class=\"keyword\">as</span> number[];</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>定义额外的属性</li>\n</ol>\n<p>有时候需要传一些已经定义好的额外的属性，这些额外的属性又不确定<br>有三种方法：</p>\n<ul>\n<li><p>第一：通过类型断言的方式;(as)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface SquareConfig &#123;</span><br><span class=\"line\">    color?: string;</span><br><span class=\"line\">    width?: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: string; area: number &#125; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">opacity</span>: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二：添加字符串索引签名（最佳）</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface SquareConfig &#123;</span><br><span class=\"line\">    color?: string;</span><br><span class=\"line\">    width?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>意思是 <code>SquareConfig</code> 可以有任意数量属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>\n<ul>\n<li>第三：赋值新变量</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; <span class=\"attr\">colour</span>: <span class=\"string\">\"red\"</span>, <span class=\"attr\">width</span>: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>\n<p>将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>\n<h4 id=\"继承类型\"><a href=\"#继承类型\" class=\"headerlink\" title=\"继承类型\"></a>继承类型</h4><p>一个类型可以继承多个类型，使用 extends</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Shape &#123;</span><br><span class=\"line\">    color: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface PenStroke &#123;</span><br><span class=\"line\">    penWidth: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Square extends Shape, PenStroke &#123;</span><br><span class=\"line\">    sideLength: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = \"blue\";</span><br><span class=\"line\">square.sideLength = 10;</span><br><span class=\"line\">square.penWidth = 5.0;</span><br></pre></td></tr></table></figure>\n<h4 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h4><p>一个对象可以同时做为函数和对象使用，并带有额外的属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Counter &#123;</span><br><span class=\"line\">    (start: number): string;</span><br><span class=\"line\">    interval: number;</span><br><span class=\"line\">    reset(): <span class=\"keyword\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class=\"line\">    counter.interval = 123;</span><br><span class=\"line\">    counter.reset = function () &#123; &#125;;</span><br><span class=\"line\">    return counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let c = getCounter();</span><br><span class=\"line\">c(10);</span><br><span class=\"line\">c.reset();</span><br><span class=\"line\">c.interval = 5.0;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"interface：\"><a href=\"#interface：\" class=\"headerlink\" title=\"interface：\"></a>interface：</h4><p>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<ol>\n<li><p>可选属性：？<br><br><br>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface SquareConfig &#123;</span><br><span class=\"line\">  color?: string;</span><br><span class=\"line\">  width?: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只读属性</p>\n</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只读中有：<br><code>ReadonlyArray&lt;T&gt;</code>类型，它与 <code>Array&lt;T&gt;</code> 相似，但是他会所以可变的方法都去掉了，以确保数组不能被修改，例如：array[0] = 1、array.push(‘test’)、array.length = 10 等；</p>\n<p>需要注意的是：把 <code>ReadonlyArray</code> 赋给普通数组也不信，但是可以断言重写：<br>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: number[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class=\"line\">&lt;!--错误--&gt;</span><br><span class=\"line\">a = ro; <span class=\"comment\">// error!</span></span><br><span class=\"line\">&lt;!--正确--&gt;</span><br><span class=\"line\">a = ro <span class=\"keyword\">as</span> number[];</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>定义额外的属性</li>\n</ol>\n<p>有时候需要传一些已经定义好的额外的属性，这些额外的属性又不确定<br>有三种方法：</p>\n<ul>\n<li><p>第一：通过类型断言的方式;(as)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface SquareConfig &#123;</span><br><span class=\"line\">    color?: string;</span><br><span class=\"line\">    width?: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: string; area: number &#125; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">opacity</span>: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二：添加字符串索引签名（最佳）</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface SquareConfig &#123;</span><br><span class=\"line\">    color?: string;</span><br><span class=\"line\">    width?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>意思是 <code>SquareConfig</code> 可以有任意数量属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>\n<ul>\n<li>第三：赋值新变量</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; <span class=\"attr\">colour</span>: <span class=\"string\">\"red\"</span>, <span class=\"attr\">width</span>: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>\n<p>将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>\n<h4 id=\"继承类型\"><a href=\"#继承类型\" class=\"headerlink\" title=\"继承类型\"></a>继承类型</h4><p>一个类型可以继承多个类型，使用 extends</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Shape &#123;</span><br><span class=\"line\">    color: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface PenStroke &#123;</span><br><span class=\"line\">    penWidth: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Square extends Shape, PenStroke &#123;</span><br><span class=\"line\">    sideLength: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = \"blue\";</span><br><span class=\"line\">square.sideLength = 10;</span><br><span class=\"line\">square.penWidth = 5.0;</span><br></pre></td></tr></table></figure>\n<h4 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h4><p>一个对象可以同时做为函数和对象使用，并带有额外的属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Counter &#123;</span><br><span class=\"line\">    (start: number): string;</span><br><span class=\"line\">    interval: number;</span><br><span class=\"line\">    reset(): <span class=\"keyword\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class=\"line\">    counter.interval = 123;</span><br><span class=\"line\">    counter.reset = function () &#123; &#125;;</span><br><span class=\"line\">    return counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let c = getCounter();</span><br><span class=\"line\">c(10);</span><br><span class=\"line\">c.reset();</span><br><span class=\"line\">c.interval = 5.0;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"webpack 学习（一）","date":"2018-09-15T03:12:04.000Z","_content":"\n## webpack 是做什么的\n\n1. 围绕 webpack 的工具体系能够帮助我们系统化的解决前端资源问题\n2. 涵盖项目开发（单页应用或多页应用）、组件开发、SDK 开发等不同需求\n3. 配置从简到繁，需要结合项目需求和工具配置构建出符合项目的工作流。不仅仅是工具，更需要结合工程化的思想。\n\n官网地址: [中文地址](https://webpack.docschina.org/)   [英文地址](https://webpack.js.org/)\n\n> 主要需要注意的是所看 webpack 的版本，因为每个版本有很多不一样的地方\n\n## 基本原理\n\n#### 1. 初始化\n\n自动构建，读取与合并参数，加载 plugin，实例化 complier plugin 机制，在这个环节可以通过配置 plugin 对 webpack 进行自定义功能扩展\n（简言之：使用 plugin 加载各种插件）\n\n#### 2. 编译\n\n从 entry 出发，针对每一个 module 调用 loader 翻译文件内容，并找到 module 的依赖进行编译处理。\n（简言之：使用 loader 配置加载编译项目内容）\n\n#### 3. 输出\n\n将编译后的 module 组合成 chunk , 将 chunk 转换成文件，输出到文件系统。\n（简言之：将编译后的文件输出）\n\n注释：chunk 中文意思为 块\n\n## 核心概念\n\n配置 webpack 首先需要了解主要有哪些核心的配置：\n\n```jsx\nconst config = {\n    mode: \"\",           // string  构建模式, eg: production(default)、development、none\n    context: \"\",        // 上下文\n    entry: \"\",          // 入口，可以是字符串、数组、对象、函数\n    devtool: \"\",        // 开发工具\n    output: { },        // 输出配置\n    module: { },        // module 配置，处理不同资源\n    plugins: [ ],       // plugin 配置\n    optimization: { },  // 资源优化配置项\n    devServer: { }      // webpack-dev-server 服务配置\n}\n```\n\n## 区分构建环境\n\n#### 分离多套环境\n\n单独配置，可以解决很多问题\n\n1. 分离坏境：\n    dev（开发环境）、 prod（线上环境）、 staging（预发布环境）、 test（测试环境）\n2. 多环境配置文件放在 build\n3. 抽取 base 公共配置\n4. webpack-merge 合并配置\n5. 全局环境参数通过 env.mode 传入\n\n#### 不同环境不同配置\n\n- 区分环境不同的 mode 构建模式\n- 区分环境不同的 output.filename\n- 定义全局环境变量：webpack/lib/DefinePlugin  实现逻辑层也能按环境区分\n- 区分环境配置不同的 CDN && publicpath\n\n![](/images/webpack/env1.png)![](/images/webpack/env2.png)![](/images/webpack/env3.png)\n\n## loader\n\n#### 使用 loader 配置更多资源：\n1. url-loader 和 file-loader   ：前者内置后者，实现了图片的 base64 压缩以及资源大小限制、减少 http 请求\n2. postcss-loader 使用 postcss 生态，需要在预处理器前配置实用\n3. babel-loader  享受了最新的语法特性带来的技术红利\n\n#### 常用的 loader 总结：\n\n##### 文件 \n- raw-loader 加载文件原始内容（utf-8）\n- val-loader 将代码作为模块执行，并将 exports 转为 JS 代码\n- url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL\n- file-loader 将文件发送到输出文件夹，并返回（相对）URL\n\n##### JSON \n- json-loader 加载 JSON 文件（默认包含）\n- json5-loader 加载和转译 JSON 5 文件\n- cson-loader 加载和转译 CSON 文件\n\n##### 转换编译(Transpiling) \n- script-loader 在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析\n- babel-loader 加载 ES2015+ 代码，然后使用 Babel 转译为 ES5\n- buble-loader 使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5\n- traceur-loader 加载 ES2015+ 代码，然后使用 Traceur 转译为 ES5\n- ts-loader 或 awesome-typescript-loader 像 JavaScript 一样加载 TypeScript 2.0+\n- coffee-loader 像 JavaScript 一样加载 CoffeeScript\n- fengari-loader 使用 fengari 加载 Lua 代码\n\n##### 模板(Templating) \n- html-loader 导出 HTML 为字符串，需要引用静态资源\n- pug-loader 加载 Pug 模板并返回一个函数\n- jade-loader 加载 Jade 模板并返回一个函数\n- markdown-loader 将 Markdown 转译为 HTML\n- react-markdown-loader 使用 markdown-parse parser(解析器) 将 Markdown 编译为 React 组件\n- posthtml-loader 使用 PostHTML 加载并转换 HTML 文件\n- handlebars-loader 将 Handlebars 转移为 HTML\n- markup-inline-loader 将内联的 SVG/MathML 文件转换为 HTML。在应用于图标字体，或将 CSS 动画应用于 SVG 时非常有用。\n- twig-loader 编译 Twig 模板，然后返回一个函数\n\n##### 样式 \n- style-loader 将模块的导出作为样式添加到 DOM 中\n- css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码\n- less-loader 加载和转译 LESS 文件\n- sass-loader 加载和转译 SASS/SCSS 文件\n- postcss-loader 使用 PostCSS 加载和转译 CSS/SSS 文件\n- stylus-loader 加载和转译 Stylus 文件\n\n#### 常用 loader 简单分类\n\n##### 1. Html/handlebars/Jade：\nhtml-loader、pug-loader、handlebars-loader\n\n##### 2. CSS/Stylus/SASS/LESS\ncss-loader、sass-loader、less-loader、stylus-loder\n\n##### 3. ESM/AMD/CMD/COMMONJS\nbabel-loader + presets / plugins\n\n##### 4. Images/IconFont/JSON\nurl-loader、json-loader\n\n\n## plugin\n\n#### 常用的 plugin\n\n1. copy-webpack-plugin  将不需要编译的静态资源复制到目标目录\n2. html-webpack-plugin   编译 html 模板\n3. clean-webpack-plugin   清空指定目标目录资源，例如 dist\n4. mini-css-extract-plugin  独立 css 资源，压缩。 extract-text-css-plugin  不兼容 4.x\n5. AggressiveSplittingPlugin\t将原来的 chunk 分成更小的 chunk\n6. BabelMinifyWebpackPlugin\t使用 babel-minify 进行压缩\n7. BannerPlugin\t在每个生成的 chunk 顶部添加 banner\n8. CommonsChunkPlugin\t提取 chunks 之间共享的通用模块\n9. CompressionWebpackPlugin\t预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务\n10. ContextReplacementPlugin\t重写 require 表达式的推断上下文\n11. CopyWebpackPlugin\t将单个文件或整个目录复制到构建目录\n12. DefinePlugin\t允许在编译时(compile time)配置的全局常量\n13. DllPlugin\t为了极大减少构建时间，进行分离打包\n14. EnvironmentPlugin\tDefinePlugin 中 process.env 键的简写方式。\n15. ExtractTextWebpackPlugin\t从 bundle 中提取文本（CSS）到单独的文件\n16. HotModuleReplacementPlugin\t启用模块热替换(Enable Hot Module Replacement - HMR)\n17. HtmlWebpackPlugin\t简单创建 HTML 文件，用于服务器访问\n18. I18nWebpackPlugin\t为 bundle 增加国际化支持\n19. IgnorePlugin\t从 bundle 中排除某些模块\n20. LimitChunkCountPlugin\t设置 chunk 的最小/最大限制，以微调和控制 chunk\n21. LoaderOptionsPlugin\t用于从 webpack 1 迁移到 webpack 2\n22. MinChunkSizePlugin\t确保 chunk 大小超过指定限制\n23. MiniCssExtractPlugin\t为每个引入 CSS 的 JS 文件创建一个 CSS 文件\n24. NoEmitOnErrorsPlugin\t在输出阶段时，遇到编译错误跳过\n25. NormalModuleReplacementPlugin\t替换与正则表达式匹配的资源\n26. NpmInstallWebpackPlugin\t在开发时自动安装缺少的依赖\n27. ProvidePlugin\t不必通过 import/require 使用模块\n28. SourceMapDevToolPlugin\t对 source map 进行更细粒度的控制\n29. EvalSourceMapDevToolPlugin\t对 eval source map 进行更细粒度的控制\n\n## 优化基本开发体验\n\n#### devtool 开发工具\n\n| #\t  | 模式| 解释 | 速度 |\t生产环境 |\n| --- | --- | --- | --- |\n| 1 | eval | 会将模块封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.\t | 最快 |\t不可以|\n| 2 | source-map | 生成一个 SourceMap 文件.\t | 很慢 |\t可以|\n| 3 | hidden-source-map | 和 source-map 一样，但不会在 bundle 末尾追加注释.\t | 很慢 |\t可以|\n| 4 | inline-source-map | 生成一个 DataUrl 形式的 SourceMap 文件.\t | 很慢 |\t不可以|\n| 5 | eval-source-map | 每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .\t | 很慢 |\t不可以|\n| 6 | cheap-source-map | 生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）\t | 一般快 |\t可以|\n| 7 | cheap-module-source-map | 生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。\t | 较快 |\t可以|\n| 8 | cheap-module-eval-source-map | 类似 cheap-eval-source-map，并且，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。\t | 较快 |\t不可以|\n\n#### proxy 代理\n\n结合 mock 平台实现 proxy 代理。[用友 mock 平台](https://mock.yonyoucloud.com/)\n\nProxy && Mock\n\n- Webpack-dev-server proxy 配置\n- Node server based Koa / Express\n- webpack-hot-moddleware\n- Http-proxy-middleware\n- Http-proxy(node-http-proxy)\n\n配置：\n```js\ndevServer: {\n            contentBase: path.resolve(__dirname, '../dist'),\n            hot: true,\n            proxy: {\n                \"/corp\": {\n                    target: \"https://mock.yonyoucloud.com/mock/548\",\n                    secure: false,\n                    changeOrigin: true\n                }\n            }\n        },\n\n// 代理服务器会在请求头中加入相应host header，然后目标服务器就可以根据这个 header 来区别要访问的站点\n```\n\n#### MHR 热更新\n\n##### 热更新执行过程：\n\n模块更新, 更新的消息冒泡到 entry\n\n1. 未捕获：webpack-dev-server 内置 live reload\n2. 捕获：HotModuleReplacementPlugin ——>  webpack de -server （通知更新） <——> （web sokcet 通信）浏览器\n\n##### 配置\n1. devServer设置hot: true\n2. New webpack.HotModuleReplacementPlugin() 插件设置\n3. 入口判断：\n```js\nif (module.hot) {\n   module.hot.accept()\n}\n```\n\n##### 多端同步更新（移动、桌面、web端）\n\n插件：\nbrowser-sync-webpack-plugin\n\n配置： \n```js\nconst BrowserSyncPlugin = require('browser-sync-webpack-plugin')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new BrowserSyncPlugin({\n      // browse to http://localhost:3000/ during development,\n      // ./public directory is being served\n      host: 'localhost',\n      port: 3000,\n      server: { baseDir: ['public'] }\n    })\n  ]\n}\n\n```\n\n一直期待已久的整体系统的学习 webpack， 终于有机会了，现在将自己学习的笔记记录下来。。。\n\n\n","source":"_posts/webpack-学习（一）.md","raw":"---\ntitle: webpack 学习（一）\ndate: 2018-09-15 11:12:04\ntags: webpack\n---\n\n## webpack 是做什么的\n\n1. 围绕 webpack 的工具体系能够帮助我们系统化的解决前端资源问题\n2. 涵盖项目开发（单页应用或多页应用）、组件开发、SDK 开发等不同需求\n3. 配置从简到繁，需要结合项目需求和工具配置构建出符合项目的工作流。不仅仅是工具，更需要结合工程化的思想。\n\n官网地址: [中文地址](https://webpack.docschina.org/)   [英文地址](https://webpack.js.org/)\n\n> 主要需要注意的是所看 webpack 的版本，因为每个版本有很多不一样的地方\n\n## 基本原理\n\n#### 1. 初始化\n\n自动构建，读取与合并参数，加载 plugin，实例化 complier plugin 机制，在这个环节可以通过配置 plugin 对 webpack 进行自定义功能扩展\n（简言之：使用 plugin 加载各种插件）\n\n#### 2. 编译\n\n从 entry 出发，针对每一个 module 调用 loader 翻译文件内容，并找到 module 的依赖进行编译处理。\n（简言之：使用 loader 配置加载编译项目内容）\n\n#### 3. 输出\n\n将编译后的 module 组合成 chunk , 将 chunk 转换成文件，输出到文件系统。\n（简言之：将编译后的文件输出）\n\n注释：chunk 中文意思为 块\n\n## 核心概念\n\n配置 webpack 首先需要了解主要有哪些核心的配置：\n\n```jsx\nconst config = {\n    mode: \"\",           // string  构建模式, eg: production(default)、development、none\n    context: \"\",        // 上下文\n    entry: \"\",          // 入口，可以是字符串、数组、对象、函数\n    devtool: \"\",        // 开发工具\n    output: { },        // 输出配置\n    module: { },        // module 配置，处理不同资源\n    plugins: [ ],       // plugin 配置\n    optimization: { },  // 资源优化配置项\n    devServer: { }      // webpack-dev-server 服务配置\n}\n```\n\n## 区分构建环境\n\n#### 分离多套环境\n\n单独配置，可以解决很多问题\n\n1. 分离坏境：\n    dev（开发环境）、 prod（线上环境）、 staging（预发布环境）、 test（测试环境）\n2. 多环境配置文件放在 build\n3. 抽取 base 公共配置\n4. webpack-merge 合并配置\n5. 全局环境参数通过 env.mode 传入\n\n#### 不同环境不同配置\n\n- 区分环境不同的 mode 构建模式\n- 区分环境不同的 output.filename\n- 定义全局环境变量：webpack/lib/DefinePlugin  实现逻辑层也能按环境区分\n- 区分环境配置不同的 CDN && publicpath\n\n![](/images/webpack/env1.png)![](/images/webpack/env2.png)![](/images/webpack/env3.png)\n\n## loader\n\n#### 使用 loader 配置更多资源：\n1. url-loader 和 file-loader   ：前者内置后者，实现了图片的 base64 压缩以及资源大小限制、减少 http 请求\n2. postcss-loader 使用 postcss 生态，需要在预处理器前配置实用\n3. babel-loader  享受了最新的语法特性带来的技术红利\n\n#### 常用的 loader 总结：\n\n##### 文件 \n- raw-loader 加载文件原始内容（utf-8）\n- val-loader 将代码作为模块执行，并将 exports 转为 JS 代码\n- url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL\n- file-loader 将文件发送到输出文件夹，并返回（相对）URL\n\n##### JSON \n- json-loader 加载 JSON 文件（默认包含）\n- json5-loader 加载和转译 JSON 5 文件\n- cson-loader 加载和转译 CSON 文件\n\n##### 转换编译(Transpiling) \n- script-loader 在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析\n- babel-loader 加载 ES2015+ 代码，然后使用 Babel 转译为 ES5\n- buble-loader 使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5\n- traceur-loader 加载 ES2015+ 代码，然后使用 Traceur 转译为 ES5\n- ts-loader 或 awesome-typescript-loader 像 JavaScript 一样加载 TypeScript 2.0+\n- coffee-loader 像 JavaScript 一样加载 CoffeeScript\n- fengari-loader 使用 fengari 加载 Lua 代码\n\n##### 模板(Templating) \n- html-loader 导出 HTML 为字符串，需要引用静态资源\n- pug-loader 加载 Pug 模板并返回一个函数\n- jade-loader 加载 Jade 模板并返回一个函数\n- markdown-loader 将 Markdown 转译为 HTML\n- react-markdown-loader 使用 markdown-parse parser(解析器) 将 Markdown 编译为 React 组件\n- posthtml-loader 使用 PostHTML 加载并转换 HTML 文件\n- handlebars-loader 将 Handlebars 转移为 HTML\n- markup-inline-loader 将内联的 SVG/MathML 文件转换为 HTML。在应用于图标字体，或将 CSS 动画应用于 SVG 时非常有用。\n- twig-loader 编译 Twig 模板，然后返回一个函数\n\n##### 样式 \n- style-loader 将模块的导出作为样式添加到 DOM 中\n- css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码\n- less-loader 加载和转译 LESS 文件\n- sass-loader 加载和转译 SASS/SCSS 文件\n- postcss-loader 使用 PostCSS 加载和转译 CSS/SSS 文件\n- stylus-loader 加载和转译 Stylus 文件\n\n#### 常用 loader 简单分类\n\n##### 1. Html/handlebars/Jade：\nhtml-loader、pug-loader、handlebars-loader\n\n##### 2. CSS/Stylus/SASS/LESS\ncss-loader、sass-loader、less-loader、stylus-loder\n\n##### 3. ESM/AMD/CMD/COMMONJS\nbabel-loader + presets / plugins\n\n##### 4. Images/IconFont/JSON\nurl-loader、json-loader\n\n\n## plugin\n\n#### 常用的 plugin\n\n1. copy-webpack-plugin  将不需要编译的静态资源复制到目标目录\n2. html-webpack-plugin   编译 html 模板\n3. clean-webpack-plugin   清空指定目标目录资源，例如 dist\n4. mini-css-extract-plugin  独立 css 资源，压缩。 extract-text-css-plugin  不兼容 4.x\n5. AggressiveSplittingPlugin\t将原来的 chunk 分成更小的 chunk\n6. BabelMinifyWebpackPlugin\t使用 babel-minify 进行压缩\n7. BannerPlugin\t在每个生成的 chunk 顶部添加 banner\n8. CommonsChunkPlugin\t提取 chunks 之间共享的通用模块\n9. CompressionWebpackPlugin\t预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务\n10. ContextReplacementPlugin\t重写 require 表达式的推断上下文\n11. CopyWebpackPlugin\t将单个文件或整个目录复制到构建目录\n12. DefinePlugin\t允许在编译时(compile time)配置的全局常量\n13. DllPlugin\t为了极大减少构建时间，进行分离打包\n14. EnvironmentPlugin\tDefinePlugin 中 process.env 键的简写方式。\n15. ExtractTextWebpackPlugin\t从 bundle 中提取文本（CSS）到单独的文件\n16. HotModuleReplacementPlugin\t启用模块热替换(Enable Hot Module Replacement - HMR)\n17. HtmlWebpackPlugin\t简单创建 HTML 文件，用于服务器访问\n18. I18nWebpackPlugin\t为 bundle 增加国际化支持\n19. IgnorePlugin\t从 bundle 中排除某些模块\n20. LimitChunkCountPlugin\t设置 chunk 的最小/最大限制，以微调和控制 chunk\n21. LoaderOptionsPlugin\t用于从 webpack 1 迁移到 webpack 2\n22. MinChunkSizePlugin\t确保 chunk 大小超过指定限制\n23. MiniCssExtractPlugin\t为每个引入 CSS 的 JS 文件创建一个 CSS 文件\n24. NoEmitOnErrorsPlugin\t在输出阶段时，遇到编译错误跳过\n25. NormalModuleReplacementPlugin\t替换与正则表达式匹配的资源\n26. NpmInstallWebpackPlugin\t在开发时自动安装缺少的依赖\n27. ProvidePlugin\t不必通过 import/require 使用模块\n28. SourceMapDevToolPlugin\t对 source map 进行更细粒度的控制\n29. EvalSourceMapDevToolPlugin\t对 eval source map 进行更细粒度的控制\n\n## 优化基本开发体验\n\n#### devtool 开发工具\n\n| #\t  | 模式| 解释 | 速度 |\t生产环境 |\n| --- | --- | --- | --- |\n| 1 | eval | 会将模块封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.\t | 最快 |\t不可以|\n| 2 | source-map | 生成一个 SourceMap 文件.\t | 很慢 |\t可以|\n| 3 | hidden-source-map | 和 source-map 一样，但不会在 bundle 末尾追加注释.\t | 很慢 |\t可以|\n| 4 | inline-source-map | 生成一个 DataUrl 形式的 SourceMap 文件.\t | 很慢 |\t不可以|\n| 5 | eval-source-map | 每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .\t | 很慢 |\t不可以|\n| 6 | cheap-source-map | 生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）\t | 一般快 |\t可以|\n| 7 | cheap-module-source-map | 生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。\t | 较快 |\t可以|\n| 8 | cheap-module-eval-source-map | 类似 cheap-eval-source-map，并且，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。\t | 较快 |\t不可以|\n\n#### proxy 代理\n\n结合 mock 平台实现 proxy 代理。[用友 mock 平台](https://mock.yonyoucloud.com/)\n\nProxy && Mock\n\n- Webpack-dev-server proxy 配置\n- Node server based Koa / Express\n- webpack-hot-moddleware\n- Http-proxy-middleware\n- Http-proxy(node-http-proxy)\n\n配置：\n```js\ndevServer: {\n            contentBase: path.resolve(__dirname, '../dist'),\n            hot: true,\n            proxy: {\n                \"/corp\": {\n                    target: \"https://mock.yonyoucloud.com/mock/548\",\n                    secure: false,\n                    changeOrigin: true\n                }\n            }\n        },\n\n// 代理服务器会在请求头中加入相应host header，然后目标服务器就可以根据这个 header 来区别要访问的站点\n```\n\n#### MHR 热更新\n\n##### 热更新执行过程：\n\n模块更新, 更新的消息冒泡到 entry\n\n1. 未捕获：webpack-dev-server 内置 live reload\n2. 捕获：HotModuleReplacementPlugin ——>  webpack de -server （通知更新） <——> （web sokcet 通信）浏览器\n\n##### 配置\n1. devServer设置hot: true\n2. New webpack.HotModuleReplacementPlugin() 插件设置\n3. 入口判断：\n```js\nif (module.hot) {\n   module.hot.accept()\n}\n```\n\n##### 多端同步更新（移动、桌面、web端）\n\n插件：\nbrowser-sync-webpack-plugin\n\n配置： \n```js\nconst BrowserSyncPlugin = require('browser-sync-webpack-plugin')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new BrowserSyncPlugin({\n      // browse to http://localhost:3000/ during development,\n      // ./public directory is being served\n      host: 'localhost',\n      port: 3000,\n      server: { baseDir: ['public'] }\n    })\n  ]\n}\n\n```\n\n一直期待已久的整体系统的学习 webpack， 终于有机会了，现在将自己学习的笔记记录下来。。。\n\n\n","slug":"webpack-学习（一）","published":1,"updated":"2018-09-15T06:59:29.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbb0014fwvpq28336iw","content":"<h2 id=\"webpack-是做什么的\"><a href=\"#webpack-是做什么的\" class=\"headerlink\" title=\"webpack 是做什么的\"></a>webpack 是做什么的</h2><ol>\n<li>围绕 webpack 的工具体系能够帮助我们系统化的解决前端资源问题</li>\n<li>涵盖项目开发（单页应用或多页应用）、组件开发、SDK 开发等不同需求</li>\n<li>配置从简到繁，需要结合项目需求和工具配置构建出符合项目的工作流。不仅仅是工具，更需要结合工程化的思想。</li>\n</ol>\n<p>官网地址: <a href=\"https://webpack.docschina.org/\" target=\"_blank\" rel=\"noopener\">中文地址</a>   <a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">英文地址</a></p>\n<blockquote>\n<p>主要需要注意的是所看 webpack 的版本，因为每个版本有很多不一样的地方</p>\n</blockquote>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><h4 id=\"1-初始化\"><a href=\"#1-初始化\" class=\"headerlink\" title=\"1. 初始化\"></a>1. 初始化</h4><p>自动构建，读取与合并参数，加载 plugin，实例化 complier plugin 机制，在这个环节可以通过配置 plugin 对 webpack 进行自定义功能扩展<br>（简言之：使用 plugin 加载各种插件）</p>\n<h4 id=\"2-编译\"><a href=\"#2-编译\" class=\"headerlink\" title=\"2. 编译\"></a>2. 编译</h4><p>从 entry 出发，针对每一个 module 调用 loader 翻译文件内容，并找到 module 的依赖进行编译处理。<br>（简言之：使用 loader 配置加载编译项目内容）</p>\n<h4 id=\"3-输出\"><a href=\"#3-输出\" class=\"headerlink\" title=\"3. 输出\"></a>3. 输出</h4><p>将编译后的 module 组合成 chunk , 将 chunk 转换成文件，输出到文件系统。<br>（简言之：将编译后的文件输出）</p>\n<p>注释：chunk 中文意思为 块</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p>配置 webpack 首先需要了解主要有哪些核心的配置：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">\"\"</span>,           <span class=\"comment\">// string  构建模式, eg: production(default)、development、none</span></span><br><span class=\"line\">    context: <span class=\"string\">\"\"</span>,        <span class=\"comment\">// 上下文</span></span><br><span class=\"line\">    entry: <span class=\"string\">\"\"</span>,          <span class=\"comment\">// 入口，可以是字符串、数组、对象、函数</span></span><br><span class=\"line\">    devtool: <span class=\"string\">\"\"</span>,        <span class=\"comment\">// 开发工具</span></span><br><span class=\"line\">    output: &#123; &#125;,        <span class=\"comment\">// 输出配置</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123; &#125;,        <span class=\"comment\">// module 配置，处理不同资源</span></span><br><span class=\"line\">    plugins: [ ],       <span class=\"comment\">// plugin 配置</span></span><br><span class=\"line\">    optimization: &#123; &#125;,  <span class=\"comment\">// 资源优化配置项</span></span><br><span class=\"line\">    devServer: &#123; &#125;      <span class=\"comment\">// webpack-dev-server 服务配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"区分构建环境\"><a href=\"#区分构建环境\" class=\"headerlink\" title=\"区分构建环境\"></a>区分构建环境</h2><h4 id=\"分离多套环境\"><a href=\"#分离多套环境\" class=\"headerlink\" title=\"分离多套环境\"></a>分离多套环境</h4><p>单独配置，可以解决很多问题</p>\n<ol>\n<li>分离坏境：<br> dev（开发环境）、 prod（线上环境）、 staging（预发布环境）、 test（测试环境）</li>\n<li>多环境配置文件放在 build</li>\n<li>抽取 base 公共配置</li>\n<li>webpack-merge 合并配置</li>\n<li>全局环境参数通过 env.mode 传入</li>\n</ol>\n<h4 id=\"不同环境不同配置\"><a href=\"#不同环境不同配置\" class=\"headerlink\" title=\"不同环境不同配置\"></a>不同环境不同配置</h4><ul>\n<li>区分环境不同的 mode 构建模式</li>\n<li>区分环境不同的 output.filename</li>\n<li>定义全局环境变量：webpack/lib/DefinePlugin  实现逻辑层也能按环境区分</li>\n<li>区分环境配置不同的 CDN &amp;&amp; publicpath</li>\n</ul>\n<p><img src=\"/images/webpack/env1.png\" alt=\"\"><img src=\"/images/webpack/env2.png\" alt=\"\"><img src=\"/images/webpack/env3.png\" alt=\"\"></p>\n<h2 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h2><h4 id=\"使用-loader-配置更多资源：\"><a href=\"#使用-loader-配置更多资源：\" class=\"headerlink\" title=\"使用 loader 配置更多资源：\"></a>使用 loader 配置更多资源：</h4><ol>\n<li>url-loader 和 file-loader   ：前者内置后者，实现了图片的 base64 压缩以及资源大小限制、减少 http 请求</li>\n<li>postcss-loader 使用 postcss 生态，需要在预处理器前配置实用</li>\n<li>babel-loader  享受了最新的语法特性带来的技术红利</li>\n</ol>\n<h4 id=\"常用的-loader-总结：\"><a href=\"#常用的-loader-总结：\" class=\"headerlink\" title=\"常用的 loader 总结：\"></a>常用的 loader 总结：</h4><h5 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h5><ul>\n<li>raw-loader 加载文件原始内容（utf-8）</li>\n<li>val-loader 将代码作为模块执行，并将 exports 转为 JS 代码</li>\n<li>url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL</li>\n<li>file-loader 将文件发送到输出文件夹，并返回（相对）URL</li>\n</ul>\n<h5 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h5><ul>\n<li>json-loader 加载 JSON 文件（默认包含）</li>\n<li>json5-loader 加载和转译 JSON 5 文件</li>\n<li>cson-loader 加载和转译 CSON 文件</li>\n</ul>\n<h5 id=\"转换编译-Transpiling\"><a href=\"#转换编译-Transpiling\" class=\"headerlink\" title=\"转换编译(Transpiling)\"></a>转换编译(Transpiling)</h5><ul>\n<li>script-loader 在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析</li>\n<li>babel-loader 加载 ES2015+ 代码，然后使用 Babel 转译为 ES5</li>\n<li>buble-loader 使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5</li>\n<li>traceur-loader 加载 ES2015+ 代码，然后使用 Traceur 转译为 ES5</li>\n<li>ts-loader 或 awesome-typescript-loader 像 JavaScript 一样加载 TypeScript 2.0+</li>\n<li>coffee-loader 像 JavaScript 一样加载 CoffeeScript</li>\n<li>fengari-loader 使用 fengari 加载 Lua 代码</li>\n</ul>\n<h5 id=\"模板-Templating\"><a href=\"#模板-Templating\" class=\"headerlink\" title=\"模板(Templating)\"></a>模板(Templating)</h5><ul>\n<li>html-loader 导出 HTML 为字符串，需要引用静态资源</li>\n<li>pug-loader 加载 Pug 模板并返回一个函数</li>\n<li>jade-loader 加载 Jade 模板并返回一个函数</li>\n<li>markdown-loader 将 Markdown 转译为 HTML</li>\n<li>react-markdown-loader 使用 markdown-parse parser(解析器) 将 Markdown 编译为 React 组件</li>\n<li>posthtml-loader 使用 PostHTML 加载并转换 HTML 文件</li>\n<li>handlebars-loader 将 Handlebars 转移为 HTML</li>\n<li>markup-inline-loader 将内联的 SVG/MathML 文件转换为 HTML。在应用于图标字体，或将 CSS 动画应用于 SVG 时非常有用。</li>\n<li>twig-loader 编译 Twig 模板，然后返回一个函数</li>\n</ul>\n<h5 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h5><ul>\n<li>style-loader 将模块的导出作为样式添加到 DOM 中</li>\n<li>css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</li>\n<li>less-loader 加载和转译 LESS 文件</li>\n<li>sass-loader 加载和转译 SASS/SCSS 文件</li>\n<li>postcss-loader 使用 PostCSS 加载和转译 CSS/SSS 文件</li>\n<li>stylus-loader 加载和转译 Stylus 文件</li>\n</ul>\n<h4 id=\"常用-loader-简单分类\"><a href=\"#常用-loader-简单分类\" class=\"headerlink\" title=\"常用 loader 简单分类\"></a>常用 loader 简单分类</h4><h5 id=\"1-Html-handlebars-Jade：\"><a href=\"#1-Html-handlebars-Jade：\" class=\"headerlink\" title=\"1. Html/handlebars/Jade：\"></a>1. Html/handlebars/Jade：</h5><p>html-loader、pug-loader、handlebars-loader</p>\n<h5 id=\"2-CSS-Stylus-SASS-LESS\"><a href=\"#2-CSS-Stylus-SASS-LESS\" class=\"headerlink\" title=\"2. CSS/Stylus/SASS/LESS\"></a>2. CSS/Stylus/SASS/LESS</h5><p>css-loader、sass-loader、less-loader、stylus-loder</p>\n<h5 id=\"3-ESM-AMD-CMD-COMMONJS\"><a href=\"#3-ESM-AMD-CMD-COMMONJS\" class=\"headerlink\" title=\"3. ESM/AMD/CMD/COMMONJS\"></a>3. ESM/AMD/CMD/COMMONJS</h5><p>babel-loader + presets / plugins</p>\n<h5 id=\"4-Images-IconFont-JSON\"><a href=\"#4-Images-IconFont-JSON\" class=\"headerlink\" title=\"4. Images/IconFont/JSON\"></a>4. Images/IconFont/JSON</h5><p>url-loader、json-loader</p>\n<h2 id=\"plugin\"><a href=\"#plugin\" class=\"headerlink\" title=\"plugin\"></a>plugin</h2><h4 id=\"常用的-plugin\"><a href=\"#常用的-plugin\" class=\"headerlink\" title=\"常用的 plugin\"></a>常用的 plugin</h4><ol>\n<li>copy-webpack-plugin  将不需要编译的静态资源复制到目标目录</li>\n<li>html-webpack-plugin   编译 html 模板</li>\n<li>clean-webpack-plugin   清空指定目标目录资源，例如 dist</li>\n<li>mini-css-extract-plugin  独立 css 资源，压缩。 extract-text-css-plugin  不兼容 4.x</li>\n<li>AggressiveSplittingPlugin    将原来的 chunk 分成更小的 chunk</li>\n<li>BabelMinifyWebpackPlugin    使用 babel-minify 进行压缩</li>\n<li>BannerPlugin    在每个生成的 chunk 顶部添加 banner</li>\n<li>CommonsChunkPlugin    提取 chunks 之间共享的通用模块</li>\n<li>CompressionWebpackPlugin    预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务</li>\n<li>ContextReplacementPlugin    重写 require 表达式的推断上下文</li>\n<li>CopyWebpackPlugin    将单个文件或整个目录复制到构建目录</li>\n<li>DefinePlugin    允许在编译时(compile time)配置的全局常量</li>\n<li>DllPlugin    为了极大减少构建时间，进行分离打包</li>\n<li>EnvironmentPlugin    DefinePlugin 中 process.env 键的简写方式。</li>\n<li>ExtractTextWebpackPlugin    从 bundle 中提取文本（CSS）到单独的文件</li>\n<li>HotModuleReplacementPlugin    启用模块热替换(Enable Hot Module Replacement - HMR)</li>\n<li>HtmlWebpackPlugin    简单创建 HTML 文件，用于服务器访问</li>\n<li>I18nWebpackPlugin    为 bundle 增加国际化支持</li>\n<li>IgnorePlugin    从 bundle 中排除某些模块</li>\n<li>LimitChunkCountPlugin    设置 chunk 的最小/最大限制，以微调和控制 chunk</li>\n<li>LoaderOptionsPlugin    用于从 webpack 1 迁移到 webpack 2</li>\n<li>MinChunkSizePlugin    确保 chunk 大小超过指定限制</li>\n<li>MiniCssExtractPlugin    为每个引入 CSS 的 JS 文件创建一个 CSS 文件</li>\n<li>NoEmitOnErrorsPlugin    在输出阶段时，遇到编译错误跳过</li>\n<li>NormalModuleReplacementPlugin    替换与正则表达式匹配的资源</li>\n<li>NpmInstallWebpackPlugin    在开发时自动安装缺少的依赖</li>\n<li>ProvidePlugin    不必通过 import/require 使用模块</li>\n<li>SourceMapDevToolPlugin    对 source map 进行更细粒度的控制</li>\n<li>EvalSourceMapDevToolPlugin    对 eval source map 进行更细粒度的控制</li>\n</ol>\n<h2 id=\"优化基本开发体验\"><a href=\"#优化基本开发体验\" class=\"headerlink\" title=\"优化基本开发体验\"></a>优化基本开发体验</h2><h4 id=\"devtool-开发工具\"><a href=\"#devtool-开发工具\" class=\"headerlink\" title=\"devtool 开发工具\"></a>devtool 开发工具</h4><table>\n<thead>\n<tr>\n<th>#</th>\n<th>模式</th>\n<th>解释</th>\n<th>速度</th>\n<th>生产环境</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>eval</td>\n<td>会将模块封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.</td>\n<td>最快</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>2</td>\n<td>source-map</td>\n<td>生成一个 SourceMap 文件.</td>\n<td>很慢</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>3</td>\n<td>hidden-source-map</td>\n<td>和 source-map 一样，但不会在 bundle 末尾追加注释.</td>\n<td>很慢</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>4</td>\n<td>inline-source-map</td>\n<td>生成一个 DataUrl 形式的 SourceMap 文件.</td>\n<td>很慢</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>5</td>\n<td>eval-source-map</td>\n<td>每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .</td>\n<td>很慢</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>6</td>\n<td>cheap-source-map</td>\n<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）</td>\n<td>一般快</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>7</td>\n<td>cheap-module-source-map</td>\n<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。</td>\n<td>较快</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>8</td>\n<td>cheap-module-eval-source-map</td>\n<td>类似 cheap-eval-source-map，并且，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。</td>\n<td>较快</td>\n<td>不可以</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"proxy-代理\"><a href=\"#proxy-代理\" class=\"headerlink\" title=\"proxy 代理\"></a>proxy 代理</h4><p>结合 mock 平台实现 proxy 代理。<a href=\"https://mock.yonyoucloud.com/\" target=\"_blank\" rel=\"noopener\">用友 mock 平台</a></p>\n<p>Proxy &amp;&amp; Mock</p>\n<ul>\n<li>Webpack-dev-server proxy 配置</li>\n<li>Node server based Koa / Express</li>\n<li>webpack-hot-moddleware</li>\n<li>Http-proxy-middleware</li>\n<li>Http-proxy(node-http-proxy)</li>\n</ul>\n<p>配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">            contentBase: path.resolve(__dirname, <span class=\"string\">'../dist'</span>),</span><br><span class=\"line\">            hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            proxy: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"/corp\"</span>: &#123;</span><br><span class=\"line\">                    target: <span class=\"string\">\"https://mock.yonyoucloud.com/mock/548\"</span>,</span><br><span class=\"line\">                    secure: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                    changeOrigin: <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理服务器会在请求头中加入相应host header，然后目标服务器就可以根据这个 header 来区别要访问的站点</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"MHR-热更新\"><a href=\"#MHR-热更新\" class=\"headerlink\" title=\"MHR 热更新\"></a>MHR 热更新</h4><h5 id=\"热更新执行过程：\"><a href=\"#热更新执行过程：\" class=\"headerlink\" title=\"热更新执行过程：\"></a>热更新执行过程：</h5><p>模块更新, 更新的消息冒泡到 entry</p>\n<ol>\n<li>未捕获：webpack-dev-server 内置 live reload</li>\n<li>捕获：HotModuleReplacementPlugin ——&gt;  webpack de -server （通知更新） &lt;——&gt; （web sokcet 通信）浏览器</li>\n</ol>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><ol>\n<li>devServer设置hot: true</li>\n<li>New webpack.HotModuleReplacementPlugin() 插件设置</li>\n<li>入口判断：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">module</span>.hot.accept()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"多端同步更新（移动、桌面、web端）\"><a href=\"#多端同步更新（移动、桌面、web端）\" class=\"headerlink\" title=\"多端同步更新（移动、桌面、web端）\"></a>多端同步更新（移动、桌面、web端）</h5><p>插件：<br>browser-sync-webpack-plugin</p>\n<p>配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BrowserSyncPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync-webpack-plugin'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BrowserSyncPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// browse to http://localhost:3000/ during development,</span></span><br><span class=\"line\">      <span class=\"comment\">// ./public directory is being served</span></span><br><span class=\"line\">      host: <span class=\"string\">'localhost'</span>,</span><br><span class=\"line\">      port: <span class=\"number\">3000</span>,</span><br><span class=\"line\">      server: &#123; <span class=\"attr\">baseDir</span>: [<span class=\"string\">'public'</span>] &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一直期待已久的整体系统的学习 webpack， 终于有机会了，现在将自己学习的笔记记录下来。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"webpack-是做什么的\"><a href=\"#webpack-是做什么的\" class=\"headerlink\" title=\"webpack 是做什么的\"></a>webpack 是做什么的</h2><ol>\n<li>围绕 webpack 的工具体系能够帮助我们系统化的解决前端资源问题</li>\n<li>涵盖项目开发（单页应用或多页应用）、组件开发、SDK 开发等不同需求</li>\n<li>配置从简到繁，需要结合项目需求和工具配置构建出符合项目的工作流。不仅仅是工具，更需要结合工程化的思想。</li>\n</ol>\n<p>官网地址: <a href=\"https://webpack.docschina.org/\" target=\"_blank\" rel=\"noopener\">中文地址</a>   <a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">英文地址</a></p>\n<blockquote>\n<p>主要需要注意的是所看 webpack 的版本，因为每个版本有很多不一样的地方</p>\n</blockquote>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><h4 id=\"1-初始化\"><a href=\"#1-初始化\" class=\"headerlink\" title=\"1. 初始化\"></a>1. 初始化</h4><p>自动构建，读取与合并参数，加载 plugin，实例化 complier plugin 机制，在这个环节可以通过配置 plugin 对 webpack 进行自定义功能扩展<br>（简言之：使用 plugin 加载各种插件）</p>\n<h4 id=\"2-编译\"><a href=\"#2-编译\" class=\"headerlink\" title=\"2. 编译\"></a>2. 编译</h4><p>从 entry 出发，针对每一个 module 调用 loader 翻译文件内容，并找到 module 的依赖进行编译处理。<br>（简言之：使用 loader 配置加载编译项目内容）</p>\n<h4 id=\"3-输出\"><a href=\"#3-输出\" class=\"headerlink\" title=\"3. 输出\"></a>3. 输出</h4><p>将编译后的 module 组合成 chunk , 将 chunk 转换成文件，输出到文件系统。<br>（简言之：将编译后的文件输出）</p>\n<p>注释：chunk 中文意思为 块</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p>配置 webpack 首先需要了解主要有哪些核心的配置：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">\"\"</span>,           <span class=\"comment\">// string  构建模式, eg: production(default)、development、none</span></span><br><span class=\"line\">    context: <span class=\"string\">\"\"</span>,        <span class=\"comment\">// 上下文</span></span><br><span class=\"line\">    entry: <span class=\"string\">\"\"</span>,          <span class=\"comment\">// 入口，可以是字符串、数组、对象、函数</span></span><br><span class=\"line\">    devtool: <span class=\"string\">\"\"</span>,        <span class=\"comment\">// 开发工具</span></span><br><span class=\"line\">    output: &#123; &#125;,        <span class=\"comment\">// 输出配置</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123; &#125;,        <span class=\"comment\">// module 配置，处理不同资源</span></span><br><span class=\"line\">    plugins: [ ],       <span class=\"comment\">// plugin 配置</span></span><br><span class=\"line\">    optimization: &#123; &#125;,  <span class=\"comment\">// 资源优化配置项</span></span><br><span class=\"line\">    devServer: &#123; &#125;      <span class=\"comment\">// webpack-dev-server 服务配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"区分构建环境\"><a href=\"#区分构建环境\" class=\"headerlink\" title=\"区分构建环境\"></a>区分构建环境</h2><h4 id=\"分离多套环境\"><a href=\"#分离多套环境\" class=\"headerlink\" title=\"分离多套环境\"></a>分离多套环境</h4><p>单独配置，可以解决很多问题</p>\n<ol>\n<li>分离坏境：<br> dev（开发环境）、 prod（线上环境）、 staging（预发布环境）、 test（测试环境）</li>\n<li>多环境配置文件放在 build</li>\n<li>抽取 base 公共配置</li>\n<li>webpack-merge 合并配置</li>\n<li>全局环境参数通过 env.mode 传入</li>\n</ol>\n<h4 id=\"不同环境不同配置\"><a href=\"#不同环境不同配置\" class=\"headerlink\" title=\"不同环境不同配置\"></a>不同环境不同配置</h4><ul>\n<li>区分环境不同的 mode 构建模式</li>\n<li>区分环境不同的 output.filename</li>\n<li>定义全局环境变量：webpack/lib/DefinePlugin  实现逻辑层也能按环境区分</li>\n<li>区分环境配置不同的 CDN &amp;&amp; publicpath</li>\n</ul>\n<p><img src=\"/images/webpack/env1.png\" alt=\"\"><img src=\"/images/webpack/env2.png\" alt=\"\"><img src=\"/images/webpack/env3.png\" alt=\"\"></p>\n<h2 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h2><h4 id=\"使用-loader-配置更多资源：\"><a href=\"#使用-loader-配置更多资源：\" class=\"headerlink\" title=\"使用 loader 配置更多资源：\"></a>使用 loader 配置更多资源：</h4><ol>\n<li>url-loader 和 file-loader   ：前者内置后者，实现了图片的 base64 压缩以及资源大小限制、减少 http 请求</li>\n<li>postcss-loader 使用 postcss 生态，需要在预处理器前配置实用</li>\n<li>babel-loader  享受了最新的语法特性带来的技术红利</li>\n</ol>\n<h4 id=\"常用的-loader-总结：\"><a href=\"#常用的-loader-总结：\" class=\"headerlink\" title=\"常用的 loader 总结：\"></a>常用的 loader 总结：</h4><h5 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h5><ul>\n<li>raw-loader 加载文件原始内容（utf-8）</li>\n<li>val-loader 将代码作为模块执行，并将 exports 转为 JS 代码</li>\n<li>url-loader 像 file loader 一样工作，但如果文件小于限制，可以返回 data URL</li>\n<li>file-loader 将文件发送到输出文件夹，并返回（相对）URL</li>\n</ul>\n<h5 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h5><ul>\n<li>json-loader 加载 JSON 文件（默认包含）</li>\n<li>json5-loader 加载和转译 JSON 5 文件</li>\n<li>cson-loader 加载和转译 CSON 文件</li>\n</ul>\n<h5 id=\"转换编译-Transpiling\"><a href=\"#转换编译-Transpiling\" class=\"headerlink\" title=\"转换编译(Transpiling)\"></a>转换编译(Transpiling)</h5><ul>\n<li>script-loader 在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析</li>\n<li>babel-loader 加载 ES2015+ 代码，然后使用 Babel 转译为 ES5</li>\n<li>buble-loader 使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5</li>\n<li>traceur-loader 加载 ES2015+ 代码，然后使用 Traceur 转译为 ES5</li>\n<li>ts-loader 或 awesome-typescript-loader 像 JavaScript 一样加载 TypeScript 2.0+</li>\n<li>coffee-loader 像 JavaScript 一样加载 CoffeeScript</li>\n<li>fengari-loader 使用 fengari 加载 Lua 代码</li>\n</ul>\n<h5 id=\"模板-Templating\"><a href=\"#模板-Templating\" class=\"headerlink\" title=\"模板(Templating)\"></a>模板(Templating)</h5><ul>\n<li>html-loader 导出 HTML 为字符串，需要引用静态资源</li>\n<li>pug-loader 加载 Pug 模板并返回一个函数</li>\n<li>jade-loader 加载 Jade 模板并返回一个函数</li>\n<li>markdown-loader 将 Markdown 转译为 HTML</li>\n<li>react-markdown-loader 使用 markdown-parse parser(解析器) 将 Markdown 编译为 React 组件</li>\n<li>posthtml-loader 使用 PostHTML 加载并转换 HTML 文件</li>\n<li>handlebars-loader 将 Handlebars 转移为 HTML</li>\n<li>markup-inline-loader 将内联的 SVG/MathML 文件转换为 HTML。在应用于图标字体，或将 CSS 动画应用于 SVG 时非常有用。</li>\n<li>twig-loader 编译 Twig 模板，然后返回一个函数</li>\n</ul>\n<h5 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h5><ul>\n<li>style-loader 将模块的导出作为样式添加到 DOM 中</li>\n<li>css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</li>\n<li>less-loader 加载和转译 LESS 文件</li>\n<li>sass-loader 加载和转译 SASS/SCSS 文件</li>\n<li>postcss-loader 使用 PostCSS 加载和转译 CSS/SSS 文件</li>\n<li>stylus-loader 加载和转译 Stylus 文件</li>\n</ul>\n<h4 id=\"常用-loader-简单分类\"><a href=\"#常用-loader-简单分类\" class=\"headerlink\" title=\"常用 loader 简单分类\"></a>常用 loader 简单分类</h4><h5 id=\"1-Html-handlebars-Jade：\"><a href=\"#1-Html-handlebars-Jade：\" class=\"headerlink\" title=\"1. Html/handlebars/Jade：\"></a>1. Html/handlebars/Jade：</h5><p>html-loader、pug-loader、handlebars-loader</p>\n<h5 id=\"2-CSS-Stylus-SASS-LESS\"><a href=\"#2-CSS-Stylus-SASS-LESS\" class=\"headerlink\" title=\"2. CSS/Stylus/SASS/LESS\"></a>2. CSS/Stylus/SASS/LESS</h5><p>css-loader、sass-loader、less-loader、stylus-loder</p>\n<h5 id=\"3-ESM-AMD-CMD-COMMONJS\"><a href=\"#3-ESM-AMD-CMD-COMMONJS\" class=\"headerlink\" title=\"3. ESM/AMD/CMD/COMMONJS\"></a>3. ESM/AMD/CMD/COMMONJS</h5><p>babel-loader + presets / plugins</p>\n<h5 id=\"4-Images-IconFont-JSON\"><a href=\"#4-Images-IconFont-JSON\" class=\"headerlink\" title=\"4. Images/IconFont/JSON\"></a>4. Images/IconFont/JSON</h5><p>url-loader、json-loader</p>\n<h2 id=\"plugin\"><a href=\"#plugin\" class=\"headerlink\" title=\"plugin\"></a>plugin</h2><h4 id=\"常用的-plugin\"><a href=\"#常用的-plugin\" class=\"headerlink\" title=\"常用的 plugin\"></a>常用的 plugin</h4><ol>\n<li>copy-webpack-plugin  将不需要编译的静态资源复制到目标目录</li>\n<li>html-webpack-plugin   编译 html 模板</li>\n<li>clean-webpack-plugin   清空指定目标目录资源，例如 dist</li>\n<li>mini-css-extract-plugin  独立 css 资源，压缩。 extract-text-css-plugin  不兼容 4.x</li>\n<li>AggressiveSplittingPlugin    将原来的 chunk 分成更小的 chunk</li>\n<li>BabelMinifyWebpackPlugin    使用 babel-minify 进行压缩</li>\n<li>BannerPlugin    在每个生成的 chunk 顶部添加 banner</li>\n<li>CommonsChunkPlugin    提取 chunks 之间共享的通用模块</li>\n<li>CompressionWebpackPlugin    预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务</li>\n<li>ContextReplacementPlugin    重写 require 表达式的推断上下文</li>\n<li>CopyWebpackPlugin    将单个文件或整个目录复制到构建目录</li>\n<li>DefinePlugin    允许在编译时(compile time)配置的全局常量</li>\n<li>DllPlugin    为了极大减少构建时间，进行分离打包</li>\n<li>EnvironmentPlugin    DefinePlugin 中 process.env 键的简写方式。</li>\n<li>ExtractTextWebpackPlugin    从 bundle 中提取文本（CSS）到单独的文件</li>\n<li>HotModuleReplacementPlugin    启用模块热替换(Enable Hot Module Replacement - HMR)</li>\n<li>HtmlWebpackPlugin    简单创建 HTML 文件，用于服务器访问</li>\n<li>I18nWebpackPlugin    为 bundle 增加国际化支持</li>\n<li>IgnorePlugin    从 bundle 中排除某些模块</li>\n<li>LimitChunkCountPlugin    设置 chunk 的最小/最大限制，以微调和控制 chunk</li>\n<li>LoaderOptionsPlugin    用于从 webpack 1 迁移到 webpack 2</li>\n<li>MinChunkSizePlugin    确保 chunk 大小超过指定限制</li>\n<li>MiniCssExtractPlugin    为每个引入 CSS 的 JS 文件创建一个 CSS 文件</li>\n<li>NoEmitOnErrorsPlugin    在输出阶段时，遇到编译错误跳过</li>\n<li>NormalModuleReplacementPlugin    替换与正则表达式匹配的资源</li>\n<li>NpmInstallWebpackPlugin    在开发时自动安装缺少的依赖</li>\n<li>ProvidePlugin    不必通过 import/require 使用模块</li>\n<li>SourceMapDevToolPlugin    对 source map 进行更细粒度的控制</li>\n<li>EvalSourceMapDevToolPlugin    对 eval source map 进行更细粒度的控制</li>\n</ol>\n<h2 id=\"优化基本开发体验\"><a href=\"#优化基本开发体验\" class=\"headerlink\" title=\"优化基本开发体验\"></a>优化基本开发体验</h2><h4 id=\"devtool-开发工具\"><a href=\"#devtool-开发工具\" class=\"headerlink\" title=\"devtool 开发工具\"></a>devtool 开发工具</h4><table>\n<thead>\n<tr>\n<th>#</th>\n<th>模式</th>\n<th>解释</th>\n<th>速度</th>\n<th>生产环境</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>eval</td>\n<td>会将模块封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.</td>\n<td>最快</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>2</td>\n<td>source-map</td>\n<td>生成一个 SourceMap 文件.</td>\n<td>很慢</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>3</td>\n<td>hidden-source-map</td>\n<td>和 source-map 一样，但不会在 bundle 末尾追加注释.</td>\n<td>很慢</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>4</td>\n<td>inline-source-map</td>\n<td>生成一个 DataUrl 形式的 SourceMap 文件.</td>\n<td>很慢</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>5</td>\n<td>eval-source-map</td>\n<td>每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .</td>\n<td>很慢</td>\n<td>不可以</td>\n</tr>\n<tr>\n<td>6</td>\n<td>cheap-source-map</td>\n<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）</td>\n<td>一般快</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>7</td>\n<td>cheap-module-source-map</td>\n<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。</td>\n<td>较快</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>8</td>\n<td>cheap-module-eval-source-map</td>\n<td>类似 cheap-eval-source-map，并且，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。</td>\n<td>较快</td>\n<td>不可以</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"proxy-代理\"><a href=\"#proxy-代理\" class=\"headerlink\" title=\"proxy 代理\"></a>proxy 代理</h4><p>结合 mock 平台实现 proxy 代理。<a href=\"https://mock.yonyoucloud.com/\" target=\"_blank\" rel=\"noopener\">用友 mock 平台</a></p>\n<p>Proxy &amp;&amp; Mock</p>\n<ul>\n<li>Webpack-dev-server proxy 配置</li>\n<li>Node server based Koa / Express</li>\n<li>webpack-hot-moddleware</li>\n<li>Http-proxy-middleware</li>\n<li>Http-proxy(node-http-proxy)</li>\n</ul>\n<p>配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">            contentBase: path.resolve(__dirname, <span class=\"string\">'../dist'</span>),</span><br><span class=\"line\">            hot: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            proxy: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"/corp\"</span>: &#123;</span><br><span class=\"line\">                    target: <span class=\"string\">\"https://mock.yonyoucloud.com/mock/548\"</span>,</span><br><span class=\"line\">                    secure: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                    changeOrigin: <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理服务器会在请求头中加入相应host header，然后目标服务器就可以根据这个 header 来区别要访问的站点</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"MHR-热更新\"><a href=\"#MHR-热更新\" class=\"headerlink\" title=\"MHR 热更新\"></a>MHR 热更新</h4><h5 id=\"热更新执行过程：\"><a href=\"#热更新执行过程：\" class=\"headerlink\" title=\"热更新执行过程：\"></a>热更新执行过程：</h5><p>模块更新, 更新的消息冒泡到 entry</p>\n<ol>\n<li>未捕获：webpack-dev-server 内置 live reload</li>\n<li>捕获：HotModuleReplacementPlugin ——&gt;  webpack de -server （通知更新） &lt;——&gt; （web sokcet 通信）浏览器</li>\n</ol>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><ol>\n<li>devServer设置hot: true</li>\n<li>New webpack.HotModuleReplacementPlugin() 插件设置</li>\n<li>入口判断：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">   <span class=\"built_in\">module</span>.hot.accept()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"多端同步更新（移动、桌面、web端）\"><a href=\"#多端同步更新（移动、桌面、web端）\" class=\"headerlink\" title=\"多端同步更新（移动、桌面、web端）\"></a>多端同步更新（移动、桌面、web端）</h5><p>插件：<br>browser-sync-webpack-plugin</p>\n<p>配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BrowserSyncPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync-webpack-plugin'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BrowserSyncPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// browse to http://localhost:3000/ during development,</span></span><br><span class=\"line\">      <span class=\"comment\">// ./public directory is being served</span></span><br><span class=\"line\">      host: <span class=\"string\">'localhost'</span>,</span><br><span class=\"line\">      port: <span class=\"number\">3000</span>,</span><br><span class=\"line\">      server: &#123; <span class=\"attr\">baseDir</span>: [<span class=\"string\">'public'</span>] &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一直期待已久的整体系统的学习 webpack， 终于有机会了，现在将自己学习的笔记记录下来。。。</p>\n"},{"title":"windows CMD 常用指令","date":"2018-09-29T06:31:52.000Z","_content":"\n1. 进入 D 盘\n```js\n> d:   // 输入回车\n```\n \n2. 查看所有文件：\n```js\n> dir    // 会列出所有文件信息\n```\n\n3. 查看文件树\n```js\n> tree   // 会以树状行列出所有文件夹\n```","source":"_posts/windows-CMD-常用指令.md","raw":"---\ntitle: windows CMD 常用指令\ndate: 2018-09-29 14:31:52\ntags: ['windows', '指令']\n---\n\n1. 进入 D 盘\n```js\n> d:   // 输入回车\n```\n \n2. 查看所有文件：\n```js\n> dir    // 会列出所有文件信息\n```\n\n3. 查看文件树\n```js\n> tree   // 会以树状行列出所有文件夹\n```","slug":"windows-CMD-常用指令","published":1,"updated":"2018-09-29T06:37:18.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbd0017fwvpxvx4d84j","content":"<ol>\n<li>进入 D 盘<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; d:   <span class=\"comment\">// 输入回车</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>查看所有文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dir    <span class=\"comment\">// 会列出所有文件信息</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看文件树</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tree   <span class=\"comment\">// 会以树状行列出所有文件夹</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>进入 D 盘<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; d:   <span class=\"comment\">// 输入回车</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>查看所有文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dir    <span class=\"comment\">// 会列出所有文件信息</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看文件树</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; tree   <span class=\"comment\">// 会以树状行列出所有文件夹</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"windows 环境安装 git","date":"2018-08-24T06:37:43.000Z","_content":"\n对于开发者，在 windows 环境下安装 git 会有两个步骤：\n\n### 1. 下载 \n[windows 版的 git 包](https://gitforwindows.org/)\n\n### 2. 安装\n下载完成之后进行安装，很普通安装的过程一致。（一直点击下一步就行了）\n\n### 3. 配置环境变量\n安装完成之后，最关键的步骤来了，配置环境变量\n1. 右键单击“计算机”，选择“属性”;\n    ![](/images/git-computer.jpg)\n\n2. 选择左侧栏的 “高级系统设置” 选项;\n    ![](/images/git-set.jpg)\n\n3. 在属性系统中选择 “环境变量”;\n    ![](/images/git-env.jpg)\n\n4. 选择 “path” 选项\n    ![](/images/git-path.jpg)\n\n5. 复制安装的 git 目录下的 bin（如 C:\\Program Files (x86)\\Git\\bin ）添加到 PATH 环境变量。保存之后，就可以在 cmd 和 git bash 中使用 git 了。\n\n> 注意：在添加环境变量的时候是以 \";\" 隔开每个路径的。\n\n可以右键单击看看菜单栏是否已经有了 git bash。:)","source":"_posts/windows-下安装-git.md","raw":"---\ntitle: windows 环境安装 git\ndate: 2018-08-24 14:37:43\ntags: ['git', 'windows'] \n---\n\n对于开发者，在 windows 环境下安装 git 会有两个步骤：\n\n### 1. 下载 \n[windows 版的 git 包](https://gitforwindows.org/)\n\n### 2. 安装\n下载完成之后进行安装，很普通安装的过程一致。（一直点击下一步就行了）\n\n### 3. 配置环境变量\n安装完成之后，最关键的步骤来了，配置环境变量\n1. 右键单击“计算机”，选择“属性”;\n    ![](/images/git-computer.jpg)\n\n2. 选择左侧栏的 “高级系统设置” 选项;\n    ![](/images/git-set.jpg)\n\n3. 在属性系统中选择 “环境变量”;\n    ![](/images/git-env.jpg)\n\n4. 选择 “path” 选项\n    ![](/images/git-path.jpg)\n\n5. 复制安装的 git 目录下的 bin（如 C:\\Program Files (x86)\\Git\\bin ）添加到 PATH 环境变量。保存之后，就可以在 cmd 和 git bash 中使用 git 了。\n\n> 注意：在添加环境变量的时候是以 \";\" 隔开每个路径的。\n\n可以右键单击看看菜单栏是否已经有了 git bash。:)","slug":"windows-下安装-git","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbf0019fwvppidonkhw","content":"<p>对于开发者，在 windows 环境下安装 git 会有两个步骤：</p>\n<h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1. 下载\"></a>1. 下载</h3><p><a href=\"https://gitforwindows.org/\" target=\"_blank\" rel=\"noopener\">windows 版的 git 包</a></p>\n<h3 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h3><p>下载完成之后进行安装，很普通安装的过程一致。（一直点击下一步就行了）</p>\n<h3 id=\"3-配置环境变量\"><a href=\"#3-配置环境变量\" class=\"headerlink\" title=\"3. 配置环境变量\"></a>3. 配置环境变量</h3><p>安装完成之后，最关键的步骤来了，配置环境变量</p>\n<ol>\n<li><p>右键单击“计算机”，选择“属性”;<br> <img src=\"/images/git-computer.jpg\" alt=\"\"></p>\n</li>\n<li><p>选择左侧栏的 “高级系统设置” 选项;<br> <img src=\"/images/git-set.jpg\" alt=\"\"></p>\n</li>\n<li><p>在属性系统中选择 “环境变量”;<br> <img src=\"/images/git-env.jpg\" alt=\"\"></p>\n</li>\n<li><p>选择 “path” 选项<br> <img src=\"/images/git-path.jpg\" alt=\"\"></p>\n</li>\n<li><p>复制安装的 git 目录下的 bin（如 C:\\Program Files (x86)\\Git\\bin ）添加到 PATH 环境变量。保存之后，就可以在 cmd 和 git bash 中使用 git 了。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：在添加环境变量的时候是以 “;” 隔开每个路径的。</p>\n</blockquote>\n<p>可以右键单击看看菜单栏是否已经有了 git bash。:)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于开发者，在 windows 环境下安装 git 会有两个步骤：</p>\n<h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1. 下载\"></a>1. 下载</h3><p><a href=\"https://gitforwindows.org/\" target=\"_blank\" rel=\"noopener\">windows 版的 git 包</a></p>\n<h3 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h3><p>下载完成之后进行安装，很普通安装的过程一致。（一直点击下一步就行了）</p>\n<h3 id=\"3-配置环境变量\"><a href=\"#3-配置环境变量\" class=\"headerlink\" title=\"3. 配置环境变量\"></a>3. 配置环境变量</h3><p>安装完成之后，最关键的步骤来了，配置环境变量</p>\n<ol>\n<li><p>右键单击“计算机”，选择“属性”;<br> <img src=\"/images/git-computer.jpg\" alt=\"\"></p>\n</li>\n<li><p>选择左侧栏的 “高级系统设置” 选项;<br> <img src=\"/images/git-set.jpg\" alt=\"\"></p>\n</li>\n<li><p>在属性系统中选择 “环境变量”;<br> <img src=\"/images/git-env.jpg\" alt=\"\"></p>\n</li>\n<li><p>选择 “path” 选项<br> <img src=\"/images/git-path.jpg\" alt=\"\"></p>\n</li>\n<li><p>复制安装的 git 目录下的 bin（如 C:\\Program Files (x86)\\Git\\bin ）添加到 PATH 环境变量。保存之后，就可以在 cmd 和 git bash 中使用 git 了。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：在添加环境变量的时候是以 “;” 隔开每个路径的。</p>\n</blockquote>\n<p>可以右键单击看看菜单栏是否已经有了 git bash。:)</p>\n"},{"title":"windows 常用快捷键总结","date":"2018-08-25T04:10:54.000Z","_content":"\n已经使用 Mac 两年的人，突然间要求我换回来 windows ，适应起来真的有点费劲，所以总结一下平时最常用的快捷吧：\n\n## 基本操作\n\n复制：Ctrl + C\n剪切：Ctrl + X\n粘贴：Ctrl + V\n全选：Ctrl + A\n保存：Ctrl + S\n删除文件：Delete 键\n刷新：F5\n打开/关闭浏览器控制台：F12\n切换输入法：Ctrl + Shift\n获取当前时间：Ctrl + ;\n\n## 文件夹操作\n\n重命名：F2（选中想要重命名的文件）\n直接删除文件（不放在垃圾桶里）：Shift + Delete\n新建文件夹(XP系统不适用)：Ctrl + Shift + N\n\n## 标签操作\n\n关闭当前标签页/窗口：Ctrl + W\n切换标签(前移): Ctrl + Tab\n切换标签(后移): Ctrl + Shift + Tab\n\n## 窗口操作\n\n打卡终端（windows 叫做 cmd）：选择开始 -> 在搜索输入框中输入 cmd\n显示桌面：Win + D\n移动窗口：Win + 方向键（上下左右）","source":"_posts/windows-常用快捷键总结.md","raw":"---\ntitle: windows 常用快捷键总结\ndate: 2018-08-25 12:10:54\ntags: windows\n---\n\n已经使用 Mac 两年的人，突然间要求我换回来 windows ，适应起来真的有点费劲，所以总结一下平时最常用的快捷吧：\n\n## 基本操作\n\n复制：Ctrl + C\n剪切：Ctrl + X\n粘贴：Ctrl + V\n全选：Ctrl + A\n保存：Ctrl + S\n删除文件：Delete 键\n刷新：F5\n打开/关闭浏览器控制台：F12\n切换输入法：Ctrl + Shift\n获取当前时间：Ctrl + ;\n\n## 文件夹操作\n\n重命名：F2（选中想要重命名的文件）\n直接删除文件（不放在垃圾桶里）：Shift + Delete\n新建文件夹(XP系统不适用)：Ctrl + Shift + N\n\n## 标签操作\n\n关闭当前标签页/窗口：Ctrl + W\n切换标签(前移): Ctrl + Tab\n切换标签(后移): Ctrl + Shift + Tab\n\n## 窗口操作\n\n打卡终端（windows 叫做 cmd）：选择开始 -> 在搜索输入框中输入 cmd\n显示桌面：Win + D\n移动窗口：Win + 方向键（上下左右）","slug":"windows-常用快捷键总结","published":1,"updated":"2018-09-15T02:18:11.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbh001dfwvpnmc2izh5","content":"<p>已经使用 Mac 两年的人，突然间要求我换回来 windows ，适应起来真的有点费劲，所以总结一下平时最常用的快捷吧：</p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>复制：Ctrl + C<br>剪切：Ctrl + X<br>粘贴：Ctrl + V<br>全选：Ctrl + A<br>保存：Ctrl + S<br>删除文件：Delete 键<br>刷新：F5<br>打开/关闭浏览器控制台：F12<br>切换输入法：Ctrl + Shift<br>获取当前时间：Ctrl + ;</p>\n<h2 id=\"文件夹操作\"><a href=\"#文件夹操作\" class=\"headerlink\" title=\"文件夹操作\"></a>文件夹操作</h2><p>重命名：F2（选中想要重命名的文件）<br>直接删除文件（不放在垃圾桶里）：Shift + Delete<br>新建文件夹(XP系统不适用)：Ctrl + Shift + N</p>\n<h2 id=\"标签操作\"><a href=\"#标签操作\" class=\"headerlink\" title=\"标签操作\"></a>标签操作</h2><p>关闭当前标签页/窗口：Ctrl + W<br>切换标签(前移): Ctrl + Tab<br>切换标签(后移): Ctrl + Shift + Tab</p>\n<h2 id=\"窗口操作\"><a href=\"#窗口操作\" class=\"headerlink\" title=\"窗口操作\"></a>窗口操作</h2><p>打卡终端（windows 叫做 cmd）：选择开始 -&gt; 在搜索输入框中输入 cmd<br>显示桌面：Win + D<br>移动窗口：Win + 方向键（上下左右）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>已经使用 Mac 两年的人，突然间要求我换回来 windows ，适应起来真的有点费劲，所以总结一下平时最常用的快捷吧：</p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>复制：Ctrl + C<br>剪切：Ctrl + X<br>粘贴：Ctrl + V<br>全选：Ctrl + A<br>保存：Ctrl + S<br>删除文件：Delete 键<br>刷新：F5<br>打开/关闭浏览器控制台：F12<br>切换输入法：Ctrl + Shift<br>获取当前时间：Ctrl + ;</p>\n<h2 id=\"文件夹操作\"><a href=\"#文件夹操作\" class=\"headerlink\" title=\"文件夹操作\"></a>文件夹操作</h2><p>重命名：F2（选中想要重命名的文件）<br>直接删除文件（不放在垃圾桶里）：Shift + Delete<br>新建文件夹(XP系统不适用)：Ctrl + Shift + N</p>\n<h2 id=\"标签操作\"><a href=\"#标签操作\" class=\"headerlink\" title=\"标签操作\"></a>标签操作</h2><p>关闭当前标签页/窗口：Ctrl + W<br>切换标签(前移): Ctrl + Tab<br>切换标签(后移): Ctrl + Shift + Tab</p>\n<h2 id=\"窗口操作\"><a href=\"#窗口操作\" class=\"headerlink\" title=\"窗口操作\"></a>窗口操作</h2><p>打卡终端（windows 叫做 cmd）：选择开始 -&gt; 在搜索输入框中输入 cmd<br>显示桌面：Win + D<br>移动窗口：Win + 方向键（上下左右）</p>\n"},{"title":"什么是跨域？","date":"2018-06-11T14:12:53.000Z","_content":"\n简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法\n\n看如下例子：\n\n1. 同一域名下  【允许通信】\nhttp://www.a.com/a.js\nhttp://www.a.com/b.js\n\n2. 同一域名下不同文件夹  【允许通信】\nhttp://www.a.com/lab/a.js\nhttp://www.a.com/script/b.js\n\n3. 同一域名，不同端口  【不允许通信】\nhttp://www.a.com:8000/a.js\nhttp://www.a.com/b.js\n\n4. 同一域名，不同协议  【不允许通信】\nhttp://www.a.com/a.js\nhttps://www.a.com/b.js\n\n5. 域名和域名对应ip 【不允许通信】\nhttp://www.a.com/a.js\nhttp://70.32.92.74/b.js\n\n6. 主域相同，子域不同 【不允许通信】\nhttp://www.a.com/a.js\nhttp://script.a.com/b.js\n\n7. 同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】\nhttp://www.a.com/a.js\nhttp://a.com/b.js\n\n8. 不同域名 【不允许通信】\nhttp://www.cnblogs.com/a.js\nhttp://www.a.com/b.js\n\n\n#### 同源策略（same-origin policy）\n同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。\n\n\n原文链接：http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\n","source":"_posts/什么是跨域？.md","raw":"---\ntitle: 什么是跨域？\ndate: 2018-06-11 22:12:53\ntags: 跨域\ncategories: js\n---\n\n简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法\n\n看如下例子：\n\n1. 同一域名下  【允许通信】\nhttp://www.a.com/a.js\nhttp://www.a.com/b.js\n\n2. 同一域名下不同文件夹  【允许通信】\nhttp://www.a.com/lab/a.js\nhttp://www.a.com/script/b.js\n\n3. 同一域名，不同端口  【不允许通信】\nhttp://www.a.com:8000/a.js\nhttp://www.a.com/b.js\n\n4. 同一域名，不同协议  【不允许通信】\nhttp://www.a.com/a.js\nhttps://www.a.com/b.js\n\n5. 域名和域名对应ip 【不允许通信】\nhttp://www.a.com/a.js\nhttp://70.32.92.74/b.js\n\n6. 主域相同，子域不同 【不允许通信】\nhttp://www.a.com/a.js\nhttp://script.a.com/b.js\n\n7. 同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】\nhttp://www.a.com/a.js\nhttp://a.com/b.js\n\n8. 不同域名 【不允许通信】\nhttp://www.cnblogs.com/a.js\nhttp://www.a.com/b.js\n\n\n#### 同源策略（same-origin policy）\n同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。\n\n\n原文链接：http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\n","slug":"什么是跨域？","published":1,"updated":"2018-09-15T02:18:11.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbj001gfwvp3etbqzeh","content":"<p>简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法</p>\n<p>看如下例子：</p>\n<ol>\n<li><p>同一域名下  【允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名下不同文件夹  【允许通信】<br><a href=\"http://www.a.com/lab/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/lab/a.js</a><br><a href=\"http://www.a.com/script/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/script/b.js</a></p>\n</li>\n<li><p>同一域名，不同端口  【不允许通信】<br><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同协议  【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"https://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">https://www.a.com/b.js</a></p>\n</li>\n<li><p>域名和域名对应ip 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://70.32.92.74/b.js\" target=\"_blank\" rel=\"noopener\">http://70.32.92.74/b.js</a></p>\n</li>\n<li><p>主域相同，子域不同 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://script.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://script.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://a.com/b.js</a></p>\n</li>\n<li><p>不同域名 【不允许通信】<br><a href=\"http://www.cnblogs.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n</ol>\n<h4 id=\"同源策略（same-origin-policy）\"><a href=\"#同源策略（same-origin-policy）\" class=\"headerlink\" title=\"同源策略（same-origin policy）\"></a>同源策略（same-origin policy）</h4><p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法</p>\n<p>看如下例子：</p>\n<ol>\n<li><p>同一域名下  【允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名下不同文件夹  【允许通信】<br><a href=\"http://www.a.com/lab/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/lab/a.js</a><br><a href=\"http://www.a.com/script/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/script/b.js</a></p>\n</li>\n<li><p>同一域名，不同端口  【不允许通信】<br><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同协议  【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"https://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">https://www.a.com/b.js</a></p>\n</li>\n<li><p>域名和域名对应ip 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://70.32.92.74/b.js\" target=\"_blank\" rel=\"noopener\">http://70.32.92.74/b.js</a></p>\n</li>\n<li><p>主域相同，子域不同 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://script.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://script.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://a.com/b.js</a></p>\n</li>\n<li><p>不同域名 【不允许通信】<br><a href=\"http://www.cnblogs.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n</ol>\n<h4 id=\"同源策略（same-origin-policy）\"><a href=\"#同源策略（same-origin-policy）\" class=\"headerlink\" title=\"同源策略（same-origin policy）\"></a>同源策略（same-origin policy）</h4><p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html</a></p>\n"},{"title":"正则表达式","date":"2018-09-28T02:38:45.000Z","_content":"\n## 正则生成\n\n 1. new RegExp 对象的构造函数\n \n` var reg = new RegExp('^[a-z]$', 'gi')`\n\n2. 字面量形式：\n\n` var reg = /^[a-z]$/gi `\n\n## 正则的组成\n\n#### 元字符\n1. 匹配字符\n\n\n.   出来换行(\\n)以外的所有字符\n\n\\w  匹配字母、数字、下划线\n\n\\W  匹配除了字母、数字、下划线\n\n\\d  匹配数字 \n\n\\D  匹配除了数字以外其他字符\n\n\\s  匹配仍以的空白符（空格、\\t \\v \\n \\r \\f 制表符）\n\n\\S  匹配空白符意外的任意字符\n\n2. 匹配位置\n\n\n\\b  匹配单词开始和结束的位置（\\w 和 \\W 之间的位置）\n\n\\B  匹配单词的非开始或者结束位置\n\n^   匹配行首位置\n\n$   匹配行尾位置\n\n(?=p) 该位置后面字符要匹配 p  \n\n(?!p) 该位置后面字符不匹配 p\n\n\n#### 标志字符\nm   多行（multi line）\n\ng   全局（global）\n\ni   不区分大小写（ignore）\n\n例如：\n```js\nvar reg = /^abc/;\nvar str = 'test\\nabc'; // 匹配不上，因为 \\n 是换行，不能匹配多行\n\nvar reg = /^abc/m;\nvar str = 'test\\nabc';  // 匹配上\n\n```\n\n#### 限定符\n\n` * `     匹配 0 次以上\n\n`+`       匹配 1 次以上\n\n`?`       0 次或 1 次\n\n`{m}`     匹配 m 次\n\n`{ m, }`  至少匹配 m 次\n\n`{m, n}`  至少 m 次，最多 n 次\n\n#### 转义字符\n\n`*+?|\\/{}[]()^$` 需要 \\ 进行转义\n\n\n## 正则方法\n\n#### 正则实例\n\n1. ` test()`\n参数为 string，返回值为 boolean\n\n例如：\n```js\n/javascript/.test(\"dadjavascript\");  //  true\n```\n\n2. `exec()`\n\n参数string，返回 [] ，存放匹配结果，如果没有匹配上返回 null\n\n例如:\n\n```js\nvar string = \"a and b and c\";\nvar reg = /(a and)?(b and)?c/;\n\nreg.exec(string);\n\n结果：\n[\"a and b and c\", \"a and \", \"b and \"]\n```\n返回值忠包含另外两个属性：index 和 input\n\nindex 表示匹配项在字符串中的位置。（上面代码匹配项为 short ，对应的位置 是16）;\n\ninput 表示应用正则表达式的字符串\n\n3. `lastIndex`  \n\n匹配的位置，可读可写\n\n\n> 注意：\n> 重复执行 `test()` ，他会记住匹配的位置，从上一次匹配的位置继续匹配\n\n1. 不具有标志 g 和不表示全局模式的正则对象不能使用 lastIndex 属性\n```js\n var reg = /abc/;\n var str = '1#abc+abc';\n console.log(rgb.test(str));   //true\n console.log(rgb.lastIndex);   // 0\n console.log(rgb.test(str));   // true\n console.log(rgb.lastIndex);   // 0\n console.log(rgb.test(str));   // true \n```\n\n2. lastIndex 用于规定下次匹配的起始位置\n\n```js\nvar reg = /abc/g;\n var str = '1#abc+abc';\n var str2 = '2abc';\n console.log(rgb.test(str));    //true\n console.log(rgb.lastIndex);    // 5\n console.log(rgb.test(str));    // true\n console.log(rgb.lastIndex);    // 9\n console.log(rgb.test(str2));   // false  最后没有了，所以匹配不上了\n```\n\n3. 如果再成功匹配字符串之后，想要重新匹配新的字符串，需要将该属性设置成 0\n```js \n var reg = /abc/g; \n var str = '1#abc+abc';\n var str2 = '2#abc';\n console.log(reg.test(str));   // true\n console.log(reg.lastIndex);   // 5\n console.log(reg.test(str2));  // false\n console.log(reg.lastIndex);   // 0\n```\n\n#### 字符串实例\n\n`search()`\n参数：需要检索的字串 / 正则对象\n\n返回值：-1 / 字符串忠 <b>第一个</b>预正则相匹配的字串的位置\n\n1. 不执行全局匹配，忽略 g\n2. 不能使用 lastIndex\n3. 总是从字符串开始进行检索\n\n```js\n'hello,javascript'.search('javascript');              //6     \n'hello,javascript'.search(/javascript/);               //6       \n'hello,javascript,javascript'.search(/javascript/g);   //6\n```\n\n`match()`\n\n参数：需要检索的字串 / 正则对象\n\n返回值： array / null\n\n1. 如果正则没有 g ，字符串只会匹配一次\n2. 如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到被检索字符串中的所有匹配的子串，它       的数组元素中存放的是被检索字符串中所有的匹配的子串，而且也没有 index 属性或 input 属性；\n\n\n```js\n'hello,javascript'.match('javascript');\n'hello,javascript'.match(/javascript/);\n```\n\n<img src=\"/images/reg/match.png\"/>\n<!-- ![](/images/hexo-page.png) -->\n\n`replace()`\n\n替换\n\n参数：\n1. 被替换的文本（字符串/正则）\n2. 替换成的文本（字符串/函数），如果是字符串，可以用特殊变量来代替\n\n返回值：替换后的字符串\n\n例如：\n```js\n'hello, javascript'.replace(' javascript', 'nodejs');\n'hello,javascript'.replace(/javascript/, 'nodeJs');\n'javascript nodejs'.replace(/(\\w+)\\s(\\w+)/, \"$2 $1\")\n'javascript nodejs'.replace(/(\\w+)\\s(\\w+)/, function( match, p1, p2, offset, string ){\n    // match: 匹配的字串\n    // p1, p2... 对应 $1 $2\n    // offset 匹配的字符串忠的偏移量\n    // string： 被匹配的字符串\n    console.log(match, '---', p1, p2, offset, string);\n    return [p1, p2].join('-')\n})\n```\n\n$$ 插入 $\n\n$& 插入匹配的字串\n\n$“ 插入匹配的左侧\n\n$” 插入撇右侧\n\n`split()`\n\n切割\n\n1. 用捕获括号的时候会将匹配结果也包含在返回的数组中。\n\n```js\n'hello,javascript'.split(/(,)/);  //[\"hello\", \",\", \"javascript”]\n```\n\n## 正则匹配\n\n1. 精确匹配：/hello/.test('hello')\n2. 模糊匹配: \n3. 排除字符 ^\n4. 分支匹配 |  （惰性）\n5. 分组匹配 ()\n6. 分组引用  $1 $2 \n7. 反向引用  \\1 \\2\n（正则本身引用分组，但只能引用之前出现的分组）\n    1. 括号以左开括号为准\n    2. 引用不存在的分组，正则不会报错，只是匹配反向引用的字符串本身\n    3. 反向分组后面量词的话，反向分组最终捕获到数据是最后一粒匹配： const reg = /(\\d)+ \\1/;  '12345 1'.match(reg)\n8. 位置匹配\n9. 贪婪模式（默认）\n10. 非贪婪模式  \n    再限定符后面加 ? \n11. 捕获分组  ()\n12. 非捕获分组  (?:)\n\n## 常用的正则\n\n1. 匹配汉字：`^[\\u4e00-\\u9fa5]{0,}$`\n2. Email地址：`^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$`\n3. 日期格式：`^\\d{4}-\\d{1,2}-\\d{1,2}`\n4. 时间：` /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/`\n5. 一年的12个月 ` (01～09和1～12)：^(0?[1-9]|1[0-2])$`\n6. 一个月的31天 `(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ `\n7. 中国邮政编码：` [1-9]\\d{5}(?!\\d)`\n8. IP地址：`((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))`\n9. 匹配id: `'<div id=\"container\" class=\"main\"></div>’.match(/id=\"[^\"]*\"/ ) `;\n10. 格式化货币：`function format (num) { return num.toFixed(2).replace(/\\B(?=(\\d{3})+\\b)/, \",\").replace(/^/, \"$$ \"); };` \n11. 去掉左右空格： `' javascript   '.replace(/^\\s+|\\s+$/g, ''); `\n12. 每个单词的首字母转换为大写 ： `function format(str) { return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) { return c.toUpperCase(); }); } `\n13. 匹配标签： `\"aaa<title>hello</title>\" .match(/<([^>]+)>[\\d\\D]*<\\/\\1>/)`\n14. 身份证号码：`/^(\\d{15}|\\d{17}[\\dxX])$/`\n\n## 正则的回溯\n\n```js\n'\"abc\"de'.match(/\".*\"/)\n```\n\n<img  src=\"/images/reg/huisu.png\" />\n\n## 正则效率\n\n1. 使用确定的字符直接匹配\n2. 使用非捕获分组（省内存）\n3. 减少分支数量，缩减范围：/red|read/ 改为 /rea?d/\n4. 正则效率和正则可读性需要做一个取舍\n","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2018-09-28 10:38:45\ntags: js\n---\n\n## 正则生成\n\n 1. new RegExp 对象的构造函数\n \n` var reg = new RegExp('^[a-z]$', 'gi')`\n\n2. 字面量形式：\n\n` var reg = /^[a-z]$/gi `\n\n## 正则的组成\n\n#### 元字符\n1. 匹配字符\n\n\n.   出来换行(\\n)以外的所有字符\n\n\\w  匹配字母、数字、下划线\n\n\\W  匹配除了字母、数字、下划线\n\n\\d  匹配数字 \n\n\\D  匹配除了数字以外其他字符\n\n\\s  匹配仍以的空白符（空格、\\t \\v \\n \\r \\f 制表符）\n\n\\S  匹配空白符意外的任意字符\n\n2. 匹配位置\n\n\n\\b  匹配单词开始和结束的位置（\\w 和 \\W 之间的位置）\n\n\\B  匹配单词的非开始或者结束位置\n\n^   匹配行首位置\n\n$   匹配行尾位置\n\n(?=p) 该位置后面字符要匹配 p  \n\n(?!p) 该位置后面字符不匹配 p\n\n\n#### 标志字符\nm   多行（multi line）\n\ng   全局（global）\n\ni   不区分大小写（ignore）\n\n例如：\n```js\nvar reg = /^abc/;\nvar str = 'test\\nabc'; // 匹配不上，因为 \\n 是换行，不能匹配多行\n\nvar reg = /^abc/m;\nvar str = 'test\\nabc';  // 匹配上\n\n```\n\n#### 限定符\n\n` * `     匹配 0 次以上\n\n`+`       匹配 1 次以上\n\n`?`       0 次或 1 次\n\n`{m}`     匹配 m 次\n\n`{ m, }`  至少匹配 m 次\n\n`{m, n}`  至少 m 次，最多 n 次\n\n#### 转义字符\n\n`*+?|\\/{}[]()^$` 需要 \\ 进行转义\n\n\n## 正则方法\n\n#### 正则实例\n\n1. ` test()`\n参数为 string，返回值为 boolean\n\n例如：\n```js\n/javascript/.test(\"dadjavascript\");  //  true\n```\n\n2. `exec()`\n\n参数string，返回 [] ，存放匹配结果，如果没有匹配上返回 null\n\n例如:\n\n```js\nvar string = \"a and b and c\";\nvar reg = /(a and)?(b and)?c/;\n\nreg.exec(string);\n\n结果：\n[\"a and b and c\", \"a and \", \"b and \"]\n```\n返回值忠包含另外两个属性：index 和 input\n\nindex 表示匹配项在字符串中的位置。（上面代码匹配项为 short ，对应的位置 是16）;\n\ninput 表示应用正则表达式的字符串\n\n3. `lastIndex`  \n\n匹配的位置，可读可写\n\n\n> 注意：\n> 重复执行 `test()` ，他会记住匹配的位置，从上一次匹配的位置继续匹配\n\n1. 不具有标志 g 和不表示全局模式的正则对象不能使用 lastIndex 属性\n```js\n var reg = /abc/;\n var str = '1#abc+abc';\n console.log(rgb.test(str));   //true\n console.log(rgb.lastIndex);   // 0\n console.log(rgb.test(str));   // true\n console.log(rgb.lastIndex);   // 0\n console.log(rgb.test(str));   // true \n```\n\n2. lastIndex 用于规定下次匹配的起始位置\n\n```js\nvar reg = /abc/g;\n var str = '1#abc+abc';\n var str2 = '2abc';\n console.log(rgb.test(str));    //true\n console.log(rgb.lastIndex);    // 5\n console.log(rgb.test(str));    // true\n console.log(rgb.lastIndex);    // 9\n console.log(rgb.test(str2));   // false  最后没有了，所以匹配不上了\n```\n\n3. 如果再成功匹配字符串之后，想要重新匹配新的字符串，需要将该属性设置成 0\n```js \n var reg = /abc/g; \n var str = '1#abc+abc';\n var str2 = '2#abc';\n console.log(reg.test(str));   // true\n console.log(reg.lastIndex);   // 5\n console.log(reg.test(str2));  // false\n console.log(reg.lastIndex);   // 0\n```\n\n#### 字符串实例\n\n`search()`\n参数：需要检索的字串 / 正则对象\n\n返回值：-1 / 字符串忠 <b>第一个</b>预正则相匹配的字串的位置\n\n1. 不执行全局匹配，忽略 g\n2. 不能使用 lastIndex\n3. 总是从字符串开始进行检索\n\n```js\n'hello,javascript'.search('javascript');              //6     \n'hello,javascript'.search(/javascript/);               //6       \n'hello,javascript,javascript'.search(/javascript/g);   //6\n```\n\n`match()`\n\n参数：需要检索的字串 / 正则对象\n\n返回值： array / null\n\n1. 如果正则没有 g ，字符串只会匹配一次\n2. 如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到被检索字符串中的所有匹配的子串，它       的数组元素中存放的是被检索字符串中所有的匹配的子串，而且也没有 index 属性或 input 属性；\n\n\n```js\n'hello,javascript'.match('javascript');\n'hello,javascript'.match(/javascript/);\n```\n\n<img src=\"/images/reg/match.png\"/>\n<!-- ![](/images/hexo-page.png) -->\n\n`replace()`\n\n替换\n\n参数：\n1. 被替换的文本（字符串/正则）\n2. 替换成的文本（字符串/函数），如果是字符串，可以用特殊变量来代替\n\n返回值：替换后的字符串\n\n例如：\n```js\n'hello, javascript'.replace(' javascript', 'nodejs');\n'hello,javascript'.replace(/javascript/, 'nodeJs');\n'javascript nodejs'.replace(/(\\w+)\\s(\\w+)/, \"$2 $1\")\n'javascript nodejs'.replace(/(\\w+)\\s(\\w+)/, function( match, p1, p2, offset, string ){\n    // match: 匹配的字串\n    // p1, p2... 对应 $1 $2\n    // offset 匹配的字符串忠的偏移量\n    // string： 被匹配的字符串\n    console.log(match, '---', p1, p2, offset, string);\n    return [p1, p2].join('-')\n})\n```\n\n$$ 插入 $\n\n$& 插入匹配的字串\n\n$“ 插入匹配的左侧\n\n$” 插入撇右侧\n\n`split()`\n\n切割\n\n1. 用捕获括号的时候会将匹配结果也包含在返回的数组中。\n\n```js\n'hello,javascript'.split(/(,)/);  //[\"hello\", \",\", \"javascript”]\n```\n\n## 正则匹配\n\n1. 精确匹配：/hello/.test('hello')\n2. 模糊匹配: \n3. 排除字符 ^\n4. 分支匹配 |  （惰性）\n5. 分组匹配 ()\n6. 分组引用  $1 $2 \n7. 反向引用  \\1 \\2\n（正则本身引用分组，但只能引用之前出现的分组）\n    1. 括号以左开括号为准\n    2. 引用不存在的分组，正则不会报错，只是匹配反向引用的字符串本身\n    3. 反向分组后面量词的话，反向分组最终捕获到数据是最后一粒匹配： const reg = /(\\d)+ \\1/;  '12345 1'.match(reg)\n8. 位置匹配\n9. 贪婪模式（默认）\n10. 非贪婪模式  \n    再限定符后面加 ? \n11. 捕获分组  ()\n12. 非捕获分组  (?:)\n\n## 常用的正则\n\n1. 匹配汉字：`^[\\u4e00-\\u9fa5]{0,}$`\n2. Email地址：`^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$`\n3. 日期格式：`^\\d{4}-\\d{1,2}-\\d{1,2}`\n4. 时间：` /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/`\n5. 一年的12个月 ` (01～09和1～12)：^(0?[1-9]|1[0-2])$`\n6. 一个月的31天 `(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ `\n7. 中国邮政编码：` [1-9]\\d{5}(?!\\d)`\n8. IP地址：`((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))`\n9. 匹配id: `'<div id=\"container\" class=\"main\"></div>’.match(/id=\"[^\"]*\"/ ) `;\n10. 格式化货币：`function format (num) { return num.toFixed(2).replace(/\\B(?=(\\d{3})+\\b)/, \",\").replace(/^/, \"$$ \"); };` \n11. 去掉左右空格： `' javascript   '.replace(/^\\s+|\\s+$/g, ''); `\n12. 每个单词的首字母转换为大写 ： `function format(str) { return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) { return c.toUpperCase(); }); } `\n13. 匹配标签： `\"aaa<title>hello</title>\" .match(/<([^>]+)>[\\d\\D]*<\\/\\1>/)`\n14. 身份证号码：`/^(\\d{15}|\\d{17}[\\dxX])$/`\n\n## 正则的回溯\n\n```js\n'\"abc\"de'.match(/\".*\"/)\n```\n\n<img  src=\"/images/reg/huisu.png\" />\n\n## 正则效率\n\n1. 使用确定的字符直接匹配\n2. 使用非捕获分组（省内存）\n3. 减少分支数量，缩减范围：/red|read/ 改为 /rea?d/\n4. 正则效率和正则可读性需要做一个取舍\n","slug":"正则表达式","published":1,"updated":"2018-09-28T02:41:55.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbl001jfwvprkfnyirt","content":"<h2 id=\"正则生成\"><a href=\"#正则生成\" class=\"headerlink\" title=\"正则生成\"></a>正则生成</h2><ol>\n<li>new RegExp 对象的构造函数</li>\n</ol>\n<p><code>var reg = new RegExp(&#39;^[a-z]$&#39;, &#39;gi&#39;)</code></p>\n<ol start=\"2\">\n<li>字面量形式：</li>\n</ol>\n<p><code>var reg = /^[a-z]$/gi</code></p>\n<h2 id=\"正则的组成\"><a href=\"#正则的组成\" class=\"headerlink\" title=\"正则的组成\"></a>正则的组成</h2><h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><ol>\n<li>匹配字符</li>\n</ol>\n<p>.   出来换行(\\n)以外的所有字符</p>\n<p>\\w  匹配字母、数字、下划线</p>\n<p>\\W  匹配除了字母、数字、下划线</p>\n<p>\\d  匹配数字 </p>\n<p>\\D  匹配除了数字以外其他字符</p>\n<p>\\s  匹配仍以的空白符（空格、\\t \\v \\n \\r \\f 制表符）</p>\n<p>\\S  匹配空白符意外的任意字符</p>\n<ol start=\"2\">\n<li>匹配位置</li>\n</ol>\n<p>\\b  匹配单词开始和结束的位置（\\w 和 \\W 之间的位置）</p>\n<p>\\B  匹配单词的非开始或者结束位置</p>\n<p>^   匹配行首位置</p>\n<p>$   匹配行尾位置</p>\n<p>(?=p) 该位置后面字符要匹配 p  </p>\n<p>(?!p) 该位置后面字符不匹配 p</p>\n<h4 id=\"标志字符\"><a href=\"#标志字符\" class=\"headerlink\" title=\"标志字符\"></a>标志字符</h4><p>m   多行（multi line）</p>\n<p>g   全局（global）</p>\n<p>i   不区分大小写（ignore）</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^abc/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test\\nabc'</span>; <span class=\"comment\">// 匹配不上，因为 \\n 是换行，不能匹配多行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^abc/m</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test\\nabc'</span>;  <span class=\"comment\">// 匹配上</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h4><p><code>*</code>     匹配 0 次以上</p>\n<p><code>+</code>       匹配 1 次以上</p>\n<p><code>?</code>       0 次或 1 次</p>\n<p><code>{m}</code>     匹配 m 次</p>\n<p><code>{ m, }</code>  至少匹配 m 次</p>\n<p><code>{m, n}</code>  至少 m 次，最多 n 次</p>\n<h4 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h4><p><code>*+?|\\/{}[]()^$</code> 需要 \\ 进行转义</p>\n<h2 id=\"正则方法\"><a href=\"#正则方法\" class=\"headerlink\" title=\"正则方法\"></a>正则方法</h2><h4 id=\"正则实例\"><a href=\"#正则实例\" class=\"headerlink\" title=\"正则实例\"></a>正则实例</h4><ol>\n<li><code>test()</code><br>参数为 string，返回值为 boolean</li>\n</ol>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/javascript/.test(<span class=\"string\">\"dadjavascript\"</span>);  <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li><code>exec()</code></li>\n</ol>\n<p>参数string，返回 [] ，存放匹配结果，如果没有匹配上返回 null</p>\n<p>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"a and b and c\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/(a and)?(b and)?c/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">reg.exec(string);</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">[<span class=\"string\">\"a and b and c\"</span>, <span class=\"string\">\"a and \"</span>, <span class=\"string\">\"b and \"</span>]</span><br></pre></td></tr></table></figure>\n<p>返回值忠包含另外两个属性：index 和 input</p>\n<p>index 表示匹配项在字符串中的位置。（上面代码匹配项为 short ，对应的位置 是16）;</p>\n<p>input 表示应用正则表达式的字符串</p>\n<ol start=\"3\">\n<li><code>lastIndex</code>  </li>\n</ol>\n<p>匹配的位置，可读可写</p>\n<blockquote>\n<p>注意：<br>重复执行 <code>test()</code> ，他会记住匹配的位置，从上一次匹配的位置继续匹配</p>\n</blockquote>\n<ol>\n<li><p>不具有标志 g 和不表示全局模式的正则对象不能使用 lastIndex 属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'1#abc+abc'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.test(str));   <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.lastIndex);   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.test(str));   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.lastIndex);   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.test(str));   <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lastIndex 用于规定下次匹配的起始位置</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/g</span>;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> str = <span class=\"string\">'1#abc+abc'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> str2 = <span class=\"string\">'2abc'</span>;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.test(str));    <span class=\"comment\">//true</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.lastIndex);    <span class=\"comment\">// 5</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.test(str));    <span class=\"comment\">// true</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.lastIndex);    <span class=\"comment\">// 9</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.test(str2));   <span class=\"comment\">// false  最后没有了，所以匹配不上了</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>如果再成功匹配字符串之后，想要重新匹配新的字符串，需要将该属性设置成 0<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/g</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'1#abc+abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">'2#abc'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str));   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.lastIndex);   <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str2));  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.lastIndex);   <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"字符串实例\"><a href=\"#字符串实例\" class=\"headerlink\" title=\"字符串实例\"></a>字符串实例</h4><p><code>search()</code><br>参数：需要检索的字串 / 正则对象</p>\n<p>返回值：-1 / 字符串忠 <b>第一个</b>预正则相匹配的字串的位置</p>\n<ol>\n<li>不执行全局匹配，忽略 g</li>\n<li>不能使用 lastIndex</li>\n<li>总是从字符串开始进行检索</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.search(<span class=\"string\">'javascript'</span>);              <span class=\"comment\">//6     </span></span><br><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.search(<span class=\"regexp\">/javascript/</span>);               <span class=\"comment\">//6       </span></span><br><span class=\"line\"><span class=\"string\">'hello,javascript,javascript'</span>.search(<span class=\"regexp\">/javascript/g</span>);   <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<p><code>match()</code></p>\n<p>参数：需要检索的字串 / 正则对象</p>\n<p>返回值： array / null</p>\n<ol>\n<li>如果正则没有 g ，字符串只会匹配一次</li>\n<li>如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到被检索字符串中的所有匹配的子串，它       的数组元素中存放的是被检索字符串中所有的匹配的子串，而且也没有 index 属性或 input 属性；</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.match(<span class=\"string\">'javascript'</span>);</span><br><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.match(<span class=\"regexp\">/javascript/</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/reg/match.png\"><br><!-- ![](/images/hexo-page.png) --></p>\n<p><code>replace()</code></p>\n<p>替换</p>\n<p>参数：</p>\n<ol>\n<li>被替换的文本（字符串/正则）</li>\n<li>替换成的文本（字符串/函数），如果是字符串，可以用特殊变量来代替</li>\n</ol>\n<p>返回值：替换后的字符串</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello, javascript'</span>.replace(<span class=\"string\">' javascript'</span>, <span class=\"string\">'nodejs'</span>);</span><br><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.replace(<span class=\"regexp\">/javascript/</span>, <span class=\"string\">'nodeJs'</span>);</span><br><span class=\"line\"><span class=\"string\">'javascript nodejs'</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>, <span class=\"string\">\"$2 $1\"</span>)</span><br><span class=\"line\"><span class=\"string\">'javascript nodejs'</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> match, p1, p2, offset, string </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// match: 匹配的字串</span></span><br><span class=\"line\">    <span class=\"comment\">// p1, p2... 对应 $1 $2</span></span><br><span class=\"line\">    <span class=\"comment\">// offset 匹配的字符串忠的偏移量</span></span><br><span class=\"line\">    <span class=\"comment\">// string： 被匹配的字符串</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(match, <span class=\"string\">'---'</span>, p1, p2, offset, string);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [p1, p2].join(<span class=\"string\">'-'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>$$ 插入 $</p>\n<p>$&amp; 插入匹配的字串</p>\n<p>$“ 插入匹配的左侧</p>\n<p>$” 插入撇右侧</p>\n<p><code>split()</code></p>\n<p>切割</p>\n<ol>\n<li>用捕获括号的时候会将匹配结果也包含在返回的数组中。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.split(<span class=\"regexp\">/(,)/</span>);  <span class=\"comment\">//[\"hello\", \",\", \"javascript”]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h2><ol>\n<li>精确匹配：/hello/.test(‘hello’)</li>\n<li>模糊匹配: </li>\n<li>排除字符 ^</li>\n<li>分支匹配 |  （惰性）</li>\n<li>分组匹配 ()</li>\n<li>分组引用  $1 $2 </li>\n<li>反向引用  \\1 \\2<br>（正则本身引用分组，但只能引用之前出现的分组）<ol>\n<li>括号以左开括号为准</li>\n<li>引用不存在的分组，正则不会报错，只是匹配反向引用的字符串本身</li>\n<li>反向分组后面量词的话，反向分组最终捕获到数据是最后一粒匹配： const reg = /(\\d)+ \\1/;  ‘12345 1’.match(reg)</li>\n</ol>\n</li>\n<li>位置匹配</li>\n<li>贪婪模式（默认）</li>\n<li>非贪婪模式<br>再限定符后面加 ? </li>\n<li>捕获分组  ()</li>\n<li>非捕获分组  (?:)</li>\n</ol>\n<h2 id=\"常用的正则\"><a href=\"#常用的正则\" class=\"headerlink\" title=\"常用的正则\"></a>常用的正则</h2><ol>\n<li>匹配汉字：<code>^[\\u4e00-\\u9fa5]{0,}$</code></li>\n<li>Email地址：<code>^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$</code></li>\n<li>日期格式：<code>^\\d{4}-\\d{1,2}-\\d{1,2}</code></li>\n<li>时间：<code>/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</code></li>\n<li>一年的12个月 <code>(01～09和1～12)：^(0?[1-9]|1[0-2])$</code></li>\n<li>一个月的31天 <code>(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>\n<li>中国邮政编码：<code>[1-9]\\d{5}(?!\\d)</code></li>\n<li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</code></li>\n<li>匹配id: <code>&#39;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;’.match(/id=&quot;[^&quot;]*&quot;/ )</code>;</li>\n<li>格式化货币：<code>function format (num) { return num.toFixed(2).replace(/\\B(?=(\\d{3})+\\b)/, &quot;,&quot;).replace(/^/, &quot;$$ &quot;); };</code> </li>\n<li>去掉左右空格： <code>&#39; javascript   &#39;.replace(/^\\s+|\\s+$/g, &#39;&#39;);</code></li>\n<li>每个单词的首字母转换为大写 ： <code>function format(str) { return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) { return c.toUpperCase(); }); }</code></li>\n<li>匹配标签： <code>&quot;aaa&lt;title&gt;hello&lt;/title&gt;&quot; .match(/&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/)</code></li>\n<li>身份证号码：<code>/^(\\d{15}|\\d{17}[\\dxX])$/</code></li>\n</ol>\n<h2 id=\"正则的回溯\"><a href=\"#正则的回溯\" class=\"headerlink\" title=\"正则的回溯\"></a>正则的回溯</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'\"abc\"de'</span>.match(<span class=\"regexp\">/\".*\"/</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/reg/huisu.png\"></p>\n<h2 id=\"正则效率\"><a href=\"#正则效率\" class=\"headerlink\" title=\"正则效率\"></a>正则效率</h2><ol>\n<li>使用确定的字符直接匹配</li>\n<li>使用非捕获分组（省内存）</li>\n<li>减少分支数量，缩减范围：/red|read/ 改为 /rea?d/</li>\n<li>正则效率和正则可读性需要做一个取舍</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"正则生成\"><a href=\"#正则生成\" class=\"headerlink\" title=\"正则生成\"></a>正则生成</h2><ol>\n<li>new RegExp 对象的构造函数</li>\n</ol>\n<p><code>var reg = new RegExp(&#39;^[a-z]$&#39;, &#39;gi&#39;)</code></p>\n<ol start=\"2\">\n<li>字面量形式：</li>\n</ol>\n<p><code>var reg = /^[a-z]$/gi</code></p>\n<h2 id=\"正则的组成\"><a href=\"#正则的组成\" class=\"headerlink\" title=\"正则的组成\"></a>正则的组成</h2><h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><ol>\n<li>匹配字符</li>\n</ol>\n<p>.   出来换行(\\n)以外的所有字符</p>\n<p>\\w  匹配字母、数字、下划线</p>\n<p>\\W  匹配除了字母、数字、下划线</p>\n<p>\\d  匹配数字 </p>\n<p>\\D  匹配除了数字以外其他字符</p>\n<p>\\s  匹配仍以的空白符（空格、\\t \\v \\n \\r \\f 制表符）</p>\n<p>\\S  匹配空白符意外的任意字符</p>\n<ol start=\"2\">\n<li>匹配位置</li>\n</ol>\n<p>\\b  匹配单词开始和结束的位置（\\w 和 \\W 之间的位置）</p>\n<p>\\B  匹配单词的非开始或者结束位置</p>\n<p>^   匹配行首位置</p>\n<p>$   匹配行尾位置</p>\n<p>(?=p) 该位置后面字符要匹配 p  </p>\n<p>(?!p) 该位置后面字符不匹配 p</p>\n<h4 id=\"标志字符\"><a href=\"#标志字符\" class=\"headerlink\" title=\"标志字符\"></a>标志字符</h4><p>m   多行（multi line）</p>\n<p>g   全局（global）</p>\n<p>i   不区分大小写（ignore）</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^abc/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test\\nabc'</span>; <span class=\"comment\">// 匹配不上，因为 \\n 是换行，不能匹配多行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^abc/m</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test\\nabc'</span>;  <span class=\"comment\">// 匹配上</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h4><p><code>*</code>     匹配 0 次以上</p>\n<p><code>+</code>       匹配 1 次以上</p>\n<p><code>?</code>       0 次或 1 次</p>\n<p><code>{m}</code>     匹配 m 次</p>\n<p><code>{ m, }</code>  至少匹配 m 次</p>\n<p><code>{m, n}</code>  至少 m 次，最多 n 次</p>\n<h4 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h4><p><code>*+?|\\/{}[]()^$</code> 需要 \\ 进行转义</p>\n<h2 id=\"正则方法\"><a href=\"#正则方法\" class=\"headerlink\" title=\"正则方法\"></a>正则方法</h2><h4 id=\"正则实例\"><a href=\"#正则实例\" class=\"headerlink\" title=\"正则实例\"></a>正则实例</h4><ol>\n<li><code>test()</code><br>参数为 string，返回值为 boolean</li>\n</ol>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/javascript/.test(<span class=\"string\">\"dadjavascript\"</span>);  <span class=\"comment\">//  true</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li><code>exec()</code></li>\n</ol>\n<p>参数string，返回 [] ，存放匹配结果，如果没有匹配上返回 null</p>\n<p>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"a and b and c\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/(a and)?(b and)?c/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">reg.exec(string);</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">[<span class=\"string\">\"a and b and c\"</span>, <span class=\"string\">\"a and \"</span>, <span class=\"string\">\"b and \"</span>]</span><br></pre></td></tr></table></figure>\n<p>返回值忠包含另外两个属性：index 和 input</p>\n<p>index 表示匹配项在字符串中的位置。（上面代码匹配项为 short ，对应的位置 是16）;</p>\n<p>input 表示应用正则表达式的字符串</p>\n<ol start=\"3\">\n<li><code>lastIndex</code>  </li>\n</ol>\n<p>匹配的位置，可读可写</p>\n<blockquote>\n<p>注意：<br>重复执行 <code>test()</code> ，他会记住匹配的位置，从上一次匹配的位置继续匹配</p>\n</blockquote>\n<ol>\n<li><p>不具有标志 g 和不表示全局模式的正则对象不能使用 lastIndex 属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'1#abc+abc'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.test(str));   <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.lastIndex);   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.test(str));   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.lastIndex);   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rgb.test(str));   <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lastIndex 用于规定下次匹配的起始位置</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/g</span>;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> str = <span class=\"string\">'1#abc+abc'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> str2 = <span class=\"string\">'2abc'</span>;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.test(str));    <span class=\"comment\">//true</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.lastIndex);    <span class=\"comment\">// 5</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.test(str));    <span class=\"comment\">// true</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.lastIndex);    <span class=\"comment\">// 9</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rgb.test(str2));   <span class=\"comment\">// false  最后没有了，所以匹配不上了</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>如果再成功匹配字符串之后，想要重新匹配新的字符串，需要将该属性设置成 0<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/g</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'1#abc+abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">'2#abc'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str));   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.lastIndex);   <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str2));  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reg.lastIndex);   <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"字符串实例\"><a href=\"#字符串实例\" class=\"headerlink\" title=\"字符串实例\"></a>字符串实例</h4><p><code>search()</code><br>参数：需要检索的字串 / 正则对象</p>\n<p>返回值：-1 / 字符串忠 <b>第一个</b>预正则相匹配的字串的位置</p>\n<ol>\n<li>不执行全局匹配，忽略 g</li>\n<li>不能使用 lastIndex</li>\n<li>总是从字符串开始进行检索</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.search(<span class=\"string\">'javascript'</span>);              <span class=\"comment\">//6     </span></span><br><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.search(<span class=\"regexp\">/javascript/</span>);               <span class=\"comment\">//6       </span></span><br><span class=\"line\"><span class=\"string\">'hello,javascript,javascript'</span>.search(<span class=\"regexp\">/javascript/g</span>);   <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<p><code>match()</code></p>\n<p>参数：需要检索的字串 / 正则对象</p>\n<p>返回值： array / null</p>\n<ol>\n<li>如果正则没有 g ，字符串只会匹配一次</li>\n<li>如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到被检索字符串中的所有匹配的子串，它       的数组元素中存放的是被检索字符串中所有的匹配的子串，而且也没有 index 属性或 input 属性；</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.match(<span class=\"string\">'javascript'</span>);</span><br><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.match(<span class=\"regexp\">/javascript/</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/reg/match.png\"><br><!-- ![](/images/hexo-page.png) --></p>\n<p><code>replace()</code></p>\n<p>替换</p>\n<p>参数：</p>\n<ol>\n<li>被替换的文本（字符串/正则）</li>\n<li>替换成的文本（字符串/函数），如果是字符串，可以用特殊变量来代替</li>\n</ol>\n<p>返回值：替换后的字符串</p>\n<p>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello, javascript'</span>.replace(<span class=\"string\">' javascript'</span>, <span class=\"string\">'nodejs'</span>);</span><br><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.replace(<span class=\"regexp\">/javascript/</span>, <span class=\"string\">'nodeJs'</span>);</span><br><span class=\"line\"><span class=\"string\">'javascript nodejs'</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>, <span class=\"string\">\"$2 $1\"</span>)</span><br><span class=\"line\"><span class=\"string\">'javascript nodejs'</span>.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> match, p1, p2, offset, string </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// match: 匹配的字串</span></span><br><span class=\"line\">    <span class=\"comment\">// p1, p2... 对应 $1 $2</span></span><br><span class=\"line\">    <span class=\"comment\">// offset 匹配的字符串忠的偏移量</span></span><br><span class=\"line\">    <span class=\"comment\">// string： 被匹配的字符串</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(match, <span class=\"string\">'---'</span>, p1, p2, offset, string);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [p1, p2].join(<span class=\"string\">'-'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>$$ 插入 $</p>\n<p>$&amp; 插入匹配的字串</p>\n<p>$“ 插入匹配的左侧</p>\n<p>$” 插入撇右侧</p>\n<p><code>split()</code></p>\n<p>切割</p>\n<ol>\n<li>用捕获括号的时候会将匹配结果也包含在返回的数组中。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'hello,javascript'</span>.split(<span class=\"regexp\">/(,)/</span>);  <span class=\"comment\">//[\"hello\", \",\", \"javascript”]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h2><ol>\n<li>精确匹配：/hello/.test(‘hello’)</li>\n<li>模糊匹配: </li>\n<li>排除字符 ^</li>\n<li>分支匹配 |  （惰性）</li>\n<li>分组匹配 ()</li>\n<li>分组引用  $1 $2 </li>\n<li>反向引用  \\1 \\2<br>（正则本身引用分组，但只能引用之前出现的分组）<ol>\n<li>括号以左开括号为准</li>\n<li>引用不存在的分组，正则不会报错，只是匹配反向引用的字符串本身</li>\n<li>反向分组后面量词的话，反向分组最终捕获到数据是最后一粒匹配： const reg = /(\\d)+ \\1/;  ‘12345 1’.match(reg)</li>\n</ol>\n</li>\n<li>位置匹配</li>\n<li>贪婪模式（默认）</li>\n<li>非贪婪模式<br>再限定符后面加 ? </li>\n<li>捕获分组  ()</li>\n<li>非捕获分组  (?:)</li>\n</ol>\n<h2 id=\"常用的正则\"><a href=\"#常用的正则\" class=\"headerlink\" title=\"常用的正则\"></a>常用的正则</h2><ol>\n<li>匹配汉字：<code>^[\\u4e00-\\u9fa5]{0,}$</code></li>\n<li>Email地址：<code>^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$</code></li>\n<li>日期格式：<code>^\\d{4}-\\d{1,2}-\\d{1,2}</code></li>\n<li>时间：<code>/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</code></li>\n<li>一年的12个月 <code>(01～09和1～12)：^(0?[1-9]|1[0-2])$</code></li>\n<li>一个月的31天 <code>(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>\n<li>中国邮政编码：<code>[1-9]\\d{5}(?!\\d)</code></li>\n<li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</code></li>\n<li>匹配id: <code>&#39;&lt;div id=&quot;container&quot; class=&quot;main&quot;&gt;&lt;/div&gt;’.match(/id=&quot;[^&quot;]*&quot;/ )</code>;</li>\n<li>格式化货币：<code>function format (num) { return num.toFixed(2).replace(/\\B(?=(\\d{3})+\\b)/, &quot;,&quot;).replace(/^/, &quot;$$ &quot;); };</code> </li>\n<li>去掉左右空格： <code>&#39; javascript   &#39;.replace(/^\\s+|\\s+$/g, &#39;&#39;);</code></li>\n<li>每个单词的首字母转换为大写 ： <code>function format(str) { return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) { return c.toUpperCase(); }); }</code></li>\n<li>匹配标签： <code>&quot;aaa&lt;title&gt;hello&lt;/title&gt;&quot; .match(/&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/)</code></li>\n<li>身份证号码：<code>/^(\\d{15}|\\d{17}[\\dxX])$/</code></li>\n</ol>\n<h2 id=\"正则的回溯\"><a href=\"#正则的回溯\" class=\"headerlink\" title=\"正则的回溯\"></a>正则的回溯</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'\"abc\"de'</span>.match(<span class=\"regexp\">/\".*\"/</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/reg/huisu.png\"></p>\n<h2 id=\"正则效率\"><a href=\"#正则效率\" class=\"headerlink\" title=\"正则效率\"></a>正则效率</h2><ol>\n<li>使用确定的字符直接匹配</li>\n<li>使用非捕获分组（省内存）</li>\n<li>减少分支数量，缩减范围：/red|read/ 改为 /rea?d/</li>\n<li>正则效率和正则可读性需要做一个取舍</li>\n</ol>\n"},{"title":"浏览器内核","date":"2018-07-04T14:40:26.000Z","_content":"\n## 浏览器内核介绍\n所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br />\n浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br />\n我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。\n\n## 常见的浏览器内核有哪些？\n\n- Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]\n- Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等\n- Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]\n- Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]","source":"_posts/浏览器内核.md","raw":"---\ntitle: 浏览器内核\ndate: 2018-07-04 22:40:26\ntags: 浏览器\n---\n\n## 浏览器内核介绍\n所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br />\n浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br />\n我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。\n\n## 常见的浏览器内核有哪些？\n\n- Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]\n- Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等\n- Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]\n- Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]","slug":"浏览器内核","published":1,"updated":"2018-09-15T02:18:11.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbn001mfwvp3xvcs2ce","content":"<h2 id=\"浏览器内核介绍\"><a href=\"#浏览器内核介绍\" class=\"headerlink\" title=\"浏览器内核介绍\"></a>浏览器内核介绍</h2><p>所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br><br>浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br><br>我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><ul>\n<li>Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]</li>\n<li>Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等</li>\n<li>Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]</li>\n<li>Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器内核介绍\"><a href=\"#浏览器内核介绍\" class=\"headerlink\" title=\"浏览器内核介绍\"></a>浏览器内核介绍</h2><p>所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br><br>浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br><br>我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><ul>\n<li>Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]</li>\n<li>Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等</li>\n<li>Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]</li>\n<li>Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]</li>\n</ul>\n"},{"title":"网址总结","date":"2018-08-09T09:49:22.000Z","_content":"\n## 图片\n\n##### 1. 压缩图片\nhttps://img.top/\n\n## 下载\n##### 1.  Mac 下载破解版客户端\nhttp://xclient.info/s/c/design/?t=1cfbe7ef21f518706ece0f257a74dd1a4a940299\n\n## 笔记\n##### 1. 印象笔记\nhttps://app.yinxiang.com/\n\n##### 2. Bear\nhttp://www.bear-writer.com/\n\n\n## 设计素材\n##### 1. 设计飞机稿\nhttps://www.ui8.net/\n\n##### 2. 设计相关推荐网站\nhttp://so.uigreat.com/\n\n##### 3. 优波\nhttps://ubuuk.com/\n\n## 设计前端交互工具\n##### 1. 蓝狐\nhttps://lanhuapp.com/\n\n##### 2. Zeplin\nhttps://zeplin.io/\n\n## 其他工具\n##### 1. foxmail 邮箱\nhttp://www.foxmail.com/\n\n","source":"_posts/网址集合.md","raw":"---\ntitle: 网址总结\ndate: 2018-08-09 17:49:22\ntags: 其他\n---\n\n## 图片\n\n##### 1. 压缩图片\nhttps://img.top/\n\n## 下载\n##### 1.  Mac 下载破解版客户端\nhttp://xclient.info/s/c/design/?t=1cfbe7ef21f518706ece0f257a74dd1a4a940299\n\n## 笔记\n##### 1. 印象笔记\nhttps://app.yinxiang.com/\n\n##### 2. Bear\nhttp://www.bear-writer.com/\n\n\n## 设计素材\n##### 1. 设计飞机稿\nhttps://www.ui8.net/\n\n##### 2. 设计相关推荐网站\nhttp://so.uigreat.com/\n\n##### 3. 优波\nhttps://ubuuk.com/\n\n## 设计前端交互工具\n##### 1. 蓝狐\nhttps://lanhuapp.com/\n\n##### 2. Zeplin\nhttps://zeplin.io/\n\n## 其他工具\n##### 1. foxmail 邮箱\nhttp://www.foxmail.com/\n\n","slug":"网址集合","published":1,"updated":"2018-09-15T02:18:11.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbo001ofwvpxtj6ocrr","content":"<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><h5 id=\"1-压缩图片\"><a href=\"#1-压缩图片\" class=\"headerlink\" title=\"1. 压缩图片\"></a>1. 压缩图片</h5><p><a href=\"https://img.top/\" target=\"_blank\" rel=\"noopener\">https://img.top/</a></p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><h5 id=\"1-Mac-下载破解版客户端\"><a href=\"#1-Mac-下载破解版客户端\" class=\"headerlink\" title=\"1.  Mac 下载破解版客户端\"></a>1.  Mac 下载破解版客户端</h5><p><a href=\"http://xclient.info/s/c/design/?t=1cfbe7ef21f518706ece0f257a74dd1a4a940299\" target=\"_blank\" rel=\"noopener\">http://xclient.info/s/c/design/?t=1cfbe7ef21f518706ece0f257a74dd1a4a940299</a></p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h5 id=\"1-印象笔记\"><a href=\"#1-印象笔记\" class=\"headerlink\" title=\"1. 印象笔记\"></a>1. 印象笔记</h5><p><a href=\"https://app.yinxiang.com/\" target=\"_blank\" rel=\"noopener\">https://app.yinxiang.com/</a></p>\n<h5 id=\"2-Bear\"><a href=\"#2-Bear\" class=\"headerlink\" title=\"2. Bear\"></a>2. Bear</h5><p><a href=\"http://www.bear-writer.com/\" target=\"_blank\" rel=\"noopener\">http://www.bear-writer.com/</a></p>\n<h2 id=\"设计素材\"><a href=\"#设计素材\" class=\"headerlink\" title=\"设计素材\"></a>设计素材</h2><h5 id=\"1-设计飞机稿\"><a href=\"#1-设计飞机稿\" class=\"headerlink\" title=\"1. 设计飞机稿\"></a>1. 设计飞机稿</h5><p><a href=\"https://www.ui8.net/\" target=\"_blank\" rel=\"noopener\">https://www.ui8.net/</a></p>\n<h5 id=\"2-设计相关推荐网站\"><a href=\"#2-设计相关推荐网站\" class=\"headerlink\" title=\"2. 设计相关推荐网站\"></a>2. 设计相关推荐网站</h5><p><a href=\"http://so.uigreat.com/\" target=\"_blank\" rel=\"noopener\">http://so.uigreat.com/</a></p>\n<h5 id=\"3-优波\"><a href=\"#3-优波\" class=\"headerlink\" title=\"3. 优波\"></a>3. 优波</h5><p><a href=\"https://ubuuk.com/\" target=\"_blank\" rel=\"noopener\">https://ubuuk.com/</a></p>\n<h2 id=\"设计前端交互工具\"><a href=\"#设计前端交互工具\" class=\"headerlink\" title=\"设计前端交互工具\"></a>设计前端交互工具</h2><h5 id=\"1-蓝狐\"><a href=\"#1-蓝狐\" class=\"headerlink\" title=\"1. 蓝狐\"></a>1. 蓝狐</h5><p><a href=\"https://lanhuapp.com/\" target=\"_blank\" rel=\"noopener\">https://lanhuapp.com/</a></p>\n<h5 id=\"2-Zeplin\"><a href=\"#2-Zeplin\" class=\"headerlink\" title=\"2. Zeplin\"></a>2. Zeplin</h5><p><a href=\"https://zeplin.io/\" target=\"_blank\" rel=\"noopener\">https://zeplin.io/</a></p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><h5 id=\"1-foxmail-邮箱\"><a href=\"#1-foxmail-邮箱\" class=\"headerlink\" title=\"1. foxmail 邮箱\"></a>1. foxmail 邮箱</h5><p><a href=\"http://www.foxmail.com/\" target=\"_blank\" rel=\"noopener\">http://www.foxmail.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><h5 id=\"1-压缩图片\"><a href=\"#1-压缩图片\" class=\"headerlink\" title=\"1. 压缩图片\"></a>1. 压缩图片</h5><p><a href=\"https://img.top/\" target=\"_blank\" rel=\"noopener\">https://img.top/</a></p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><h5 id=\"1-Mac-下载破解版客户端\"><a href=\"#1-Mac-下载破解版客户端\" class=\"headerlink\" title=\"1.  Mac 下载破解版客户端\"></a>1.  Mac 下载破解版客户端</h5><p><a href=\"http://xclient.info/s/c/design/?t=1cfbe7ef21f518706ece0f257a74dd1a4a940299\" target=\"_blank\" rel=\"noopener\">http://xclient.info/s/c/design/?t=1cfbe7ef21f518706ece0f257a74dd1a4a940299</a></p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h5 id=\"1-印象笔记\"><a href=\"#1-印象笔记\" class=\"headerlink\" title=\"1. 印象笔记\"></a>1. 印象笔记</h5><p><a href=\"https://app.yinxiang.com/\" target=\"_blank\" rel=\"noopener\">https://app.yinxiang.com/</a></p>\n<h5 id=\"2-Bear\"><a href=\"#2-Bear\" class=\"headerlink\" title=\"2. Bear\"></a>2. Bear</h5><p><a href=\"http://www.bear-writer.com/\" target=\"_blank\" rel=\"noopener\">http://www.bear-writer.com/</a></p>\n<h2 id=\"设计素材\"><a href=\"#设计素材\" class=\"headerlink\" title=\"设计素材\"></a>设计素材</h2><h5 id=\"1-设计飞机稿\"><a href=\"#1-设计飞机稿\" class=\"headerlink\" title=\"1. 设计飞机稿\"></a>1. 设计飞机稿</h5><p><a href=\"https://www.ui8.net/\" target=\"_blank\" rel=\"noopener\">https://www.ui8.net/</a></p>\n<h5 id=\"2-设计相关推荐网站\"><a href=\"#2-设计相关推荐网站\" class=\"headerlink\" title=\"2. 设计相关推荐网站\"></a>2. 设计相关推荐网站</h5><p><a href=\"http://so.uigreat.com/\" target=\"_blank\" rel=\"noopener\">http://so.uigreat.com/</a></p>\n<h5 id=\"3-优波\"><a href=\"#3-优波\" class=\"headerlink\" title=\"3. 优波\"></a>3. 优波</h5><p><a href=\"https://ubuuk.com/\" target=\"_blank\" rel=\"noopener\">https://ubuuk.com/</a></p>\n<h2 id=\"设计前端交互工具\"><a href=\"#设计前端交互工具\" class=\"headerlink\" title=\"设计前端交互工具\"></a>设计前端交互工具</h2><h5 id=\"1-蓝狐\"><a href=\"#1-蓝狐\" class=\"headerlink\" title=\"1. 蓝狐\"></a>1. 蓝狐</h5><p><a href=\"https://lanhuapp.com/\" target=\"_blank\" rel=\"noopener\">https://lanhuapp.com/</a></p>\n<h5 id=\"2-Zeplin\"><a href=\"#2-Zeplin\" class=\"headerlink\" title=\"2. Zeplin\"></a>2. Zeplin</h5><p><a href=\"https://zeplin.io/\" target=\"_blank\" rel=\"noopener\">https://zeplin.io/</a></p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><h5 id=\"1-foxmail-邮箱\"><a href=\"#1-foxmail-邮箱\" class=\"headerlink\" title=\"1. foxmail 邮箱\"></a>1. foxmail 邮箱</h5><p><a href=\"http://www.foxmail.com/\" target=\"_blank\" rel=\"noopener\">http://www.foxmail.com/</a></p>\n"},{"title":"解决跨域的 10 种方法","date":"2018-06-11T14:40:49.000Z","_content":"\n## 单向跨域\n\n### 一、 JSONP（JSON with Padding）\n\nhtml中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源\n\n例子：\n【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数\n\n优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。\n缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。\n\n### 二、flash URLloader\n\nflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。\n\n例子：\n从域 www.a.com 请求域 www.b.com 上的数据，我们可以借助 flash 来发送 HTTP 请求。\n1. 修改域 www.b.com 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 www.a.com 加入到白名单。\n2. 通过 Flash URLLoader 发送 HTTP 请求。\n3. 通过 Flash API 把响应结果传递给 JavaScript。\n\n缺点：不支持 IOS\n\n### 三、Access Control\n\nAccess Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。\n\n例子：\nwww.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\n\n缺点：目前只在很少的浏览器中得以支持，\n\n\n### 四、window.name\n\nwindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。\n\n例子：\n在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。\n\n优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。\n\n### 五、server proxy\n\n在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。\n\n例子：\n当 www.a.com 域下的页面需要请求 www.b.com 下的资源文件 asset.txt 时，直接发送一个指向 www.b.com/asset.txt 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 www.a.com 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 www.a.com/proxy/ , 然后这个代理发送 HTTP 请求访问 www.b.com 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。\n\n注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。\n\n## 双向跨域\n\n### 一、document.domain\n\n通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。\n\n例子：\n同域策略认为域和子域隶属于不同的域，比如 www.a.com 和 sub.a.com 是不同的域，这时，我们无法在 www.a.com 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。\n\n### 二、FIM – Fragment Identitier Messaging\n\n不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。\nFIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。\n\n### 三、Flash LocalConnection\n\n页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。\n\n### 四、window.postMessage\n\nwindow.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。\n\n### 五、Cross Frame\n\nCross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 www.a.com 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 www.b.com 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。\n\n不同的跨域请求可以使用不同的方式解决\n\n原文链接：http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html","source":"_posts/解决跨域的-10-种方法.md","raw":"---\ntitle: 解决跨域的 10 种方法\ndate: 2018-06-11 22:40:49\ntags: 跨域\ncategories: js\n---\n\n## 单向跨域\n\n### 一、 JSONP（JSON with Padding）\n\nhtml中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源\n\n例子：\n【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数\n\n优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。\n缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。\n\n### 二、flash URLloader\n\nflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。\n\n例子：\n从域 www.a.com 请求域 www.b.com 上的数据，我们可以借助 flash 来发送 HTTP 请求。\n1. 修改域 www.b.com 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 www.a.com 加入到白名单。\n2. 通过 Flash URLLoader 发送 HTTP 请求。\n3. 通过 Flash API 把响应结果传递给 JavaScript。\n\n缺点：不支持 IOS\n\n### 三、Access Control\n\nAccess Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。\n\n例子：\nwww.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\n\n缺点：目前只在很少的浏览器中得以支持，\n\n\n### 四、window.name\n\nwindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。\n\n例子：\n在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。\n\n优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。\n\n### 五、server proxy\n\n在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。\n\n例子：\n当 www.a.com 域下的页面需要请求 www.b.com 下的资源文件 asset.txt 时，直接发送一个指向 www.b.com/asset.txt 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 www.a.com 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 www.a.com/proxy/ , 然后这个代理发送 HTTP 请求访问 www.b.com 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。\n\n注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。\n\n## 双向跨域\n\n### 一、document.domain\n\n通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。\n\n例子：\n同域策略认为域和子域隶属于不同的域，比如 www.a.com 和 sub.a.com 是不同的域，这时，我们无法在 www.a.com 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。\n\n### 二、FIM – Fragment Identitier Messaging\n\n不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。\nFIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。\n\n### 三、Flash LocalConnection\n\n页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。\n\n### 四、window.postMessage\n\nwindow.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。\n\n### 五、Cross Frame\n\nCross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 www.a.com 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 www.b.com 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。\n\n不同的跨域请求可以使用不同的方式解决\n\n原文链接：http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html","slug":"解决跨域的-10-种方法","published":1,"updated":"2018-09-15T02:18:11.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn14bbbs001sfwvp8zlbvkf4","content":"<h2 id=\"单向跨域\"><a href=\"#单向跨域\" class=\"headerlink\" title=\"单向跨域\"></a>单向跨域</h2><h3 id=\"一、-JSONP（JSON-with-Padding）\"><a href=\"#一、-JSONP（JSON-with-Padding）\" class=\"headerlink\" title=\"一、 JSONP（JSON with Padding）\"></a>一、 JSONP（JSON with Padding）</h3><p>html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源</p>\n<p>例子：<br>【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数</p>\n<p>优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。<br>缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。</p>\n<h3 id=\"二、flash-URLloader\"><a href=\"#二、flash-URLloader\" class=\"headerlink\" title=\"二、flash URLloader\"></a>二、flash URLloader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>\n<p>例子：<br>从域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 请求域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的数据，我们可以借助 flash 来发送 HTTP 请求。</p>\n<ol>\n<li>修改域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 加入到白名单。</li>\n<li>通过 Flash URLLoader 发送 HTTP 请求。</li>\n<li>通过 Flash API 把响应结果传递给 JavaScript。</li>\n</ol>\n<p>缺点：不支持 IOS</p>\n<h3 id=\"三、Access-Control\"><a href=\"#三、Access-Control\" class=\"headerlink\" title=\"三、Access Control\"></a>三、Access Control</h3><p>Access Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。</p>\n<p>例子：<br><a href=\"http://www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\" target=\"_blank\" rel=\"noopener\">www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头</a></p>\n<p>缺点：目前只在很少的浏览器中得以支持，</p>\n<h3 id=\"四、window-name\"><a href=\"#四、window-name\" class=\"headerlink\" title=\"四、window.name\"></a>四、window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。</p>\n<p>例子：<br>在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。</p>\n<p>优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。</p>\n<h3 id=\"五、server-proxy\"><a href=\"#五、server-proxy\" class=\"headerlink\" title=\"五、server proxy\"></a>五、server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>\n<p>例子：<br>当 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 域下的页面需要请求 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的资源文件 asset.txt 时，直接发送一个指向 <a href=\"http://www.b.com/asset.txt\" target=\"_blank\" rel=\"noopener\">www.b.com/asset.txt</a> 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 <a href=\"http://www.a.com/proxy/\" target=\"_blank\" rel=\"noopener\">www.a.com/proxy/</a> , 然后这个代理发送 HTTP 请求访问 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。</p>\n<p>注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</p>\n<h2 id=\"双向跨域\"><a href=\"#双向跨域\" class=\"headerlink\" title=\"双向跨域\"></a>双向跨域</h2><h3 id=\"一、document-domain\"><a href=\"#一、document-domain\" class=\"headerlink\" title=\"一、document.domain\"></a>一、document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。</p>\n<p>例子：<br>同域策略认为域和子域隶属于不同的域，比如 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 和 sub.a.com 是不同的域，这时，我们无法在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。</p>\n<h3 id=\"二、FIM-–-Fragment-Identitier-Messaging\"><a href=\"#二、FIM-–-Fragment-Identitier-Messaging\" class=\"headerlink\" title=\"二、FIM – Fragment Identitier Messaging\"></a>二、FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。<br>FIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。</p>\n<h3 id=\"三、Flash-LocalConnection\"><a href=\"#三、Flash-LocalConnection\" class=\"headerlink\" title=\"三、Flash LocalConnection\"></a>三、Flash LocalConnection</h3><p>页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。</p>\n<h3 id=\"四、window-postMessage\"><a href=\"#四、window-postMessage\" class=\"headerlink\" title=\"四、window.postMessage\"></a>四、window.postMessage</h3><p>window.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>\n<h3 id=\"五、Cross-Frame\"><a href=\"#五、Cross-Frame\" class=\"headerlink\" title=\"五、Cross Frame\"></a>五、Cross Frame</h3><p>Cross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。</p>\n<p>不同的跨域请求可以使用不同的方式解决</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单向跨域\"><a href=\"#单向跨域\" class=\"headerlink\" title=\"单向跨域\"></a>单向跨域</h2><h3 id=\"一、-JSONP（JSON-with-Padding）\"><a href=\"#一、-JSONP（JSON-with-Padding）\" class=\"headerlink\" title=\"一、 JSONP（JSON with Padding）\"></a>一、 JSONP（JSON with Padding）</h3><p>html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源</p>\n<p>例子：<br>【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数</p>\n<p>优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。<br>缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。</p>\n<h3 id=\"二、flash-URLloader\"><a href=\"#二、flash-URLloader\" class=\"headerlink\" title=\"二、flash URLloader\"></a>二、flash URLloader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>\n<p>例子：<br>从域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 请求域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的数据，我们可以借助 flash 来发送 HTTP 请求。</p>\n<ol>\n<li>修改域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 加入到白名单。</li>\n<li>通过 Flash URLLoader 发送 HTTP 请求。</li>\n<li>通过 Flash API 把响应结果传递给 JavaScript。</li>\n</ol>\n<p>缺点：不支持 IOS</p>\n<h3 id=\"三、Access-Control\"><a href=\"#三、Access-Control\" class=\"headerlink\" title=\"三、Access Control\"></a>三、Access Control</h3><p>Access Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。</p>\n<p>例子：<br><a href=\"http://www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\" target=\"_blank\" rel=\"noopener\">www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头</a></p>\n<p>缺点：目前只在很少的浏览器中得以支持，</p>\n<h3 id=\"四、window-name\"><a href=\"#四、window-name\" class=\"headerlink\" title=\"四、window.name\"></a>四、window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。</p>\n<p>例子：<br>在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。</p>\n<p>优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。</p>\n<h3 id=\"五、server-proxy\"><a href=\"#五、server-proxy\" class=\"headerlink\" title=\"五、server proxy\"></a>五、server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>\n<p>例子：<br>当 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 域下的页面需要请求 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的资源文件 asset.txt 时，直接发送一个指向 <a href=\"http://www.b.com/asset.txt\" target=\"_blank\" rel=\"noopener\">www.b.com/asset.txt</a> 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 <a href=\"http://www.a.com/proxy/\" target=\"_blank\" rel=\"noopener\">www.a.com/proxy/</a> , 然后这个代理发送 HTTP 请求访问 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。</p>\n<p>注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</p>\n<h2 id=\"双向跨域\"><a href=\"#双向跨域\" class=\"headerlink\" title=\"双向跨域\"></a>双向跨域</h2><h3 id=\"一、document-domain\"><a href=\"#一、document-domain\" class=\"headerlink\" title=\"一、document.domain\"></a>一、document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。</p>\n<p>例子：<br>同域策略认为域和子域隶属于不同的域，比如 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 和 sub.a.com 是不同的域，这时，我们无法在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。</p>\n<h3 id=\"二、FIM-–-Fragment-Identitier-Messaging\"><a href=\"#二、FIM-–-Fragment-Identitier-Messaging\" class=\"headerlink\" title=\"二、FIM – Fragment Identitier Messaging\"></a>二、FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。<br>FIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。</p>\n<h3 id=\"三、Flash-LocalConnection\"><a href=\"#三、Flash-LocalConnection\" class=\"headerlink\" title=\"三、Flash LocalConnection\"></a>三、Flash LocalConnection</h3><p>页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。</p>\n<h3 id=\"四、window-postMessage\"><a href=\"#四、window-postMessage\" class=\"headerlink\" title=\"四、window.postMessage\"></a>四、window.postMessage</h3><p>window.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>\n<h3 id=\"五、Cross-Frame\"><a href=\"#五、Cross-Frame\" class=\"headerlink\" title=\"五、Cross Frame\"></a>五、Cross Frame</h3><p>Cross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。</p>\n<p>不同的跨域请求可以使用不同的方式解决</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjn14bba10004fwvpkvdkeyvh","category_id":"cjn14bba40006fwvp3jx68531","_id":"cjn14bbap000gfwvp2kz3qktq"},{"post_id":"cjn14bba30005fwvpioj2zyl5","category_id":"cjn14bbab000cfwvpkq5sayh9","_id":"cjn14bbay000nfwvpt7l3p2ux"},{"post_id":"cjn14bba50007fwvpartfaqg4","category_id":"cjn14bba40006fwvp3jx68531","_id":"cjn14bbb2000tfwvpbro4rgm4"},{"post_id":"cjn14bba8000afwvpmd7m9phg","category_id":"cjn14bbax000mfwvp0g3uejs1","_id":"cjn14bbb80011fwvpo8cmh9vv"},{"post_id":"cjn14bbad000efwvpxvsr0z80","category_id":"cjn14bbax000mfwvp0g3uejs1","_id":"cjn14bbbd0015fwvpt9xr2ste"},{"post_id":"cjn14bbaf000ffwvph1p7wepk","category_id":"cjn14bbb70010fwvpsgeb00s9","_id":"cjn14bbbh001cfwvpz3f1azb0"},{"post_id":"cjn14bbat000jfwvpe9j38921","category_id":"cjn14bbax000mfwvp0g3uejs1","_id":"cjn14bbbl001ifwvp9bxdofz1"},{"post_id":"cjn14bbbj001gfwvp3etbqzeh","category_id":"cjn14bbax000mfwvp0g3uejs1","_id":"cjn14bbbp001pfwvpxedpaxcd"},{"post_id":"cjn14bbaz000qfwvpsnnmc4vg","category_id":"cjn14bbbg001bfwvp5lae8jr2","_id":"cjn14bbbt001tfwvpyp1msshx"},{"post_id":"cjn14bbbs001sfwvp8zlbvkf4","category_id":"cjn14bbax000mfwvp0g3uejs1","_id":"cjn14bbbv001yfwvp0cwo71vp"}],"PostTag":[{"post_id":"cjn14bb9m0000fwvpmw5fd9mw","tag_id":"cjn14bb9y0003fwvp9ww3w7hv","_id":"cjn14bba70009fwvp5fjj7dex"},{"post_id":"cjn14bb9t0002fwvplxknyiqt","tag_id":"cjn14bba60008fwvpgyegmzya","_id":"cjn14bbaw000kfwvpwv6kdket"},{"post_id":"cjn14bb9t0002fwvplxknyiqt","tag_id":"cjn14bbac000dfwvprd5hbg3w","_id":"cjn14bbay000ofwvpy7cs8ic4"},{"post_id":"cjn14bbaf000ffwvph1p7wepk","tag_id":"cjn14bb9y0003fwvp9ww3w7hv","_id":"cjn14bbb0000rfwvpormhpjp3"},{"post_id":"cjn14bba10004fwvpkvdkeyvh","tag_id":"cjn14bbas000ifwvpp9xdxvcj","_id":"cjn14bbb3000ufwvp6orooe99"},{"post_id":"cjn14bba30005fwvpioj2zyl5","tag_id":"cjn14bbay000pfwvpi31cf0su","_id":"cjn14bbb6000yfwvpxbw4u22z"},{"post_id":"cjn14bba50007fwvpartfaqg4","tag_id":"cjn14bbas000ifwvpp9xdxvcj","_id":"cjn14bbbg001afwvpgwecd3kq"},{"post_id":"cjn14bba50007fwvpartfaqg4","tag_id":"cjn14bbba0013fwvp21tsymu2","_id":"cjn14bbbi001efwvps8lj5eol"},{"post_id":"cjn14bbbd0017fwvpxvx4d84j","tag_id":"cjn14bba60008fwvpgyegmzya","_id":"cjn14bbbk001hfwvpzvvlvjog"},{"post_id":"cjn14bbbd0017fwvpxvx4d84j","tag_id":"cjn14bbba0013fwvp21tsymu2","_id":"cjn14bbbm001kfwvpcxe69f5z"},{"post_id":"cjn14bbbf0019fwvppidonkhw","tag_id":"cjn14bbas000ifwvpp9xdxvcj","_id":"cjn14bbbo001nfwvpy5wk8op5"},{"post_id":"cjn14bbbf0019fwvppidonkhw","tag_id":"cjn14bba60008fwvpgyegmzya","_id":"cjn14bbbq001qfwvpnfq8n4xg"},{"post_id":"cjn14bba8000afwvpmd7m9phg","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbbt001ufwvpu3utqxj3"},{"post_id":"cjn14bbbh001dfwvpnmc2izh5","tag_id":"cjn14bba60008fwvpgyegmzya","_id":"cjn14bbbu001vfwvprrw323be"},{"post_id":"cjn14bbaa000bfwvpzab8usmd","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbbv001xfwvp6gdhae3m"},{"post_id":"cjn14bbbl001jfwvprkfnyirt","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbbv001zfwvpy5exf2cv"},{"post_id":"cjn14bbad000efwvpxvsr0z80","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbbw0021fwvpavacacs0"},{"post_id":"cjn14bbat000jfwvpe9j38921","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbbw0022fwvp0jqvwrgn"},{"post_id":"cjn14bbat000jfwvpe9j38921","tag_id":"cjn14bbbu001wfwvptmxmaw2a","_id":"cjn14bbbx0024fwvpt6taflnn"},{"post_id":"cjn14bbaw000lfwvp9zygqnh6","tag_id":"cjn14bbbw0020fwvpgsofzgqk","_id":"cjn14bbbz0027fwvpm92zu4h0"},{"post_id":"cjn14bbaw000lfwvp9zygqnh6","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbbz0028fwvponyx221n"},{"post_id":"cjn14bbaw000lfwvp9zygqnh6","tag_id":"cjn14bbbu001wfwvptmxmaw2a","_id":"cjn14bbbz002afwvpw93hmxxq"},{"post_id":"cjn14bbaz000qfwvpsnnmc4vg","tag_id":"cjn14bbby0026fwvpejxnxr5s","_id":"cjn14bbc0002bfwvpqy0lr0ng"},{"post_id":"cjn14bbb0000sfwvpy77gz8vy","tag_id":"cjn14bbbz0029fwvpgee3vkxw","_id":"cjn14bbc1002efwvpzhj29h6j"},{"post_id":"cjn14bbb0000sfwvpy77gz8vy","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbc2002ffwvpzn5efshh"},{"post_id":"cjn14bbb4000wfwvp1uuvuste","tag_id":"cjn14bbbe0018fwvppd1m86qs","_id":"cjn14bbc3002ifwvpp2adfypl"},{"post_id":"cjn14bbb4000wfwvp1uuvuste","tag_id":"cjn14bbbz0029fwvpgee3vkxw","_id":"cjn14bbc3002jfwvpg5e3647e"},{"post_id":"cjn14bbb6000zfwvpkniylmbx","tag_id":"cjn14bbc2002hfwvpkylq6su9","_id":"cjn14bbc4002lfwvptq7bz4lg"},{"post_id":"cjn14bbb80012fwvpmtjehaim","tag_id":"cjn14bbc2002hfwvpkylq6su9","_id":"cjn14bbc5002nfwvp7056og93"},{"post_id":"cjn14bbbb0014fwvpq28336iw","tag_id":"cjn14bbc4002mfwvp9qvbej33","_id":"cjn14bbc6002pfwvplh0x5rsu"},{"post_id":"cjn14bbbj001gfwvp3etbqzeh","tag_id":"cjn14bbc5002ofwvpcz4ynplu","_id":"cjn14bbc7002rfwvp56uaq7mr"},{"post_id":"cjn14bbbn001mfwvp3xvcs2ce","tag_id":"cjn14bbc6002qfwvpsm5zk4c5","_id":"cjn14bbc8002tfwvpc1t3id61"},{"post_id":"cjn14bbbo001ofwvpxtj6ocrr","tag_id":"cjn14bbc7002sfwvpf1iblxnk","_id":"cjn14bbc9002vfwvpk0w25kuo"},{"post_id":"cjn14bbbs001sfwvp8zlbvkf4","tag_id":"cjn14bbc5002ofwvpcz4ynplu","_id":"cjn14bbca002wfwvpkn97wgoo"}],"Tag":[{"name":"html","_id":"cjn14bb9y0003fwvp9ww3w7hv"},{"name":"windows","_id":"cjn14bba60008fwvpgyegmzya"},{"name":"数据库","_id":"cjn14bbac000dfwvprd5hbg3w"},{"name":"git","_id":"cjn14bbas000ifwvpp9xdxvcj"},{"name":"hexo","_id":"cjn14bbay000pfwvpi31cf0su"},{"name":"指令","_id":"cjn14bbba0013fwvp21tsymu2"},{"name":"js","_id":"cjn14bbbe0018fwvppd1m86qs"},{"name":"css","_id":"cjn14bbbu001wfwvptmxmaw2a"},{"name":"nextjs","_id":"cjn14bbbw0020fwvpgsofzgqk"},{"name":"package.json","_id":"cjn14bbby0026fwvpejxnxr5s"},{"name":"react","_id":"cjn14bbbz0029fwvpgee3vkxw"},{"name":"ts","_id":"cjn14bbc2002hfwvpkylq6su9"},{"name":"webpack","_id":"cjn14bbc4002mfwvp9qvbej33"},{"name":"跨域","_id":"cjn14bbc5002ofwvpcz4ynplu"},{"name":"浏览器","_id":"cjn14bbc6002qfwvpsm5zk4c5"},{"name":"其他","_id":"cjn14bbc7002sfwvpf1iblxnk"}]}}