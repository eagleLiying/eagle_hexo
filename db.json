{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/bom-dom.jpg","path":"images/bom-dom.jpg","modified":0,"renderable":0},{"_id":"source/images/hexo-page.png","path":"images/hexo-page.png","modified":0,"renderable":0},{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/avater.png","path":"css/images/avater.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/vexo/.gitignore","hash":"37fb9fd49e7f944716efd3284a6bf55adb6dd0c2","modified":1531823115094},{"_id":"themes/vexo/.travis.yml","hash":"cc482f06f4ea6962058f2548dcb814b954876e76","modified":1531823115094},{"_id":"themes/vexo/README.md","hash":"036ddc66e868b93411a15ed3fd5ed5e9101045a5","modified":1531823115094},{"_id":"themes/vexo/package.json","hash":"8852c5a394ac59d219e5bbbcee10d573d33e1fc6","modified":1531823115099},{"_id":"themes/vexo/LICENSE","hash":"3e135cd69c0e02c0a49dd43d571f600223cc61d1","modified":1531823115094},{"_id":"themes/vexo/_config.yml","hash":"03c435d2ae54c98825e7fc99c97c78e14f2b4af4","modified":1531823115095},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1531823115099},{"_id":"source/_posts/BOM-DOM.md","hash":"a8577a445cf25f61fcf1c51bbfe55a95316d9152","modified":1531823115087},{"_id":"source/_posts/git-账户切换的怪异处理方式.md","hash":"ec09418521a17106ac5c99320447fca264aa6eb5","modified":1531823115088},{"_id":"source/_posts/gitCommand.md","hash":"f83c7236b2f8cbee7890b8dab694898b796d2c2b","modified":1531823115088},{"_id":"source/_posts/hexoGithubIo.md","hash":"cc959f808dd0546d97441528d3fc32cee26c5f2f","modified":1531823115088},{"_id":"source/_posts/js-继承方式.md","hash":"eabeb0139af0e332e479d21c23428392c3c75beb","modified":1531823115089},{"_id":"source/_posts/nextjs-postcss-typeScript.md","hash":"693df22c7af1851b785596d31dbc976e82c095bc","modified":1533183166727},{"_id":"source/_posts/let-vs-var.md","hash":"b6b69451fcbd4875503bebe78ffae16bc95dd22f","modified":1531823115089},{"_id":"source/_posts/localStorage-sessionStorage.md","hash":"77b5747b5587c32cce2d0c3001269de5a7d1c859","modified":1531823115089},{"_id":"source/_posts/mobile-modal-scroll.md","hash":"0704d36df17a092864ffeeeae697410dcf68b4a7","modified":1533009467363},{"_id":"source/_posts/react-Lifecycle.md","hash":"6a24ff937e04152a7b8865a8eb34d597a370717f","modified":1531823115090},{"_id":"source/_posts/package-json文件.md","hash":"b29cc91ad446cd8d248fe6987dbf6b51c94a9920","modified":1531823115090},{"_id":"source/_posts/什么是跨域？.md","hash":"38f81261d6d53feee5bf9ba488879332fd1aceec","modified":1531823115090},{"_id":"source/_posts/浏览器内核.md","hash":"bac46dab98625cda7fecfb9089f217ea37687775","modified":1531823115090},{"_id":"source/_posts/解决跨域的-10-种方法.md","hash":"b0182165c743d5bfce9e972a215c328d2f1cd325","modified":1531823115091},{"_id":"source/about/index.md","hash":"2f9c503b618939cfb0dddccf08f031c829ef9aa2","modified":1529637029441},{"_id":"source/images/bom-dom.jpg","hash":"72643a90e347098a053c30529760871c79d4e71f","modified":1531823115091},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1531823115094},{"_id":"source/images/hexo-page.png","hash":"bcc8884f0fa4b9491eff8c4511d7ebc95a4d1f40","modified":1531823115093},{"_id":"themes/vexo/layout/about.ejs","hash":"76ba7418788eb2bb9ba46844f4d750734847d0b4","modified":1531823115097},{"_id":"themes/vexo/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1531823115098},{"_id":"themes/vexo/layout/index.ejs","hash":"9f12f5928d68d4d68175b825e18f89f3b0dfdb69","modified":1531823115098},{"_id":"themes/vexo/layout/archive.ejs","hash":"cb12abb19cb70e90d410a6233933eedb3f2c033a","modified":1531823115098},{"_id":"themes/vexo/layout/page.ejs","hash":"a886fb7e8a9d70bc971b6dfc7210d4fa2ee671c9","modified":1531823115098},{"_id":"themes/vexo/layout/project.ejs","hash":"666be5c72bac8165e0946428642b36dd3232983e","modified":1531823115099},{"_id":"themes/vexo/layout/tags.ejs","hash":"5b326e2bd3292b3015d0666b796544d7126acfda","modified":1531823115099},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1531823115095},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1531823115095},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1531823115095},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1531823115096},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1531823115096},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"6032a4dcc6224ad916b7898d54e91552c17396ce","modified":1531823115096},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"90334bd53e232d7b2cc5ae743b377fc5336bcd6b","modified":1531823115096},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"e544f516b23bc609cc6367190f380c879b935c21","modified":1531823115096},{"_id":"themes/vexo/layout/_partial/nav.ejs","hash":"3d8ddc1f6e135a240d40edd157cf37f5d0a12df6","modified":1531823115096},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1531823115097},{"_id":"themes/vexo/layout/_third-party/mathjax.ejs","hash":"aa58f0cfe22e7151c1a0521bbfa5cbd76f6dcd9d","modified":1531823115097},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1531823115097},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1531823115097},{"_id":"themes/vexo/source/css/_config.styl","hash":"0c9c0e77d6b8813cb76494e8d757843aab9e117b","modified":1531823115100},{"_id":"themes/vexo/source/css/style.styl","hash":"c09ad049c647cc089eaf00aa59e5d5d2a7f782d4","modified":1531823115107},{"_id":"themes/vexo/source/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1531823115109},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1531823115109},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"8a428687f74f33426bf0c7de3fdd1f7654c26587","modified":1531823115100},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"e80ddf26f2af3523632afeabd57f81592537985a","modified":1531823115100},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"970b6fd3d05834926c69724934b798dd5a1472e6","modified":1531823115100},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"cbf3f59d3c3162700eb9cbd4cf72c8470c170f81","modified":1531823115100},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"7f3f828d0107cca18c0929fd902753441ae5d3c1","modified":1531823115100},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"3ec22606f9548681389158384dc29ddf59c8ceea","modified":1531823115101},{"_id":"themes/vexo/source/css/_partial/nav.styl","hash":"e92c010c5cd460e75c67083df8cdd0bf4d25cde4","modified":1531823115101},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1531823115101},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1531823115101},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"e9b6faadf4852bce3a4141cba0a102a7afb81e9f","modified":1531823115101},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1531823115104},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1531823115102},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1531823115105},{"_id":"themes/vexo/source/css/images/favicon.ico","hash":"84133d0b67e264f6008e81233f0f3a37defd4af3","modified":1531823115105},{"_id":"themes/vexo/source/css/images/logo.png","hash":"c20b2395c9a2fd5e7c188bcc0676a3efbb6e6cb7","modified":1531823115105},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1531823115105},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1531823115106},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1531823115106},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1531823115106},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1531823115108},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1531823115109},{"_id":"themes/vexo/source/css/images/avater.png","hash":"56d6339a771cab60aaa71e2dc4e347c75bf6a954","modified":1531823115104},{"_id":"public/about/index.html","hash":"7a5b776b759c78a51a3ad018cb6065f66ad29780","modified":1533183224621},{"_id":"public/tags/index.html","hash":"455db2fef939bb04e9d64c353e765e75df6ca0d5","modified":1533183224622},{"_id":"public/2018/07/31/mobile-modal-scroll/index.html","hash":"73d4796afd99bd20c5ba70029a48ba1011f518c2","modified":1533183224622},{"_id":"public/2018/07/04/浏览器内核/index.html","hash":"3de3d113be3ed9dc7b77f97e87fd15f01cbfe0f1","modified":1533183224622},{"_id":"public/2018/06/28/BOM-DOM/index.html","hash":"33c3b6a7e45734f6aa4a2f5fb4bcc6f7c686aba8","modified":1533183224622},{"_id":"public/2018/06/22/let-vs-var/index.html","hash":"40a2bcdd7cfad73ee11ae3ab8fd49ba0fa265a14","modified":1533183224622},{"_id":"public/2018/06/11/什么是跨域？/index.html","hash":"17f9ce77bf2ac3537b89b7c3b6fb46119ccc16b6","modified":1533183224622},{"_id":"public/2018/06/09/git-账户切换的怪异处理方式/index.html","hash":"4d92e12d9b2b99e2ff3dcb4c54720319f99eb859","modified":1533183224623},{"_id":"public/archives/index.html","hash":"ba34389c9e2451b8fc9d7bcc0e2b51ced9bdd848","modified":1533183224623},{"_id":"public/archives/page/2/index.html","hash":"9e5996dc64bdb8b8516bc6b9f1a13f31cbe18b29","modified":1533183224623},{"_id":"public/archives/2018/index.html","hash":"4bf2f516b341d0379e1c3dbef2a229e5da351410","modified":1533183224623},{"_id":"public/archives/2018/page/2/index.html","hash":"7fef9044715c93d7bee248a5dc02ff7c77cf95dd","modified":1533183224623},{"_id":"public/archives/2018/06/index.html","hash":"68d9402703aa23dfea6cfbaa2cdd0775b69cd3d3","modified":1533183224623},{"_id":"public/archives/2018/06/page/2/index.html","hash":"582939d520463d10a15df71c526f9709563821bc","modified":1533183224623},{"_id":"public/archives/2018/07/index.html","hash":"fcbefef8fa884d371cc5f020ca9e1373dd280c56","modified":1533183224623},{"_id":"public/archives/2018/08/index.html","hash":"bb7b88c7509f328a2d3108669ef1688ca102893f","modified":1533183224623},{"_id":"public/categories/指令/index.html","hash":"3689db71c580e4d53590af1686fd7934063f5806","modified":1533183224623},{"_id":"public/categories/环境/index.html","hash":"58dd2ed3c3bc8a3cddfe3604354d0f908821212e","modified":1533183224624},{"_id":"public/categories/js/index.html","hash":"36a3024436e52568e38cf7090a3830a1782cbf16","modified":1533183224624},{"_id":"public/categories/html/index.html","hash":"d3217017ba76eff69cd70eef81808b9287544f36","modified":1533183224624},{"_id":"public/categories/json/index.html","hash":"b92cfd1aa8127fa1af6ddc897e8a06452d70e0d0","modified":1533183224624},{"_id":"public/index.html","hash":"5e8ef601c7dea5bcab73c49b7113d3a40e652167","modified":1533183224624},{"_id":"public/page/2/index.html","hash":"1456484b30a4276df400a23b3de0e0ed7165e356","modified":1533183224624},{"_id":"public/tags/html/index.html","hash":"2fc2dd4eb77e6058e0069259c7a7e01458cc46b4","modified":1533183224624},{"_id":"public/tags/git/index.html","hash":"838c619009845472a3087249ba5fae4a4a510b06","modified":1533183224624},{"_id":"public/tags/hexo/index.html","hash":"b654b31c886317bf9926eae9b3724ef96a9da9c6","modified":1533183224624},{"_id":"public/tags/js/index.html","hash":"14ca0d24fa3bd286214992ef0d24bf4ab3874af3","modified":1533183224624},{"_id":"public/tags/nextjs/index.html","hash":"1c1c285aa9f7090312e9b2e7b903d307d6d4b229","modified":1533183224625},{"_id":"public/tags/css/index.html","hash":"7244fe2f008ed393af2fda8419e834a9bae50fda","modified":1533183224625},{"_id":"public/tags/react/index.html","hash":"93cdc2ed2fb734355d36ba739915a53bd99ec8f0","modified":1533183224625},{"_id":"public/tags/package-json/index.html","hash":"28da83f8cfe1b6f541b92f7fb0319cd0fb76aa5b","modified":1533183224625},{"_id":"public/tags/跨域/index.html","hash":"5d62c6585e77e0bb49581adbbc3a2fee42d7cc7a","modified":1533183224625},{"_id":"public/tags/浏览器/index.html","hash":"736be9cc4d8d5840ec48e50a7df407607baf144a","modified":1533183224625},{"_id":"public/2018/08/01/nextjs-postcss-typeScript/index.html","hash":"e4a623d98df14aa62a78d6acef181757ee98d0ce","modified":1533183224625},{"_id":"public/2018/06/28/react-Lifecycle/index.html","hash":"79c47d25f2af728994db6074f9e9b88a87d4da75","modified":1533183224626},{"_id":"public/2018/06/23/localStorage-sessionStorage/index.html","hash":"9006781298864751816896f84913aa5fc9c5d126","modified":1533183224627},{"_id":"public/2018/06/21/js-继承方式/index.html","hash":"94ebc5cd3274993835024df576555bb7f2b57a34","modified":1533183224627},{"_id":"public/2018/06/17/package-json文件/index.html","hash":"a97a0fe04e1196ca80811aedd362c7a10b2e9913","modified":1533183224627},{"_id":"public/2018/06/11/解决跨域的-10-种方法/index.html","hash":"f06e39fdad9e89a4df07607f66c19704b42fc204","modified":1533183224627},{"_id":"public/2018/06/09/gitCommand/index.html","hash":"7f81311e6678e881a2682b47851f32ddc625050d","modified":1533183224627},{"_id":"public/2018/06/06/hexoGithubIo/index.html","hash":"c654ce02e5e22fac825ad28cf33e0586fabfd99f","modified":1533183224627},{"_id":"public/images/bom-dom.jpg","hash":"72643a90e347098a053c30529760871c79d4e71f","modified":1533183224632},{"_id":"public/images/hexo-page.png","hash":"bcc8884f0fa4b9491eff8c4511d7ebc95a4d1f40","modified":1533183224632},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1533183224632},{"_id":"public/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1533183224632},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1533183224633},{"_id":"public/css/images/favicon.ico","hash":"84133d0b67e264f6008e81233f0f3a37defd4af3","modified":1533183224633},{"_id":"public/css/images/logo.png","hash":"c20b2395c9a2fd5e7c188bcc0676a3efbb6e6cb7","modified":1533183224633},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1533183224633},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1533183224633},{"_id":"public/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1533183224633},{"_id":"public/js/script.js","hash":"19c6ac9c1d8220fa9ab2ec461c17eaae3bc962d7","modified":1533183224922},{"_id":"public/css/style.css","hash":"41aeb651949e331fdc2b9a731c42a6976ee197bb","modified":1533183224922},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1533183224923},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1533183224923},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1533183224923},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1533183224923},{"_id":"public/css/images/avater.png","hash":"56d6339a771cab60aaa71e2dc4e347c75bf6a954","modified":1533183224938}],"Category":[{"name":"指令","_id":"cjkahyd6j0004nzz94fkzxgf1"},{"name":"环境","_id":"cjkahyd6o000anzz999r2wxey"},{"name":"js","_id":"cjkahyd7s000mnzz9nkcel7ms"},{"name":"html","_id":"cjkahyd83000xnzz9iyz16ao6"},{"name":"json","_id":"cjkahyd870014nzz94mk5p945"}],"Data":[],"Page":[{"title":"About","type":"about","comments":0,"_content":"Eagle Li\n\n喜欢自己折腾一些感兴趣的小东西\n\n敲起代码不喜欢被打扰\n\n周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天\n\n长假想要出去走走，看看这大好的风光\n\n在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌\n\n舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万\n\n\n\n\n邮箱：liying_eagle@163.com","source":"about/index.md","raw":"title: About\ntype: \"about\"\ncomments: false\n---\nEagle Li\n\n喜欢自己折腾一些感兴趣的小东西\n\n敲起代码不喜欢被打扰\n\n周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天\n\n长假想要出去走走，看看这大好的风光\n\n在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌\n\n舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万\n\n\n\n\n邮箱：liying_eagle@163.com","date":"2018-06-22T03:10:29.441Z","updated":"2018-06-22T03:10:29.441Z","path":"about/index.html","layout":"page","_id":"cjkahyd7p000jnzz978eq9a9s","content":"<p>Eagle Li</p>\n<p>喜欢自己折腾一些感兴趣的小东西</p>\n<p>敲起代码不喜欢被打扰</p>\n<p>周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天</p>\n<p>长假想要出去走走，看看这大好的风光</p>\n<p>在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌</p>\n<p>舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万</p>\n<p>邮箱：<a href=\"mailto:liying_eagle@163.com\" target=\"_blank\" rel=\"noopener\">liying_eagle@163.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Eagle Li</p>\n<p>喜欢自己折腾一些感兴趣的小东西</p>\n<p>敲起代码不喜欢被打扰</p>\n<p>周末喜欢跳跳小舞，或者默默的在家里宅一天，或者在家里睡一天</p>\n<p>长假想要出去走走，看看这大好的风光</p>\n<p>在别人想着整一个美美的化妆台时，我想最多的是给自己整套大气磅礴的电脑桌</p>\n<p>舍不得买几百块钱的衣服，却在买电脑时没有考虑过一不小心花出了上万</p>\n<p>邮箱：<a href=\"mailto:liying_eagle@163.com\" target=\"_blank\" rel=\"noopener\">liying_eagle@163.com</a></p>\n"},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2018-07-17T10:25:15.094Z","updated":"2018-07-17T10:25:15.094Z","path":"tags/index.html","comments":1,"_id":"cjkahyd7r000lnzz989f4iysm","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BOM-DOM","date":"2018-06-27T17:01:59.000Z","_content":"\n## BOM\n\n1. BOM 是 Browser Object Model 的缩写，即浏览器对象模型。\n\nBOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。\n\n2. BOM没有相关标准\n\n由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。\n\n3. BOM 的最根本对象是 window。\n\n## DOM\n\n1. DOM 是 Document Object Model 的缩写，即文档对象模型。\n\nDOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。\n\n2. DOM 是 W3C 的标准。\n\n3. DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。\n\n## BOM DOM 关系图\n\n![](/images/bom-dom.jpg)\n\n\n原文链接：https://blog.csdn.net/xiao__gui/article/details/8315148","source":"_posts/BOM-DOM.md","raw":"---\ntitle: BOM-DOM\ndate: 2018-06-28 01:01:59\ntags: html\n---\n\n## BOM\n\n1. BOM 是 Browser Object Model 的缩写，即浏览器对象模型。\n\nBOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。\n\n2. BOM没有相关标准\n\n由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。\n\n3. BOM 的最根本对象是 window。\n\n## DOM\n\n1. DOM 是 Document Object Model 的缩写，即文档对象模型。\n\nDOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。\n\n2. DOM 是 W3C 的标准。\n\n3. DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。\n\n## BOM DOM 关系图\n\n![](/images/bom-dom.jpg)\n\n\n原文链接：https://blog.csdn.net/xiao__gui/article/details/8315148","slug":"BOM-DOM","published":1,"updated":"2018-07-17T10:25:15.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd670000nzz91bhq52fc","content":"<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><ol>\n<li>BOM 是 Browser Object Model 的缩写，即浏览器对象模型。</li>\n</ol>\n<p>BOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。</p>\n<ol start=\"2\">\n<li>BOM没有相关标准</li>\n</ol>\n<p>由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。</p>\n<ol start=\"3\">\n<li>BOM 的最根本对象是 window。</li>\n</ol>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><ol>\n<li>DOM 是 Document Object Model 的缩写，即文档对象模型。</li>\n</ol>\n<p>DOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。</p>\n<ol start=\"2\">\n<li><p>DOM 是 W3C 的标准。</p>\n</li>\n<li><p>DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p>\n</li>\n</ol>\n<h2 id=\"BOM-DOM-关系图\"><a href=\"#BOM-DOM-关系图\" class=\"headerlink\" title=\"BOM DOM 关系图\"></a>BOM DOM 关系图</h2><p><img src=\"/images/bom-dom.jpg\" alt=\"\"></p>\n<p>原文链接：<a href=\"https://blog.csdn.net/xiao__gui/article/details/8315148\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiao__gui/article/details/8315148</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><ol>\n<li>BOM 是 Browser Object Model 的缩写，即浏览器对象模型。</li>\n</ol>\n<p>BOM 和浏览器关系密切。浏览器的很多东西可以通过 JavaScript 控制的，例如打开新窗口、打开新选项卡（标签页）、关闭页面，把网页设为主页，或加入收藏夹，等这些涉及到的对象就是 BOM。</p>\n<ol start=\"2\">\n<li>BOM没有相关标准</li>\n</ol>\n<p>由于没有标准，不同的浏览器实现同一功能，可以需要不同的实现方式。虽然 BOM 没有一套标准，但是各个浏览器的常用功能的 JavaScript 代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。</p>\n<ol start=\"3\">\n<li>BOM 的最根本对象是 window。</li>\n</ol>\n<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><ol>\n<li>DOM 是 Document Object Model 的缩写，即文档对象模型。</li>\n</ol>\n<p>DOM 和文档有关，这里的文档指的是网页，也就是 HTML 文档。网页是由服务器发送给客户端浏览器的，无论用什么浏览器，接收到的 HTML 都是一样的，所以 DOM 和浏览器无关，它关注的是网页本身的内容。由于和浏览器关系不大，所以标准就好定了。</p>\n<ol start=\"2\">\n<li><p>DOM 是 W3C 的标准。</p>\n</li>\n<li><p>DOM 最根本对象是 document（window.document）。DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p>\n</li>\n</ol>\n<h2 id=\"BOM-DOM-关系图\"><a href=\"#BOM-DOM-关系图\" class=\"headerlink\" title=\"BOM DOM 关系图\"></a>BOM DOM 关系图</h2><p><img src=\"/images/bom-dom.jpg\" alt=\"\"></p>\n<p>原文链接：<a href=\"https://blog.csdn.net/xiao__gui/article/details/8315148\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiao__gui/article/details/8315148</a></p>\n"},{"title":"git 账户切换的怪异处理方式","date":"2018-06-09T13:44:35.000Z","_content":"\n在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”\n\n指令： ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.xx\"\n\n执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub \n在你的编辑器里打开 id_rsa.pub\n复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。\n保存之后就OK了  ：）\n","source":"_posts/git-账户切换的怪异处理方式.md","raw":"---\ntitle: git 账户切换的怪异处理方式\ndate: 2018-06-09 21:44:35\ntags: git\ncategories: 指令\n---\n\n在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”\n\n指令： ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.xx\"\n\n执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub \n在你的编辑器里打开 id_rsa.pub\n复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。\n保存之后就OK了  ：）\n","slug":"git-账户切换的怪异处理方式","published":1,"updated":"2018-07-17T10:25:15.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd6d0001nzz9focojiul","content":"<p>在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”</p>\n<p>指令： ssh-keygen -t rsa -b 4096 -C “<a href=\"mailto:xxx@xxx.xx\" target=\"_blank\" rel=\"noopener\">xxx@xxx.xx</a>“</p>\n<p>执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub<br>在你的编辑器里打开 id_rsa.pub<br>复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。<br>保存之后就OK了  ：）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在平时一个电脑上切换 git 账户时你发现很多烦人的问题，明明已经切换过来了，但是最终的结果，在你提交代码的时候发现总是给你报错导致你提交代码是啊，现在本人找出了一个小小的解决方案就是“修改 deploy key”</p>\n<p>指令： ssh-keygen -t rsa -b 4096 -C “<a href=\"mailto:xxx@xxx.xx\" target=\"_blank\" rel=\"noopener\">xxx@xxx.xx</a>“</p>\n<p>执行之后会在你的电脑更目录下生成一个 .ssh 文件夹，其中会有两个文件：id_rsa 和 id_rsa.pub<br>在你的编辑器里打开 id_rsa.pub<br>复制里面的 key 值，在你的 github 账户中项目的 setting 中的 deploy 配置中添加一个新的 deploy key ，记得勾选是否允许写入，否则的话你是只读的，同样推代码推不上去。<br>保存之后就OK了  ：）</p>\n"},{"title":"Git Command","date":"2018-06-09T12:51:35.000Z","_content":"\n使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：\n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 配置 git\n\n1. git 基本配置：\n\ngit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置（如果加 --global 表示设置全局）\n$ git config --list [--global]\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息 \n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n2. fork 代码库\n\n\n如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。\n```\n# 显示所有远程仓库\n$ git remote -v\n\n# 查看帮助\n$ git remote —help  \n\n# 删除 origin\n$ git remote remove origin  \n\n# 将当前的代码塞进刚建的心的项目\n$ git remote add origin [url]\n\n# 推送当前的代码到远程的 master 分支\n$ git push -u origin master\n\n# 监听版本更新:\n$ git remote add upstream [url]\n```\n### 文件管理\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 分支管理\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n### commit 管理\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 同步远程分支\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销某些操作\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 撤回上一次 commit\n$ git reset HEAD^\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。\nmerge 命令不会保留 merge 的分支的 commit\nrebase 命令会保留 merge 的分支的 commit\n\n\n```\n# 从源分支进行变基\n$ git rebase origin\n\n# 变基倒数三个 commit\n$ git rebase -i HEAD~3\n\n# 继续执行\n$ git rebase --continue\n\n# 停止变基\n$ git rebase --abort\n```","source":"_posts/gitCommand.md","raw":"---\ntitle: Git Command\ndate: 2018-06-09 20:51:35\ntags: git\ncategories: 指令\n---\n\n使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：\n\n### 新建代码库\n\n```\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 配置 git\n\n1. git 基本配置：\n\ngit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```\n# 显示当前的Git配置（如果加 --global 表示设置全局）\n$ git config --list [--global]\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息 \n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n2. fork 代码库\n\n\n如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。\n```\n# 显示所有远程仓库\n$ git remote -v\n\n# 查看帮助\n$ git remote —help  \n\n# 删除 origin\n$ git remote remove origin  \n\n# 将当前的代码塞进刚建的心的项目\n$ git remote add origin [url]\n\n# 推送当前的代码到远程的 master 分支\n$ git push -u origin master\n\n# 监听版本更新:\n$ git remote add upstream [url]\n```\n### 文件管理\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 分支管理\n```\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n```\n\n### commit 管理\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 查看信息\n```\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 同步远程分支\n\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销某些操作\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 撤回上一次 commit\n$ git reset HEAD^\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。\nmerge 命令不会保留 merge 的分支的 commit\nrebase 命令会保留 merge 的分支的 commit\n\n\n```\n# 从源分支进行变基\n$ git rebase origin\n\n# 变基倒数三个 commit\n$ git rebase -i HEAD~3\n\n# 继续执行\n$ git rebase --continue\n\n# 停止变基\n$ git rebase --abort\n```","slug":"gitCommand","published":1,"updated":"2018-07-17T10:25:15.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd6h0003nzz9roia89ev","content":"<p>使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：</p>\n<h3 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个目录，将其初始化为Git代码库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 下载一个项目和它的整个代码历史</span><br><span class=\"line\">$ git clone [url]</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><ol>\n<li>git 基本配置：</li>\n</ol>\n<p>git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前的Git配置（如果加 --global 表示设置全局）</span><br><span class=\"line\">$ git config --list [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 编辑Git配置文件</span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置提交代码时的用户信息 </span><br><span class=\"line\">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>fork 代码库</li>\n</ol>\n<p>如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看帮助</span><br><span class=\"line\">$ git remote —help  </span><br><span class=\"line\"></span><br><span class=\"line\"># 删除 origin</span><br><span class=\"line\">$ git remote remove origin  </span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前的代码塞进刚建的心的项目</span><br><span class=\"line\">$ git remote add origin [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送当前的代码到远程的 master 分支</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"># 监听版本更新:</span><br><span class=\"line\">$ git remote add upstream [url]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加每个变化前，都会要求确认</span><br><span class=\"line\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 改名文件，并且将这个改名放入暂存区</span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class=\"line\">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-管理\"><a href=\"#commit-管理\" class=\"headerlink\" title=\"commit 管理\"></a>commit 管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区</span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit [file1] [file2] ... -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时显示所有diff信息</span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"line\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重做上一次commit，并包括指定文件的新变化</span><br><span class=\"line\">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示有变更的文件</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的版本历史</span><br><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class=\"line\">$ git log --stat</span><br><span class=\"line\"></span><br><span class=\"line\"># 搜索提交历史，根据关键词</span><br><span class=\"line\">$ git log -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class=\"line\">$ git log [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class=\"line\">$ git log [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个文件的版本历史，包括文件改名</span><br><span class=\"line\">$ git log --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件相关的每一次diff</span><br><span class=\"line\">$ git log -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示过去5次提交</span><br><span class=\"line\">$ git log -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有提交过的用户，按提交次数排序</span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件是什么人在什么时间修改过</span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和工作区的差异</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和上一个commit的差异</span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示工作区与当前分支最新commit之间的差异</span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示两次提交之间的差异</span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示今天你写了多少行代码</span><br><span class=\"line\">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交的元数据和内容变化</span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交发生变化的文件</span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交时，某个文件的内容</span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的最近几次提交</span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载远程仓库的所有变动</span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个远程仓库的信息</span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个新的远程仓库，并命名</span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 取回远程仓库的变化，并与本地分支合并</span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 上传本地指定分支到远程仓库</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销某些操作\"><a href=\"#撤销某些操作\" class=\"headerlink\" title=\"撤销某些操作\"></a>撤销某些操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 恢复暂存区的指定文件到工作区</span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复暂存区的所有文件到工作区</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 撤回上一次 commit</span><br><span class=\"line\">$ git reset HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂时将未提交的变化移除，稍后再移入</span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。<br>merge 命令不会保留 merge 的分支的 commit<br>rebase 命令会保留 merge 的分支的 commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从源分支进行变基</span><br><span class=\"line\">$ git rebase origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 变基倒数三个 commit</span><br><span class=\"line\">$ git rebase -i HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\"># 继续执行</span><br><span class=\"line\">$ git rebase --continue</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止变基</span><br><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>使用 github 很久了，但是一直没有仔细研究过 git 指令，现在把自己常用的 git 指令总结，方便翻阅：</p>\n<h3 id=\"新建代码库\"><a href=\"#新建代码库\" class=\"headerlink\" title=\"新建代码库\"></a>新建代码库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个目录，将其初始化为Git代码库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 下载一个项目和它的整个代码历史</span><br><span class=\"line\">$ git clone [url]</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><ol>\n<li>git 基本配置：</li>\n</ol>\n<p>git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前的Git配置（如果加 --global 表示设置全局）</span><br><span class=\"line\">$ git config --list [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 编辑Git配置文件</span><br><span class=\"line\">$ git config -e [--global]</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置提交代码时的用户信息 </span><br><span class=\"line\">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>fork 代码库</li>\n</ol>\n<p>如果想要将那些开源的代码直接fork 到自己的 github 中，我们可以直接点击 github 网站中的 fork 按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看帮助</span><br><span class=\"line\">$ git remote —help  </span><br><span class=\"line\"></span><br><span class=\"line\"># 删除 origin</span><br><span class=\"line\">$ git remote remove origin  </span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前的代码塞进刚建的心的项目</span><br><span class=\"line\">$ git remote add origin [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送当前的代码到远程的 master 分支</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\"></span><br><span class=\"line\"># 监听版本更新:</span><br><span class=\"line\">$ git remote add upstream [url]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加每个变化前，都会要求确认</span><br><span class=\"line\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class=\"line\">$ git add -p</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\">$ git rm [file1] [file2] ...</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class=\"line\">$ git rm --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 改名文件，并且将这个改名放入暂存区</span><br><span class=\"line\">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class=\"line\">$ git branch --track [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br><span class=\"line\"></span><br><span class=\"line\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class=\"line\">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"commit-管理\"><a href=\"#commit-管理\" class=\"headerlink\" title=\"commit 管理\"></a>commit 管理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区</span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit [file1] [file2] ... -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\">$ git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交时显示所有diff信息</span><br><span class=\"line\">$ git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用一次新的commit，替代上一次提交</span><br><span class=\"line\"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重做上一次commit，并包括指定文件的新变化</span><br><span class=\"line\">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示有变更的文件</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的版本历史</span><br><span class=\"line\">$ git log</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class=\"line\">$ git log --stat</span><br><span class=\"line\"></span><br><span class=\"line\"># 搜索提交历史，根据关键词</span><br><span class=\"line\">$ git log -S [keyword]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class=\"line\">$ git log [tag] HEAD --pretty=format:%s</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class=\"line\">$ git log [tag] HEAD --grep feature</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个文件的版本历史，包括文件改名</span><br><span class=\"line\">$ git log --follow [file]</span><br><span class=\"line\">$ git whatchanged [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件相关的每一次diff</span><br><span class=\"line\">$ git log -p [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示过去5次提交</span><br><span class=\"line\">$ git log -5 --pretty --oneline</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有提交过的用户，按提交次数排序</span><br><span class=\"line\">$ git shortlog -sn</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定文件是什么人在什么时间修改过</span><br><span class=\"line\">$ git blame [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和工作区的差异</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示暂存区和上一个commit的差异</span><br><span class=\"line\">$ git diff --cached [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示工作区与当前分支最新commit之间的差异</span><br><span class=\"line\">$ git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示两次提交之间的差异</span><br><span class=\"line\">$ git diff [first-branch]...[second-branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示今天你写了多少行代码</span><br><span class=\"line\">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交的元数据和内容变化</span><br><span class=\"line\">$ git show [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交发生变化的文件</span><br><span class=\"line\">$ git show --name-only [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某次提交时，某个文件的内容</span><br><span class=\"line\">$ git show [commit]:[filename]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示当前分支的最近几次提交</span><br><span class=\"line\">$ git reflog</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步远程分支\"><a href=\"#同步远程分支\" class=\"headerlink\" title=\"同步远程分支\"></a>同步远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载远程仓库的所有变动</span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有远程仓库</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个远程仓库的信息</span><br><span class=\"line\">$ git remote show [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个新的远程仓库，并命名</span><br><span class=\"line\">$ git remote add [shortname] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"># 取回远程仓库的变化，并与本地分支合并</span><br><span class=\"line\">$ git pull [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 上传本地指定分支到远程仓库</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class=\"line\">$ git push [remote] --force</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销某些操作\"><a href=\"#撤销某些操作\" class=\"headerlink\" title=\"撤销某些操作\"></a>撤销某些操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 恢复暂存区的指定文件到工作区</span><br><span class=\"line\">$ git checkout [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class=\"line\">$ git checkout [commit] [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 恢复暂存区的所有文件到工作区</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class=\"line\">$ git reset [file]</span><br><span class=\"line\"></span><br><span class=\"line\"># 撤回上一次 commit</span><br><span class=\"line\">$ git reset HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class=\"line\">$ git reset [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class=\"line\">$ git reset --hard [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂时将未提交的变化移除，稍后再移入</span><br><span class=\"line\">$ git stash</span><br><span class=\"line\">$ git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。<br>merge 命令不会保留 merge 的分支的 commit<br>rebase 命令会保留 merge 的分支的 commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从源分支进行变基</span><br><span class=\"line\">$ git rebase origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 变基倒数三个 commit</span><br><span class=\"line\">$ git rebase -i HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\"># 继续执行</span><br><span class=\"line\">$ git rebase --continue</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止变基</span><br><span class=\"line\">$ git rebase --abort</span><br></pre></td></tr></table></figure>"},{"title":"hexo + github.io","date":"2018-06-05T16:14:18.000Z","_content":"\n### 第一步：需要的环境：\n   node环境  （[立即下载](https://nodejs.org/zh-cn/)）\n   git 环境  （[立即下载](https://git-scm.com/download/)）\n   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。\n    [安装 homebrw](https://brew.sh/)\n    [安装 yarn](https://yarnpkg.com/en/docs/install#mac-stable)\n### 第二步：安装 hexo:\n([也可以按照官方网站就行安装](https://hexo.io/zh-cn/docs/index.html))\n1. 安装 hexo\n```\n$ yarn add -g hexo-cli\n```\n2. 创建一个新的 hexo 项目\n```\n$ hexo init blog（项目名字）\ncd blog\n$ yarn install\n```\n3. 启动项目\n```\n$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000\n```\n\n项目文件结构为：\n\n![](/images/hexo-page.png)\n\n至此，我们本地的一个博客环境就已经搭建完成。\n常用的指令如下：([具体参数使用前查看详细文档](https://hexo.io/zh-cn/docs/commands.html))\n```\n$ hexo server = hexo s  // 启动项目\n$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage\n$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中\n$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）\n```\n### 第三步：更换主题\n现在为自己的博客找一个喜欢的主题：\n1. 进入[hexo 主题库](https://hexo.io/themes/)，选择一个自己喜欢的主题\n2. 点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来\n3. 将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字\n\n当前我所用的主题为 [clean-blog](https://github.com/klugjo/hexo-theme-clean-blog)\n\n### 第四步：搭建免费的 github.io 服务器\n\n首先明白什么是 github pages:\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n\n***特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的***\n\n\n1. 注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。\n\n2. 将本地环境推上线上环境，\n    1. 首先需要知道，如果直接访问 http://eagle.github.io 的时候，他会直接去找根目录下的 index.html 的静态文件。\n    2. Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问\n    3. 需要将hexo生成的静态文件，提交 commit 推到github上\n\n部署的方法一：\nhexo deploy ，可以参考 [官方的文档](https://hexo.io/docs/deployment.html)\n\n安装 hexo-deployer-git\n```\n$ yarn add hexo-deployer-git\n```\n配置：_config.xml\n```\ndeploy:\n  type: git\n  repo: git@github.com:jiji262/jiji262.github.io.git\n  branch: master\n```\n执行：\n```\n$ hexo d\n```\n\n执行之后可能会报错：\n```\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n则是因为没有设置好public key所致。\n在本机生成public key[参考github帮助](https://help.github.com/articles/connecting-to-github-with-ssh/)\n```\n$ ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\"\n```\n然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.\n然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。\n\n根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。\n\n部署方法二：\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。\n\n写一个发布脚本：deploy.sh\n```\nhexo generate\ncp -R public/* deploy/eagle.github.io\ncd deploy/eagle.github.io\ngit add .\ngit commit -m “update blog”\ngit push origin master\n```\n\n做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。\n\n至此，一个简单的博客建完  ^ - ^","source":"_posts/hexoGithubIo.md","raw":"---\ntitle: hexo + github.io\ndate: 2018-06-06 00:14:18\ntags: hexo\ncategories: 环境\n---\n\n### 第一步：需要的环境：\n   node环境  （[立即下载](https://nodejs.org/zh-cn/)）\n   git 环境  （[立即下载](https://git-scm.com/download/)）\n   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。\n    [安装 homebrw](https://brew.sh/)\n    [安装 yarn](https://yarnpkg.com/en/docs/install#mac-stable)\n### 第二步：安装 hexo:\n([也可以按照官方网站就行安装](https://hexo.io/zh-cn/docs/index.html))\n1. 安装 hexo\n```\n$ yarn add -g hexo-cli\n```\n2. 创建一个新的 hexo 项目\n```\n$ hexo init blog（项目名字）\ncd blog\n$ yarn install\n```\n3. 启动项目\n```\n$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000\n```\n\n项目文件结构为：\n\n![](/images/hexo-page.png)\n\n至此，我们本地的一个博客环境就已经搭建完成。\n常用的指令如下：([具体参数使用前查看详细文档](https://hexo.io/zh-cn/docs/commands.html))\n```\n$ hexo server = hexo s  // 启动项目\n$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage\n$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中\n$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）\n```\n### 第三步：更换主题\n现在为自己的博客找一个喜欢的主题：\n1. 进入[hexo 主题库](https://hexo.io/themes/)，选择一个自己喜欢的主题\n2. 点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来\n3. 将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字\n\n当前我所用的主题为 [clean-blog](https://github.com/klugjo/hexo-theme-clean-blog)\n\n### 第四步：搭建免费的 github.io 服务器\n\n首先明白什么是 github pages:\nGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。\n\n每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。\n\n***特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的***\n\n\n1. 注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。\n\n2. 将本地环境推上线上环境，\n    1. 首先需要知道，如果直接访问 http://eagle.github.io 的时候，他会直接去找根目录下的 index.html 的静态文件。\n    2. Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问\n    3. 需要将hexo生成的静态文件，提交 commit 推到github上\n\n部署的方法一：\nhexo deploy ，可以参考 [官方的文档](https://hexo.io/docs/deployment.html)\n\n安装 hexo-deployer-git\n```\n$ yarn add hexo-deployer-git\n```\n配置：_config.xml\n```\ndeploy:\n  type: git\n  repo: git@github.com:jiji262/jiji262.github.io.git\n  branch: master\n```\n执行：\n```\n$ hexo d\n```\n\n执行之后可能会报错：\n```\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n则是因为没有设置好public key所致。\n在本机生成public key[参考github帮助](https://help.github.com/articles/connecting-to-github-with-ssh/)\n```\n$ ssh-keygen -t rsa -b 4096 -C \"xxx@xxx.com\"\n```\n然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.\n然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。\n\n根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。\n\n部署方法二：\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。\n\n写一个发布脚本：deploy.sh\n```\nhexo generate\ncp -R public/* deploy/eagle.github.io\ncd deploy/eagle.github.io\ngit add .\ngit commit -m “update blog”\ngit push origin master\n```\n\n做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。\n\n至此，一个简单的博客建完  ^ - ^","slug":"hexoGithubIo","published":1,"updated":"2018-07-17T10:25:15.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd6j0005nzz940656xbw","content":"<h3 id=\"第一步：需要的环境：\"><a href=\"#第一步：需要的环境：\" class=\"headerlink\" title=\"第一步：需要的环境：\"></a>第一步：需要的环境：</h3><p>   node环境  （<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   git 环境  （<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。<br>    <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">安装 homebrw</a><br>    <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\" target=\"_blank\" rel=\"noopener\">安装 yarn</a></p>\n<h3 id=\"第二步：安装-hexo\"><a href=\"#第二步：安装-hexo\" class=\"headerlink\" title=\"第二步：安装 hexo:\"></a>第二步：安装 hexo:</h3><p>(<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">也可以按照官方网站就行安装</a>)</p>\n<ol>\n<li><p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个新的 hexo 项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog（项目名字）</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>项目文件结构为：</p>\n<p><img src=\"/images/hexo-page.png\" alt=\"\"></p>\n<p>至此，我们本地的一个博客环境就已经搭建完成。<br>常用的指令如下：(<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">具体参数使用前查看详细文档</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server = hexo s  // 启动项目</span><br><span class=\"line\">$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage</span><br><span class=\"line\">$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中</span><br><span class=\"line\">$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：更换主题\"><a href=\"#第三步：更换主题\" class=\"headerlink\" title=\"第三步：更换主题\"></a>第三步：更换主题</h3><p>现在为自己的博客找一个喜欢的主题：</p>\n<ol>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo 主题库</a>，选择一个自己喜欢的主题</li>\n<li>点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来</li>\n<li>将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字</li>\n</ol>\n<p>当前我所用的主题为 <a href=\"https://github.com/klugjo/hexo-theme-clean-blog\" target=\"_blank\" rel=\"noopener\">clean-blog</a></p>\n<h3 id=\"第四步：搭建免费的-github-io-服务器\"><a href=\"#第四步：搭建免费的-github-io-服务器\" class=\"headerlink\" title=\"第四步：搭建免费的 github.io 服务器\"></a>第四步：搭建免费的 github.io 服务器</h3><p>首先明白什么是 github pages:<br>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>\n<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。</p>\n<p><strong><em>特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的</em></strong></p>\n<ol>\n<li><p>注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。</p>\n</li>\n<li><p>将本地环境推上线上环境，</p>\n<ol>\n<li>首先需要知道，如果直接访问 <a href=\"http://eagle.github.io\" target=\"_blank\" rel=\"noopener\">http://eagle.github.io</a> 的时候，他会直接去找根目录下的 index.html 的静态文件。</li>\n<li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问</li>\n<li>需要将hexo生成的静态文件，提交 commit 推到github上</li>\n</ol>\n</li>\n</ol>\n<p>部署的方法一：<br>hexo deploy ，可以参考 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">官方的文档</a></p>\n<p>安装 hexo-deployer-git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure></p>\n<p>配置：_config.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>执行之后可能会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure></p>\n<p>则是因为没有设置好public key所致。<br>在本机生成public key<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">参考github帮助</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.<br>然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。</p>\n<p>根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。</p>\n<p>部署方法二：</p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。</p>\n<p>写一个发布脚本：deploy.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* deploy/eagle.github.io</span><br><span class=\"line\">cd deploy/eagle.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “update blog”</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p>做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。</p>\n<p>至此，一个简单的博客建完  ^ - ^</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"第一步：需要的环境：\"><a href=\"#第一步：需要的环境：\" class=\"headerlink\" title=\"第一步：需要的环境：\"></a>第一步：需要的环境：</h3><p>   node环境  （<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   git 环境  （<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">立即下载</a>）<br>   因为习惯使用 yarn，所以如果你的环境中没有 yarn，那就需要安装。<br>    <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">安装 homebrw</a><br>    <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\" target=\"_blank\" rel=\"noopener\">安装 yarn</a></p>\n<h3 id=\"第二步：安装-hexo\"><a href=\"#第二步：安装-hexo\" class=\"headerlink\" title=\"第二步：安装 hexo:\"></a>第二步：安装 hexo:</h3><p>(<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"noopener\">也可以按照官方网站就行安装</a>)</p>\n<ol>\n<li><p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add -g hexo-cli</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个新的 hexo 项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog（项目名字）</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server   // 启动之后再浏览器中打开 http://localhost:4000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>项目文件结构为：</p>\n<p><img src=\"/images/hexo-page.png\" alt=\"\"></p>\n<p>至此，我们本地的一个博客环境就已经搭建完成。<br>常用的指令如下：(<a href=\"https://hexo.io/zh-cn/docs/commands.html\" target=\"_blank\" rel=\"noopener\">具体参数使用前查看详细文档</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server = hexo s  // 启动项目</span><br><span class=\"line\">$ hexo new = hexo n   // 创建新的文章，如果想要创建一个新页面需要加 page ,例如：$ hexo new page newPage</span><br><span class=\"line\">$ hexo generate = hexo g  // 生成静态文件到 public 文件夹中</span><br><span class=\"line\">$ hexo deploy = hexo d   // 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：更换主题\"><a href=\"#第三步：更换主题\" class=\"headerlink\" title=\"第三步：更换主题\"></a>第三步：更换主题</h3><p>现在为自己的博客找一个喜欢的主题：</p>\n<ol>\n<li>进入<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">hexo 主题库</a>，选择一个自己喜欢的主题</li>\n<li>点击自己喜欢的主题名字，进入对应主题的 github 项目中，可以通过 download 或者 git clone 的方式将主题下载下来</li>\n<li>将下载下来的主题文件夹放在项目目中中的 themes 文件家中，修改 _config.yml 文件中的 theme 值为你下载的主题名字</li>\n</ol>\n<p>当前我所用的主题为 <a href=\"https://github.com/klugjo/hexo-theme-clean-blog\" target=\"_blank\" rel=\"noopener\">clean-blog</a></p>\n<h3 id=\"第四步：搭建免费的-github-io-服务器\"><a href=\"#第四步：搭建免费的-github-io-服务器\" class=\"headerlink\" title=\"第四步：搭建免费的 github.io 服务器\"></a>第四步：搭建免费的 github.io 服务器</h3><p>首先明白什么是 github pages:<br>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>\n<p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 来访问你的个人主页。</p>\n<p><strong><em>特别注意：新建的项目名字必须是 usename.github.io。个人主页的网站内容是在master分支下的</em></strong></p>\n<ol>\n<li><p>注册一个 github 账号，（例：用户名为eagle）激活之后，新建一个空项目名称为 eagle.github.io。</p>\n</li>\n<li><p>将本地环境推上线上环境，</p>\n<ol>\n<li>首先需要知道，如果直接访问 <a href=\"http://eagle.github.io\" target=\"_blank\" rel=\"noopener\">http://eagle.github.io</a> 的时候，他会直接去找根目录下的 index.html 的静态文件。</li>\n<li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问</li>\n<li>需要将hexo生成的静态文件，提交 commit 推到github上</li>\n</ol>\n</li>\n</ol>\n<p>部署的方法一：<br>hexo deploy ，可以参考 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">官方的文档</a></p>\n<p>安装 hexo-deployer-git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git</span><br></pre></td></tr></table></figure></p>\n<p>配置：_config.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>执行之后可能会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure></p>\n<p>则是因为没有设置好public key所致。<br>在本机生成public key<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"noopener\">参考github帮助</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 user_id/.ssh 目录下会生成两个文件，id_rsa.pub和id_rsa.<br>然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可。</p>\n<p>根据本人尝试，问题出在自己的 github 账户切换出现的奇怪的 bug，设置好各种 deploy key 或者 public key 之后任然不行的话，可以尝试手动推送项目。</p>\n<p>部署方法二：</p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做deploy用于存放克隆的代码。</p>\n<p>写一个发布脚本：deploy.sh<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* deploy/eagle.github.io</span><br><span class=\"line\">cd deploy/eagle.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “update blog”</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p>做的事情很简单：复制 public 文件中的代码到 depoly/eagle.github.io 文件中，提交 commit ，推送代码到远程。</p>\n<p>至此，一个简单的博客建完  ^ - ^</p>\n"},{"title":"js 继承方式","date":"2018-06-21T15:36:41.000Z","_content":"\nJS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。\n\n需要实现继承必须现有父类，首先定义一个父类。\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1. 原型链继承\n\n核心： 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.eat('fish'));\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); //true \n\nconsole.log(cat instanceof Cat); //true\n```\n\n> 补充小知识点： \n>\n> ` object instanceof constructor ` 中:\n> \n> instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。\n\n2. 父类新增原型方法/原型属性，子类都能访问到。\n\n3. 简单，易于实现。\n\n缺点：\n\n1. 如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。\n\n2. 无法实现多继承。\n\n3. 来自原型对象的引用属性是所有实例共享的。\n\n4. 创建子类实例时，无法向父类构造函数传参。\n\n## 2、构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); // false\n\nconsole.log(cat instanceof Cat); // true\n```\n\n> 补充小知识：\n> \n> call, apply 和 bind 的区别:\n>\n> 它们在功能上是没有区别的，都是改变 ` this ` 的指向。他们主要的区别是实现方式和传递的参数不同。\n> \n> 1. call: Fun.call(object, arg1, arg2....); \n> \n> 2. apply: Fun.apply(object, [arg1, arg2....]);\n> \n> 3. bind: Fun.bind(object, arg1, arg2, ....); \n> \n> 其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2...)），Fun 接受几个参数，后面的 arg 就有几个。\n\n特点：\n\n1. 可以实现多继承（call多个父类对象）\n\n2. 创建子类实例时，可以向父类传递参数\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）\n\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n## 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n\n2. 不支持多继承\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n## 5、组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n\n2. 既是子类的实例，也是父类的实例\n\n3. 不存在引用属性共享问题\n\n4. 可传参\n\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n## 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\nCat.prototype.constructor = Cat; // 需要修复下构造函数\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\\\n```","source":"_posts/js-继承方式.md","raw":"---\ntitle: js 继承方式\ndate: 2018-06-21 23:36:41\ntags: js\ncategories: js\n---\n\nJS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。\n\n需要实现继承必须现有父类，首先定义一个父类。\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1. 原型链继承\n\n核心： 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.eat('fish'));\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); //true \n\nconsole.log(cat instanceof Cat); //true\n```\n\n> 补充小知识点： \n>\n> ` object instanceof constructor ` 中:\n> \n> instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例。\n\n2. 父类新增原型方法/原型属性，子类都能访问到。\n\n3. 简单，易于实现。\n\n缺点：\n\n1. 如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。\n\n2. 无法实现多继承。\n\n3. 来自原型对象的引用属性是所有实例共享的。\n\n4. 创建子类实例时，无法向父类构造函数传参。\n\n## 2、构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\n\nconsole.log(cat.name);\n\nconsole.log(cat.sleep());\n\nconsole.log(cat instanceof Animal); // false\n\nconsole.log(cat instanceof Cat); // true\n```\n\n> 补充小知识：\n> \n> call, apply 和 bind 的区别:\n>\n> 它们在功能上是没有区别的，都是改变 ` this ` 的指向。他们主要的区别是实现方式和传递的参数不同。\n> \n> 1. call: Fun.call(object, arg1, arg2....); \n> \n> 2. apply: Fun.apply(object, [arg1, arg2....]);\n> \n> 3. bind: Fun.bind(object, arg1, arg2, ....); \n> \n> 其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2...)），Fun 接受几个参数，后面的 arg 就有几个。\n\n特点：\n\n1. 可以实现多继承（call多个父类对象）\n\n2. 创建子类实例时，可以向父类传递参数\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）\n\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n## 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n\n2. 不支持多继承\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n## 5、组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n\n2. 既是子类的实例，也是父类的实例\n\n3. 不存在引用属性共享问题\n\n4. 可传参\n\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n## 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\nCat.prototype.constructor = Cat; // 需要修复下构造函数\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\\\n```","slug":"js-继承方式","published":1,"updated":"2018-07-17T10:25:15.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd7n000inzz9gbe4372i","content":"<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。</p>\n<p>需要实现继承必须现有父类，首先定义一个父类。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h2><p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识点： </p>\n<p><code>object instanceof constructor</code> 中:</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例。</p>\n</li>\n<li><p>父类新增原型方法/原型属性，子类都能访问到。</p>\n</li>\n<li><p>简单，易于实现。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。</p>\n</li>\n<li><p>无法实现多继承。</p>\n</li>\n<li><p>来自原型对象的引用属性是所有实例共享的。</p>\n</li>\n<li><p>创建子类实例时，无法向父类构造函数传参。</p>\n</li>\n</ol>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识：</p>\n<p>call, apply 和 bind 的区别:</p>\n<p>它们在功能上是没有区别的，都是改变 <code>this</code> 的指向。他们主要的区别是实现方式和传递的参数不同。</p>\n<ol>\n<li><p>call: Fun.call(object, arg1, arg2….); </p>\n</li>\n<li><p>apply: Fun.apply(object, [arg1, arg2….]);</p>\n</li>\n<li><p>bind: Fun.bind(object, arg1, arg2, ….); </p>\n</li>\n</ol>\n<p>其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2…)），Fun 接受几个参数，后面的 arg 就有几个。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>可以实现多继承（call多个父类对象）</p>\n</li>\n<li><p>创建子类实例时，可以向父类传递参数</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）</p>\n</li>\n<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n</li>\n</ol>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例是父类的实例，不是子类的实例</p>\n</li>\n<li><p>不支持多继承</p>\n</li>\n</ol>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n</li>\n<li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n</li>\n</ol>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p>\n</li>\n<li><p>既是子类的实例，也是父类的实例</p>\n</li>\n<li><p>不存在引用属性共享问题</p>\n</li>\n<li><p>可传参</p>\n</li>\n<li><p>函数可复用</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; <span class=\"comment\">// 需要修复下构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true\\</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。</p>\n<p>需要实现继承必须现有父类，首先定义一个父类。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个动物类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Animal'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在睡觉！'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型方法</span></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃：'</span> + food);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h2><p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">Cat.prototype.name = <span class=\"string\">'cat'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//　Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识点： </p>\n<p><code>object instanceof constructor</code> 中:</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例。</p>\n</li>\n<li><p>父类新增原型方法/原型属性，子类都能访问到。</p>\n</li>\n<li><p>简单，易于实现。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。</p>\n</li>\n<li><p>无法实现多继承。</p>\n</li>\n<li><p>来自原型对象的引用属性是所有实例共享的。</p>\n</li>\n<li><p>创建子类实例时，无法向父类构造函数传参。</p>\n</li>\n</ol>\n<h2 id=\"2、构造继承\"><a href=\"#2、构造继承\" class=\"headerlink\" title=\"2、构造继承\"></a>2、构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充小知识：</p>\n<p>call, apply 和 bind 的区别:</p>\n<p>它们在功能上是没有区别的，都是改变 <code>this</code> 的指向。他们主要的区别是实现方式和传递的参数不同。</p>\n<ol>\n<li><p>call: Fun.call(object, arg1, arg2….); </p>\n</li>\n<li><p>apply: Fun.apply(object, [arg1, arg2….]);</p>\n</li>\n<li><p>bind: Fun.bind(object, arg1, arg2, ….); </p>\n</li>\n</ol>\n<p>其中 arg1、arg2 分别为 Fun 的参数（例如：Fun(arg1, arg2…)），Fun 接受几个参数，后面的 arg 就有几个。</p>\n</blockquote>\n<p>特点：</p>\n<ol>\n<li><p>可以实现多继承（call多个父类对象）</p>\n</li>\n<li><p>创建子类实例时，可以向父类传递参数</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法（需要进一步了解）</p>\n</li>\n<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n</li>\n</ol>\n<h2 id=\"3、实例继承\"><a href=\"#3、实例继承\" class=\"headerlink\" title=\"3、实例继承\"></a>3、实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  instance.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>不限制调用方式，不管是 new 子类() 还是子类(), 返回的对象具有相同的效果</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>实例是父类的实例，不是子类的实例</p>\n</li>\n<li><p>不支持多继承</p>\n</li>\n</ol>\n<h2 id=\"4、拷贝继承\"><a href=\"#4、拷贝继承\" class=\"headerlink\" title=\"4、拷贝继承\"></a>4、拷贝继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>支持多继承</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n</li>\n<li><p>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n</li>\n</ol>\n<h2 id=\"5、组合继承\"><a href=\"#5、组合继承\" class=\"headerlink\" title=\"5、组合继承\"></a>5、组合继承</h2><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li><p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</p>\n</li>\n<li><p>既是子类的实例，也是父类的实例</p>\n</li>\n<li><p>不存在引用属性共享问题</p>\n</li>\n<li><p>可传参</p>\n</li>\n<li><p>函数可复用</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>\n</ol>\n<h2 id=\"6、寄生组合继承\"><a href=\"#6、寄生组合继承\" class=\"headerlink\" title=\"6、寄生组合继承\"></a>6、寄生组合继承</h2><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></span><br><span class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; <span class=\"comment\">// 需要修复下构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test Code</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true\\</span></span><br></pre></td></tr></table></figure>"},{"title":"nextjs + postcss + typeScript","date":"2018-08-01T02:11:31.000Z","_content":"\n## nextjs + typescript + jest + postcss\n从零开始配置项目\n\n在 github 上 nextjs 的源码中，有集成好的 [examples](https://github.com/zeit/next.js/tree/canary/examples)，在使用过程中可以直接拿来做参考。\n\n## 一、 nextjs + typeScript\n\n[nextjs 官网](https://nextjs.org/)中有 nextjs 使用的文档，配置 ts 的方法有两种，\n\n#### 1. 使用 [with-jest-typescript](https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript)\n\n使用 `create-next-app`，通过 `yarn` 或者 `npx` 进行安装。\n\n```js\n$ npx create-next-app --example with-jest-typescript with-jest-typescript-app\n# 或者\n$ yarn create-next-app --example with-jest-typescript with-jest-typescript-app\n```\n\n运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板\n\n#### 2. 自己配置（未实践）\n\n1. 根据[官网文档](https://nextjs.org/docs/#setup)的 Getting Start 进行初始化项目\n2. 安装 ts ，添加 ts 相关配置。\n3. 安装 jest，添加 jest 相关配置。\n\n配置完之后：next.config.js 文件为：\n```js\nconst withTypescript = require('@zeit/next-typescript')\n\nmodule.exports = withTypescript()\n```\n\n## 二、配置 css\n\n1. 安装 `@zeit/next-css`\n\n```js\n$ npm install --save @zeit/next-css\n# or\n$ yarn add @zeit/next-css\n```\n\n2. 引入编译后的 css 文件\n\n项目运行之后的 css 文件会编译到 `.next/static/style.css`，我们需要在 `_document.js` 引入这个 css 文件 `/_next/static/style.css`\n\n例如：\n```jsx\n// ./pages/_document.js\nimport Document, { Head, Main, NextScript } from 'next/document'\n\nclass MyDocument extends Document {\n  render() {\n    return (\n      <html>\n        <Head>\n          <link rel=\"stylesheet\" href=\"/_next/static/style.css\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </html>\n    )\n  }\n}\n\nexport default MyDocument;\n```\n\n3. 配置 css 解析\n\n在 next.config.js 文件中配置 css 解析。\n\n```js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS())\n```\n\n此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport \"../style.css\"\n\nexport default () => <div className=\"example\">Hello World!</div>\n\n```\n\n4. css modules\n\n配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：\n\n```jsx\n// next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n}))\n```\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n._2Qh9GEqcE104osQujlJkZw {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n\n```\n\n5. 优化 css-loader 配置\n\n `css-loader` 的配置可以通过属性 `cssLoaderOptions` 添加一些其他的配置。\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  }\n}))\n ```\n\n 例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n.style-example-2Qh9G {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n```\n\n## 三、配置 postcss\n\n创建 postcss.config.js 文件：\n\n```js\n// 例如\nmodule.exports = {\n  plugins: {\n    // Illustrational\n    'postcss-css-variables': {}\n  }\n}\n```\n\n配置 postcss 解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n}))\n ```\n\n## 四、图片的加载\n\n#### 方法一\n通过 webpack 配置进行图片解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n  webpack(config) {\n        config.module.rules.push(\n            { test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/, loader: 'url-loader' }\n        )\n        return config;\n    }\n}))\n ```\n\n#### 方法二\n使用 [next-images](https://github.com/arefaslani/next-images)（未实践）\n\n具体配置方法请参考官网\n\n## 五、遇到的问题\n\n问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。\n\n解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：\n\n```jsx\nconst withTypescript = require('@zeit/next-typescript');\nconst withCSS = require('@zeit/next-css');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nconst StylelintPlugin = require('stylelint-webpack-plugin');\nconst webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = withTypescript({\n  webpack(config, options) {\n    const { dev, isServer } = options;\n\n    // Do not run type checking twice:\n    if (!isServer) {\n      config.plugins.push(\n        new ForkTsCheckerWebpackPlugin({\n          tslint: true,\n        }),\n        new StylelintPlugin({\n          files: '**/*.{ts,tsx}',\n          emitErrors: !dev,\n        }),\n      );\n    }\n    // 图片处理\n    config.module.rules.push({\n      test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/,\n      loader: 'url-loader',\n    });\n    // css 处理\n    config.module.rules.push({\n      oneOf: [\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          exclude: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            // Process external/third-party styles\n            {\n              loader: 'css-loader',\n              options: {\n                sourceMap: true,\n                minimize: false,\n                discardComments: { removeAll: true },\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          include: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            {\n              loader: require.resolve('typings-for-css-modules-loader'),\n              options: {\n                modules: true,\n                importLoaders: 1,\n                sourcemap: true,\n                localIdentName: '[name]-[local]-[hash:base64:5]',\n                discardComments: { removeAll: true },\n                namedExport: true,\n                camelCase: true,\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n      ],\n    });\n\n    return config;\n  },\n});\n\n```\n\n注意：原本只是使用 [style-loader](https://github.com/webpack-contrib/style-loader) 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader) 进行服务器端渲染的 css 解析。\n\n## 参考链接\n\n1. [nextjs 官网链接](https://nextjs.org/)\n2. [nextjs github 地址](https://github.com/zeit/next.js)\n3. [next-plugins](https://github.com/zeit/next-plugins)\n4. [next-images](https://github.com/arefaslani/next-images)\n5. [css-loader](https://github.com/webpack-contrib/css-loader)\n6. [style-loader](https://github.com/webpack-contrib/style-loader)\n7. [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader)\n8. [next.js/examples](https://github.com/zeit/next.js/tree/canary/examples)","source":"_posts/nextjs-postcss-typeScript.md","raw":"---\ntitle: nextjs + postcss + typeScript\ndate: 2018-08-01 10:11:31\ntags: ['nextjs', 'js', 'css']\n---\n\n## nextjs + typescript + jest + postcss\n从零开始配置项目\n\n在 github 上 nextjs 的源码中，有集成好的 [examples](https://github.com/zeit/next.js/tree/canary/examples)，在使用过程中可以直接拿来做参考。\n\n## 一、 nextjs + typeScript\n\n[nextjs 官网](https://nextjs.org/)中有 nextjs 使用的文档，配置 ts 的方法有两种，\n\n#### 1. 使用 [with-jest-typescript](https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript)\n\n使用 `create-next-app`，通过 `yarn` 或者 `npx` 进行安装。\n\n```js\n$ npx create-next-app --example with-jest-typescript with-jest-typescript-app\n# 或者\n$ yarn create-next-app --example with-jest-typescript with-jest-typescript-app\n```\n\n运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板\n\n#### 2. 自己配置（未实践）\n\n1. 根据[官网文档](https://nextjs.org/docs/#setup)的 Getting Start 进行初始化项目\n2. 安装 ts ，添加 ts 相关配置。\n3. 安装 jest，添加 jest 相关配置。\n\n配置完之后：next.config.js 文件为：\n```js\nconst withTypescript = require('@zeit/next-typescript')\n\nmodule.exports = withTypescript()\n```\n\n## 二、配置 css\n\n1. 安装 `@zeit/next-css`\n\n```js\n$ npm install --save @zeit/next-css\n# or\n$ yarn add @zeit/next-css\n```\n\n2. 引入编译后的 css 文件\n\n项目运行之后的 css 文件会编译到 `.next/static/style.css`，我们需要在 `_document.js` 引入这个 css 文件 `/_next/static/style.css`\n\n例如：\n```jsx\n// ./pages/_document.js\nimport Document, { Head, Main, NextScript } from 'next/document'\n\nclass MyDocument extends Document {\n  render() {\n    return (\n      <html>\n        <Head>\n          <link rel=\"stylesheet\" href=\"/_next/static/style.css\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </html>\n    )\n  }\n}\n\nexport default MyDocument;\n```\n\n3. 配置 css 解析\n\n在 next.config.js 文件中配置 css 解析。\n\n```js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS())\n```\n\n此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport \"../style.css\"\n\nexport default () => <div className=\"example\">Hello World!</div>\n\n```\n\n4. css modules\n\n配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：\n\n```jsx\n// next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n}))\n```\n\n例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n._2Qh9GEqcE104osQujlJkZw {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n\n```\n\n5. 优化 css-loader 配置\n\n `css-loader` 的配置可以通过属性 `cssLoaderOptions` 添加一些其他的配置。\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  }\n}))\n ```\n\n 例如：\n\n```jsx\n// css 文件 style.css\n.example {\n  color: red;\n}\n// 编译后的类名\n.style-example-2Qh9G {\n  color: red;\n}\n\n// pages 页面 pages/index.js\nimport style from \"../style.css\"\n\nexport default () => <div className={style.example}>Hello World!</div>\n```\n\n## 三、配置 postcss\n\n创建 postcss.config.js 文件：\n\n```js\n// 例如\nmodule.exports = {\n  plugins: {\n    // Illustrational\n    'postcss-css-variables': {}\n  }\n}\n```\n\n配置 postcss 解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n}))\n ```\n\n## 四、图片的加载\n\n#### 方法一\n通过 webpack 配置进行图片解析：\n\n ```js\n // next.config.js\nconst withTypescript = require('@zeit/next-typescript')\nconst withCSS = require('@zeit/next-css')\n\nmodule.exports = withTypescript(withCSS({\n  cssModules: true\n  cssLoaderOptions: {\n    // 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader\n    importLoaders: 1,  \n\n    // 指定编译类名方式为：模块名 + 类名 + 随机编码\n    localIdentName: '[name]-[local]-[hash:base64:5]',\n  },\n  postcssLoaderOptions: {\n    parser: true,\n    config: {\n      ctx: {\n        theme: JSON.stringify(process.env.REACT_APP_THEME)\n      }\n    }\n  }\n  webpack(config) {\n        config.module.rules.push(\n            { test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/, loader: 'url-loader' }\n        )\n        return config;\n    }\n}))\n ```\n\n#### 方法二\n使用 [next-images](https://github.com/arefaslani/next-images)（未实践）\n\n具体配置方法请参考官网\n\n## 五、遇到的问题\n\n问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。\n\n解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：\n\n```jsx\nconst withTypescript = require('@zeit/next-typescript');\nconst withCSS = require('@zeit/next-css');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nconst StylelintPlugin = require('stylelint-webpack-plugin');\nconst webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = withTypescript({\n  webpack(config, options) {\n    const { dev, isServer } = options;\n\n    // Do not run type checking twice:\n    if (!isServer) {\n      config.plugins.push(\n        new ForkTsCheckerWebpackPlugin({\n          tslint: true,\n        }),\n        new StylelintPlugin({\n          files: '**/*.{ts,tsx}',\n          emitErrors: !dev,\n        }),\n      );\n    }\n    // 图片处理\n    config.module.rules.push({\n      test: /\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/,\n      loader: 'url-loader',\n    });\n    // css 处理\n    config.module.rules.push({\n      oneOf: [\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          exclude: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            // Process external/third-party styles\n            {\n              loader: 'css-loader',\n              options: {\n                sourceMap: true,\n                minimize: false,\n                discardComments: { removeAll: true },\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n        {\n          test: /\\.(css|less|styl|scss|sass|sss)$/,\n          include: path.resolve(__dirname, './src'),\n          use: [\n            isServer\n              ? require.resolve('isomorphic-style-loader')\n              : require.resolve('style-loader'),\n            {\n              loader: require.resolve('typings-for-css-modules-loader'),\n              options: {\n                modules: true,\n                importLoaders: 1,\n                sourcemap: true,\n                localIdentName: '[name]-[local]-[hash:base64:5]',\n                discardComments: { removeAll: true },\n                namedExport: true,\n                camelCase: true,\n              },\n            },\n            {\n              loader: require.resolve('postcss-loader'),\n              options: {\n                config: {\n                  path: require.resolve('./postcss.config'),\n                },\n              },\n            },\n          ],\n        },\n      ],\n    });\n\n    return config;\n  },\n});\n\n```\n\n注意：原本只是使用 [style-loader](https://github.com/webpack-contrib/style-loader) 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader) 进行服务器端渲染的 css 解析。\n\n## 参考链接\n\n1. [nextjs 官网链接](https://nextjs.org/)\n2. [nextjs github 地址](https://github.com/zeit/next.js)\n3. [next-plugins](https://github.com/zeit/next-plugins)\n4. [next-images](https://github.com/arefaslani/next-images)\n5. [css-loader](https://github.com/webpack-contrib/css-loader)\n6. [style-loader](https://github.com/webpack-contrib/style-loader)\n7. [isomorphic-style-loader](https://github.com/kriasoft/isomorphic-style-loader)\n8. [next.js/examples](https://github.com/zeit/next.js/tree/canary/examples)","slug":"nextjs-postcss-typeScript","published":1,"updated":"2018-08-02T04:12:46.727Z","_id":"cjkahyd7q000knzz94wxq6wg9","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"nextjs-typescript-jest-postcss\"><a href=\"#nextjs-typescript-jest-postcss\" class=\"headerlink\" title=\"nextjs + typescript + jest + postcss\"></a>nextjs + typescript + jest + postcss</h2><p>从零开始配置项目</p>\n<p>在 github 上 nextjs 的源码中，有集成好的 <a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">examples</a>，在使用过程中可以直接拿来做参考。</p>\n<h2 id=\"一、-nextjs-typeScript\"><a href=\"#一、-nextjs-typeScript\" class=\"headerlink\" title=\"一、 nextjs + typeScript\"></a>一、 nextjs + typeScript</h2><p><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网</a>中有 nextjs 使用的文档，配置 ts 的方法有两种，</p>\n<h4 id=\"1-使用-with-jest-typescript\"><a href=\"#1-使用-with-jest-typescript\" class=\"headerlink\" title=\"1. 使用 with-jest-typescript\"></a>1. 使用 <a href=\"https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript\" target=\"_blank\" rel=\"noopener\">with-jest-typescript</a></h4><p>使用 <code>create-next-app</code>，通过 <code>yarn</code> 或者 <code>npx</code> 进行安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npx create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ yarn create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br></pre></td></tr></table></figure>\n<p>运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板</p>\n<h4 id=\"2-自己配置（未实践）\"><a href=\"#2-自己配置（未实践）\" class=\"headerlink\" title=\"2. 自己配置（未实践）\"></a>2. 自己配置（未实践）</h4><ol>\n<li>根据<a href=\"https://nextjs.org/docs/#setup\" target=\"_blank\" rel=\"noopener\">官网文档</a>的 Getting Start 进行初始化项目</li>\n<li>安装 ts ，添加 ts 相关配置。</li>\n<li>安装 jest，添加 jest 相关配置。</li>\n</ol>\n<p>配置完之后：next.config.js 文件为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、配置-css\"><a href=\"#二、配置-css\" class=\"headerlink\" title=\"二、配置 css\"></a>二、配置 css</h2><ol>\n<li>安装 <code>@zeit/next-css</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save @zeit/next-css</span><br><span class=\"line\"># or</span><br><span class=\"line\">$ yarn add @zeit/next-css</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>引入编译后的 css 文件</li>\n</ol>\n<p>项目运行之后的 css 文件会编译到 <code>.next/static/style.css</code>，我们需要在 <code>_document.js</code> 引入这个 css 文件 <code>/_next/static/style.css</code></p>\n<p>例如：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./pages/_document.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Document, &#123; Head, Main, NextScript &#125; <span class=\"keyword\">from</span> <span class=\"string\">'next/document'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDocument</span> <span class=\"keyword\">extends</span> <span class=\"title\">Document</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;html&gt;</span><br><span class=\"line\">        &lt;Head&gt;</span><br><span class=\"line\">          &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"/_next/static/style.css\"</span> /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Main /</span>&gt;</span><br><span class=\"line\">          &lt;NextScript /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>html&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyDocument;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>配置 css 解析</li>\n</ol>\n<p>在 next.config.js 文件中配置 css 解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS())</span><br></pre></td></tr></table></figure>\n<p>此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，</p>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=\"example\"&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>css modules</li>\n</ol>\n<p>配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">._2Qh9GEqcE104osQujlJkZw &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li><p>优化 css-loader 配置</p>\n<p><code>css-loader</code> 的配置可以通过属性 <code>cssLoaderOptions</code> 添加一些其他的配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">.style-example<span class=\"number\">-2</span>Qh9G &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、配置-postcss\"><a href=\"#三、配置-postcss\" class=\"headerlink\" title=\"三、配置 postcss\"></a>三、配置 postcss</h2><p>创建 postcss.config.js 文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Illustrational</span></span><br><span class=\"line\">    <span class=\"string\">'postcss-css-variables'</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置 postcss 解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、图片的加载\"><a href=\"#四、图片的加载\" class=\"headerlink\" title=\"四、图片的加载\"></a>四、图片的加载</h2><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>通过 webpack 配置进行图片解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  webpack(config) &#123;</span><br><span class=\"line\">        config.module.rules.push(</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader'</span> &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用 <a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a>（未实践）</p>\n<p>具体配置方法请参考官网</p>\n<h2 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h2><p>问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。</p>\n<p>解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ForkTsCheckerWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'fork-ts-checker-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> StylelintPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'stylelint-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(&#123;</span><br><span class=\"line\">  webpack(config, options) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dev, isServer &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do not run type checking twice:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isServer) &#123;</span><br><span class=\"line\">      config.plugins.push(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class=\"line\">          tslint: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> StylelintPlugin(&#123;</span><br><span class=\"line\">          files: <span class=\"string\">'**/*.&#123;ts,tsx&#125;'</span>,</span><br><span class=\"line\">          emitErrors: !dev,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 图片处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// css 处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      oneOf: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          exclude: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            <span class=\"comment\">// Process external/third-party styles</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                minimize: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          include: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'typings-for-css-modules-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                modules: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                importLoaders: <span class=\"number\">1</span>,</span><br><span class=\"line\">                sourcemap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                namedExport: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                camelCase: <span class=\"literal\">true</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意：原本只是使用 <a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a> 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 <a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a> 进行服务器端渲染的 css 解析。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网链接</a></li>\n<li><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"noopener\">nextjs github 地址</a></li>\n<li><a href=\"https://github.com/zeit/next-plugins\" target=\"_blank\" rel=\"noopener\">next-plugins</a></li>\n<li><a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a></li>\n<li><a href=\"https://github.com/webpack-contrib/css-loader\" target=\"_blank\" rel=\"noopener\">css-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a></li>\n<li><a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a></li>\n<li><a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">next.js/examples</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"nextjs-typescript-jest-postcss\"><a href=\"#nextjs-typescript-jest-postcss\" class=\"headerlink\" title=\"nextjs + typescript + jest + postcss\"></a>nextjs + typescript + jest + postcss</h2><p>从零开始配置项目</p>\n<p>在 github 上 nextjs 的源码中，有集成好的 <a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">examples</a>，在使用过程中可以直接拿来做参考。</p>\n<h2 id=\"一、-nextjs-typeScript\"><a href=\"#一、-nextjs-typeScript\" class=\"headerlink\" title=\"一、 nextjs + typeScript\"></a>一、 nextjs + typeScript</h2><p><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网</a>中有 nextjs 使用的文档，配置 ts 的方法有两种，</p>\n<h4 id=\"1-使用-with-jest-typescript\"><a href=\"#1-使用-with-jest-typescript\" class=\"headerlink\" title=\"1. 使用 with-jest-typescript\"></a>1. 使用 <a href=\"https://github.com/zeit/next.js/tree/canary/examples/with-jest-typescript\" target=\"_blank\" rel=\"noopener\">with-jest-typescript</a></h4><p>使用 <code>create-next-app</code>，通过 <code>yarn</code> 或者 <code>npx</code> 进行安装。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npx create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ yarn create-next-app --example <span class=\"keyword\">with</span>-jest-typescript <span class=\"keyword\">with</span>-jest-typescript-app</span><br></pre></td></tr></table></figure>\n<p>运行以上指令直接拷贝出一份已经集成好的 ts + jest 模板</p>\n<h4 id=\"2-自己配置（未实践）\"><a href=\"#2-自己配置（未实践）\" class=\"headerlink\" title=\"2. 自己配置（未实践）\"></a>2. 自己配置（未实践）</h4><ol>\n<li>根据<a href=\"https://nextjs.org/docs/#setup\" target=\"_blank\" rel=\"noopener\">官网文档</a>的 Getting Start 进行初始化项目</li>\n<li>安装 ts ，添加 ts 相关配置。</li>\n<li>安装 jest，添加 jest 相关配置。</li>\n</ol>\n<p>配置完之后：next.config.js 文件为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、配置-css\"><a href=\"#二、配置-css\" class=\"headerlink\" title=\"二、配置 css\"></a>二、配置 css</h2><ol>\n<li>安装 <code>@zeit/next-css</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save @zeit/next-css</span><br><span class=\"line\"># or</span><br><span class=\"line\">$ yarn add @zeit/next-css</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>引入编译后的 css 文件</li>\n</ol>\n<p>项目运行之后的 css 文件会编译到 <code>.next/static/style.css</code>，我们需要在 <code>_document.js</code> 引入这个 css 文件 <code>/_next/static/style.css</code></p>\n<p>例如：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./pages/_document.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Document, &#123; Head, Main, NextScript &#125; <span class=\"keyword\">from</span> <span class=\"string\">'next/document'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDocument</span> <span class=\"keyword\">extends</span> <span class=\"title\">Document</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;html&gt;</span><br><span class=\"line\">        &lt;Head&gt;</span><br><span class=\"line\">          &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"/_next/static/style.css\"</span> /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;Main /</span>&gt;</span><br><span class=\"line\">          &lt;NextScript /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>html&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyDocument;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>配置 css 解析</li>\n</ol>\n<p>在 next.config.js 文件中配置 css 解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS())</span><br></pre></td></tr></table></figure>\n<p>此时在每个项目中的 css 文件都可以正常编译和引入，但是没有模块化和类名编译，</p>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=\"example\"&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>css modules</li>\n</ol>\n<p>配置 css 模块化之后，每个模块编译之后的类名都是全局唯一的：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">._2Qh9GEqcE104osQujlJkZw &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li><p>优化 css-loader 配置</p>\n<p><code>css-loader</code> 的配置可以通过属性 <code>cssLoaderOptions</code> 添加一些其他的配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css 文件 style.css</span></span><br><span class=\"line\">.example &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译后的类名</span></span><br><span class=\"line\">.style-example<span class=\"number\">-2</span>Qh9G &#123;</span><br><span class=\"line\">  color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pages 页面 pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">\"../style.css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &lt;div className=&#123;style.example&#125;&gt;Hello World!&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、配置-postcss\"><a href=\"#三、配置-postcss\" class=\"headerlink\" title=\"三、配置 postcss\"></a>三、配置 postcss</h2><p>创建 postcss.config.js 文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Illustrational</span></span><br><span class=\"line\">    <span class=\"string\">'postcss-css-variables'</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置 postcss 解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、图片的加载\"><a href=\"#四、图片的加载\" class=\"headerlink\" title=\"四、图片的加载\"></a>四、图片的加载</h2><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>通过 webpack 配置进行图片解析：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// next.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(withCSS(&#123;</span><br><span class=\"line\">  cssModules: <span class=\"literal\">true</span></span><br><span class=\"line\">  cssLoaderOptions: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader</span></span><br><span class=\"line\">    importLoaders: <span class=\"number\">1</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定编译类名方式为：模块名 + 类名 + 随机编码</span></span><br><span class=\"line\">    localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcssLoaderOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      ctx: &#123;</span><br><span class=\"line\">        theme: <span class=\"built_in\">JSON</span>.stringify(process.env.REACT_APP_THEME)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  webpack(config) &#123;</span><br><span class=\"line\">        config.module.rules.push(</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'url-loader'</span> &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>使用 <a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a>（未实践）</p>\n<p>具体配置方法请参考官网</p>\n<h2 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h2><p>问题： 根据以上配置，最后会遇到一个问题，在 node_modules 里的 css 文件在项目执行时被编译打包，导致使用的第三方组件样式混乱。</p>\n<p>解决方案： 官方所处的 postcss 配置不能指定编译的路径，所以最后舍弃使用官方提供的 css 打包编译方式，使用原声的 webpack 配置解析 postcss。配置如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> withTypescript = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-typescript'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> withCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'@zeit/next-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ForkTsCheckerWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'fork-ts-checker-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> StylelintPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'stylelint-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = withTypescript(&#123;</span><br><span class=\"line\">  webpack(config, options) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dev, isServer &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do not run type checking twice:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isServer) &#123;</span><br><span class=\"line\">      config.plugins.push(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ForkTsCheckerWebpackPlugin(&#123;</span><br><span class=\"line\">          tslint: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> StylelintPlugin(&#123;</span><br><span class=\"line\">          files: <span class=\"string\">'**/*.&#123;ts,tsx&#125;'</span>,</span><br><span class=\"line\">          emitErrors: !dev,</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 图片处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.(png|jpeg|svg|jpg|gif|eot|ttf|woff)$/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// css 处理</span></span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      oneOf: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          exclude: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            <span class=\"comment\">// Process external/third-party styles</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                minimize: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.(css|less|styl|scss|sass|sss)$/</span>,</span><br><span class=\"line\">          include: path.resolve(__dirname, <span class=\"string\">'./src'</span>),</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            isServer</span><br><span class=\"line\">              ? <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'isomorphic-style-loader'</span>)</span><br><span class=\"line\">              : <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'typings-for-css-modules-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                modules: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                importLoaders: <span class=\"number\">1</span>,</span><br><span class=\"line\">                sourcemap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                localIdentName: <span class=\"string\">'[name]-[local]-[hash:base64:5]'</span>,</span><br><span class=\"line\">                discardComments: &#123; <span class=\"attr\">removeAll</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                namedExport: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                camelCase: <span class=\"literal\">true</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                config: &#123;</span><br><span class=\"line\">                  path: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'./postcss.config'</span>),</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意：原本只是使用 <a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a> 解析 css ，但是存在服务器端渲染问题，会报错：window is undefined。通过查询最后我们选择了 <a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a> 进行服务器端渲染的 css 解析。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener\">nextjs 官网链接</a></li>\n<li><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"noopener\">nextjs github 地址</a></li>\n<li><a href=\"https://github.com/zeit/next-plugins\" target=\"_blank\" rel=\"noopener\">next-plugins</a></li>\n<li><a href=\"https://github.com/arefaslani/next-images\" target=\"_blank\" rel=\"noopener\">next-images</a></li>\n<li><a href=\"https://github.com/webpack-contrib/css-loader\" target=\"_blank\" rel=\"noopener\">css-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a></li>\n<li><a href=\"https://github.com/kriasoft/isomorphic-style-loader\" target=\"_blank\" rel=\"noopener\">isomorphic-style-loader</a></li>\n<li><a href=\"https://github.com/zeit/next.js/tree/canary/examples\" target=\"_blank\" rel=\"noopener\">next.js/examples</a></li>\n</ol>\n"},{"title":"let、var、const","date":"2018-06-22T03:20:15.000Z","_content":"\nlet、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。\n\n## 首先来说 let 和 var 的异同。\n\n` let ` 声明的用法与 ` var ` 一致，` let ` 声明的变量可以把变量限制在作用域的代码中。\n\n1. 声明后未赋值，表现相同\n\n```\n(function() {\n  var varTest;\n  let letTest;\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 undefined\n}());\n```\n\n2. 使用未声明的变量，表现不同\n\n```\n(function() {\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 Error: letTest is not defined\n\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n}());\n```\n\n3. 不允许重复申明一个变量\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  var varTest = 'varTest changed.';\n  let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared\n\n  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)\n  console.log(letTest);\n}());\n```\n\n4. 不同作用域申明变量不一样\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  {\n    var varTest = 'varTest changed.';\n    let letTest = 'letTest changed.';\n  }\n\n  console.log(varTest); //输出\"varTest changed.\"，内部\"{}\"中声明的varTest变量覆盖外部的letTest声明\n  console.log(letTest); //输出\"test let OK.\"，内部\"{}\"中声明的letTest和外部的letTest不是同一个变量\n}());\n```\n\n## const\n\n1. ` const ` 声明的是常量，起止一旦设定后不可修改。因此，` const ` 常量声明是必须进行初始化。\n\n2.  ` const ` 声明的常量和 ` let ` 一样都有作用域的限制。\n\n3. 常量也不可以重复声明变量，无论该变量是 ` var ` 或者 ` let ` 声明的。","source":"_posts/let-vs-var.md","raw":"---\ntitle: let、var、const\ndate: 2018-06-22 11:20:15\ntags: js\ncategories: js\n---\n\nlet、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。\n\n## 首先来说 let 和 var 的异同。\n\n` let ` 声明的用法与 ` var ` 一致，` let ` 声明的变量可以把变量限制在作用域的代码中。\n\n1. 声明后未赋值，表现相同\n\n```\n(function() {\n  var varTest;\n  let letTest;\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 undefined\n}());\n```\n\n2. 使用未声明的变量，表现不同\n\n```\n(function() {\n  console.log(varTest); //输出 undefined\n  console.log(letTest); //输出 Error: letTest is not defined\n\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n}());\n```\n\n3. 不允许重复申明一个变量\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  var varTest = 'varTest changed.';\n  let letTest = 'letTest changed.'; //直接报错：SyntaxError: Identifier 'letTest' has already been declared\n\n  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)\n  console.log(letTest);\n}());\n```\n\n4. 不同作用域申明变量不一样\n\n```\n(function() {\n  var varTest = 'test var OK.';\n  let letTest = 'test let OK.';\n\n  {\n    var varTest = 'varTest changed.';\n    let letTest = 'letTest changed.';\n  }\n\n  console.log(varTest); //输出\"varTest changed.\"，内部\"{}\"中声明的varTest变量覆盖外部的letTest声明\n  console.log(letTest); //输出\"test let OK.\"，内部\"{}\"中声明的letTest和外部的letTest不是同一个变量\n}());\n```\n\n## const\n\n1. ` const ` 声明的是常量，起止一旦设定后不可修改。因此，` const ` 常量声明是必须进行初始化。\n\n2.  ` const ` 声明的常量和 ` let ` 一样都有作用域的限制。\n\n3. 常量也不可以重复声明变量，无论该变量是 ` var ` 或者 ` let ` 声明的。","slug":"let-vs-var","published":1,"updated":"2018-07-17T10:25:15.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd7t000onzz9oau0i1go","content":"<p>let、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。</p>\n<h2 id=\"首先来说-let-和-var-的异同。\"><a href=\"#首先来说-let-和-var-的异同。\" class=\"headerlink\" title=\"首先来说 let 和 var 的异同。\"></a>首先来说 let 和 var 的异同。</h2><p><code>let</code> 声明的用法与 <code>var</code> 一致，<code>let</code> 声明的变量可以把变量限制在作用域的代码中。</p>\n<ol>\n<li>声明后未赋值，表现相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest;</span><br><span class=\"line\">  let letTest;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 undefined</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用未声明的变量，表现不同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 Error: letTest is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>不允许重复申明一个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">  let letTest = &apos;letTest changed.&apos;; //直接报错：SyntaxError: Identifier &apos;letTest&apos; has already been declared</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span><br><span class=\"line\">  console.log(letTest);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不同作用域申明变量不一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">    let letTest = &apos;letTest changed.&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明</span><br><span class=\"line\">  console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><p><code>const</code> 声明的是常量，起止一旦设定后不可修改。因此，<code>const</code> 常量声明是必须进行初始化。</p>\n</li>\n<li><p><code>const</code> 声明的常量和 <code>let</code> 一样都有作用域的限制。</p>\n</li>\n<li><p>常量也不可以重复声明变量，无论该变量是 <code>var</code> 或者 <code>let</code> 声明的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>let、var、const 都是用来声明变量的，但是 let 、const 是为了了弥补 var 在作用域上的一些缺陷而引入的，同时在 ES6 中引入块级作用域。</p>\n<h2 id=\"首先来说-let-和-var-的异同。\"><a href=\"#首先来说-let-和-var-的异同。\" class=\"headerlink\" title=\"首先来说 let 和 var 的异同。\"></a>首先来说 let 和 var 的异同。</h2><p><code>let</code> 声明的用法与 <code>var</code> 一致，<code>let</code> 声明的变量可以把变量限制在作用域的代码中。</p>\n<ol>\n<li>声明后未赋值，表现相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest;</span><br><span class=\"line\">  let letTest;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 undefined</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用未声明的变量，表现不同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  console.log(varTest); //输出 undefined</span><br><span class=\"line\">  console.log(letTest); //输出 Error: letTest is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>不允许重复申明一个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">  let letTest = &apos;letTest changed.&apos;; //直接报错：SyntaxError: Identifier &apos;letTest&apos; has already been declared</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出varTest changed.(注意要注释掉上面letTest变量的重复声明才能运行)</span><br><span class=\"line\">  console.log(letTest);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不同作用域申明变量不一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  var varTest = &apos;test var OK.&apos;;</span><br><span class=\"line\">  let letTest = &apos;test let OK.&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    var varTest = &apos;varTest changed.&apos;;</span><br><span class=\"line\">    let letTest = &apos;letTest changed.&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(varTest); //输出&quot;varTest changed.&quot;，内部&quot;&#123;&#125;&quot;中声明的varTest变量覆盖外部的letTest声明</span><br><span class=\"line\">  console.log(letTest); //输出&quot;test let OK.&quot;，内部&quot;&#123;&#125;&quot;中声明的letTest和外部的letTest不是同一个变量</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><p><code>const</code> 声明的是常量，起止一旦设定后不可修改。因此，<code>const</code> 常量声明是必须进行初始化。</p>\n</li>\n<li><p><code>const</code> 声明的常量和 <code>let</code> 一样都有作用域的限制。</p>\n</li>\n<li><p>常量也不可以重复声明变量，无论该变量是 <code>var</code> 或者 <code>let</code> 声明的。</p>\n</li>\n</ol>\n"},{"title":"cookie、localStorage 和 sessionStorage","date":"2018-06-23T14:23:28.000Z","_content":"\n### Cookie\n\ncookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n### LocalStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。\n\nlocalStorage的优势\n\n1、localStorage 拓展了cookie 的 4K 限制\n\n2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\nlocalStorage的局限\n\n1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n\n2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n\n3、localStorage在浏览器的隐私模式下面是不可读取的\n\n4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n\n5、localStorage不能被爬虫抓取到\n\n### SessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n### 三者的异同\n\n特性 | Cookie | localStorage | sessionStorage\n---- | --- | --- | ---\n数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除\n存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB\n与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信\n易用性\t | 需要程序员自己封装，源生的Cookie接口不友好\t | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n### 使用\n\n#### 1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\n\n```js\nif(window.localStorage){\n    alert(\"浏览支持localStorage\")\n}else{\n   alert(\"浏览暂不支持localStorage\")\n}\n\n//或者\nif(typeof window.localStorage == 'undefined'){\n    alert(\"浏览暂不支持localStorage\")\n}\n```\n\n#### 2. setItem 存储数据 value（将value存储到key字段）\n\nlocalStorage 只支持 string 类型的存储。\n\n这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage\n\n```js\n<!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 -->\n\nconst storage=window.localStorage;\n\n// 存储数据方法一\nstorage[\"a\"]=1;\n\n// 存储数据方法二\nstorage.a=1;\n\n// 存储数据方法三（官方支持）\nlocalStorage.setItem(\"site\", \"js8.in\");\n\nsessionStorage.setItem(\"key\", \"value\");\n\nconsole.log(typeof storage[\"a\"]);  // 输出：string，原本存入的值是 int 类型，输出的是 string\nconsole.log(typeof storage[\"b\"]);  // 输出：string\nconsole.log(typeof storage[\"c\"]);  // 输出：string\n```\n\n#### 3. getItem 获取 value（获取指定key本地存储的值）\n\n```js\nconst value = sessionStorage.getItem(\"key\");\nconst site = localStorage.getItem(\"site\");\n```\n\n#### 4. removeItem 删除 key（删除指定key本地存储的值）\n\n```js\nsessionStorage.removeItem(\"key\");\nlocalStorage.removeItem(\"site\");\n```\n\nclear 清除所有的 key/value\n\n```js\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n","source":"_posts/localStorage-sessionStorage.md","raw":"---\ntitle: cookie、localStorage 和 sessionStorage\ndate: 2018-06-23 22:23:28\ntags: html\ncategories: html\n---\n\n### Cookie\n\ncookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n### LocalStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。\n\nlocalStorage的优势\n\n1、localStorage 拓展了cookie 的 4K 限制\n\n2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的\n\nlocalStorage的局限\n\n1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n\n2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n\n3、localStorage在浏览器的隐私模式下面是不可读取的\n\n4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n\n5、localStorage不能被爬虫抓取到\n\n### SessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n### 三者的异同\n\n特性 | Cookie | localStorage | sessionStorage\n---- | --- | --- | ---\n数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除\n存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB\n与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信\n易用性\t | 需要程序员自己封装，源生的Cookie接口不友好\t | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n### 使用\n\n#### 1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\n\n```js\nif(window.localStorage){\n    alert(\"浏览支持localStorage\")\n}else{\n   alert(\"浏览暂不支持localStorage\")\n}\n\n//或者\nif(typeof window.localStorage == 'undefined'){\n    alert(\"浏览暂不支持localStorage\")\n}\n```\n\n#### 2. setItem 存储数据 value（将value存储到key字段）\n\nlocalStorage 只支持 string 类型的存储。\n\n这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage\n\n```js\n<!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 -->\n\nconst storage=window.localStorage;\n\n// 存储数据方法一\nstorage[\"a\"]=1;\n\n// 存储数据方法二\nstorage.a=1;\n\n// 存储数据方法三（官方支持）\nlocalStorage.setItem(\"site\", \"js8.in\");\n\nsessionStorage.setItem(\"key\", \"value\");\n\nconsole.log(typeof storage[\"a\"]);  // 输出：string，原本存入的值是 int 类型，输出的是 string\nconsole.log(typeof storage[\"b\"]);  // 输出：string\nconsole.log(typeof storage[\"c\"]);  // 输出：string\n```\n\n#### 3. getItem 获取 value（获取指定key本地存储的值）\n\n```js\nconst value = sessionStorage.getItem(\"key\");\nconst site = localStorage.getItem(\"site\");\n```\n\n#### 4. removeItem 删除 key（删除指定key本地存储的值）\n\n```js\nsessionStorage.removeItem(\"key\");\nlocalStorage.removeItem(\"site\");\n```\n\nclear 清除所有的 key/value\n\n```js\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n","slug":"localStorage-sessionStorage","published":1,"updated":"2018-07-17T10:25:15.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd7v000pnzz9j8lz4ffp","content":"<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>cookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。</p>\n<p>localStorage的优势</p>\n<p>1、localStorage 拓展了cookie 的 4K 限制</p>\n<p>2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>\n<p>localStorage的局限</p>\n<p>1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</p>\n<p>2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</p>\n<p>3、localStorage在浏览器的隐私模式下面是不可读取的</p>\n<p>4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>\n<p>5、localStorage不能被爬虫抓取到</p>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<h3 id=\"三者的异同\"><a href=\"#三者的异同\" class=\"headerlink\" title=\"三者的异同\"></a>三者的异同</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>一般为5MB</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\"><a href=\"#1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\" class=\"headerlink\" title=\"1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\"></a>1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.localStorage)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览支持localStorage\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.localStorage == <span class=\"string\">'undefined'</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-setItem-存储数据-value（将value存储到key字段）\"><a href=\"#2-setItem-存储数据-value（将value存储到key字段）\" class=\"headerlink\" title=\"2. setItem 存储数据 value（将value存储到key字段）\"></a>2. setItem 存储数据 value（将value存储到key字段）</h4><p>localStorage 只支持 string 类型的存储。</p>\n<p>这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage=<span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法一</span></span><br><span class=\"line\">storage[<span class=\"string\">\"a\"</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法二</span></span><br><span class=\"line\">storage.a=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法三（官方支持）</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">\"site\"</span>, <span class=\"string\">\"js8.in\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage.setItem(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"a\"</span>]);  <span class=\"comment\">// 输出：string，原本存入的值是 int 类型，输出的是 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"b\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"c\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-getItem-获取-value（获取指定key本地存储的值）\"><a href=\"#3-getItem-获取-value（获取指定key本地存储的值）\" class=\"headerlink\" title=\"3. getItem 获取 value（获取指定key本地存储的值）\"></a>3. getItem 获取 value（获取指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = sessionStorage.getItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> site = localStorage.getItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-removeItem-删除-key（删除指定key本地存储的值）\"><a href=\"#4-removeItem-删除-key（删除指定key本地存储的值）\" class=\"headerlink\" title=\"4. removeItem 删除 key（删除指定key本地存储的值）\"></a>4. removeItem 删除 key（删除指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<p>clear 清除所有的 key/value</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>cookie 非常小，它的大小限制为4KB左右，它的主要用途有保存登录信息。比如“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p>localStorage 是 HTML5 标准中新加入的技术。在 IE 6 时代有一个常用的 userData 用作本地存储，当时为了考虑兼容性，使用更多的是 Flash。现在 localStorage 被大多数浏览器支持。</p>\n<p>localStorage的优势</p>\n<p>1、localStorage 拓展了cookie 的 4K 限制</p>\n<p>2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p>\n<p>localStorage的局限</p>\n<p>1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</p>\n<p>2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</p>\n<p>3、localStorage在浏览器的隐私模式下面是不可读取的</p>\n<p>4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>\n<p>5、localStorage不能被爬虫抓取到</p>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>\n<h3 id=\"三者的异同\"><a href=\"#三者的异同\" class=\"headerlink\" title=\"三者的异同\"></a>三者的异同</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Cookie</th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据的生命期</td>\n<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>\n<td>除非被清除，否则永久保存</td>\n<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>\n</tr>\n<tr>\n<td>存放数据大小</td>\n<td>4K左右</td>\n<td>一般为5MB</td>\n<td>一般为5MB</td>\n</tr>\n<tr>\n<td>与服务器端通信</td>\n<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>\n<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>需要程序员自己封装，源生的Cookie接口不友好</td>\n<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\"><a href=\"#1-在使用-localStorage-或者-sessionStorage-之前需要对浏览器的是否支持进行判断，如下：\" class=\"headerlink\" title=\"1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：\"></a>1. 在使用 localStorage 或者 sessionStorage 之前需要对浏览器的是否支持进行判断，如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.localStorage)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览支持localStorage\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.localStorage == <span class=\"string\">'undefined'</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"浏览暂不支持localStorage\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-setItem-存储数据-value（将value存储到key字段）\"><a href=\"#2-setItem-存储数据-value（将value存储到key字段）\" class=\"headerlink\" title=\"2. setItem 存储数据 value（将value存储到key字段）\"></a>2. setItem 存储数据 value（将value存储到key字段）</h4><p>localStorage 只支持 string 类型的存储。</p>\n<p>这里要特别说明一下localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在浏览器支持 localStorage 和 sessionStorage 的条件下 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage=<span class=\"built_in\">window</span>.localStorage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法一</span></span><br><span class=\"line\">storage[<span class=\"string\">\"a\"</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法二</span></span><br><span class=\"line\">storage.a=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储数据方法三（官方支持）</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">\"site\"</span>, <span class=\"string\">\"js8.in\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage.setItem(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"a\"</span>]);  <span class=\"comment\">// 输出：string，原本存入的值是 int 类型，输出的是 string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"b\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> storage[<span class=\"string\">\"c\"</span>]);  <span class=\"comment\">// 输出：string</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-getItem-获取-value（获取指定key本地存储的值）\"><a href=\"#3-getItem-获取-value（获取指定key本地存储的值）\" class=\"headerlink\" title=\"3. getItem 获取 value（获取指定key本地存储的值）\"></a>3. getItem 获取 value（获取指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = sessionStorage.getItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> site = localStorage.getItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-removeItem-删除-key（删除指定key本地存储的值）\"><a href=\"#4-removeItem-删除-key（删除指定key本地存储的值）\" class=\"headerlink\" title=\"4. removeItem 删除 key（删除指定key本地存储的值）\"></a>4. removeItem 删除 key（删除指定key本地存储的值）</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"site\"</span>);</span><br></pre></td></tr></table></figure>\n<p>clear 清除所有的 key/value</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n"},{"title":"mobile-modal-scroll","date":"2018-07-31T03:03:09.000Z","_content":"\n# 移动端滚动穿透解决方案:\n\n移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。\n\n现在总结一下三种解决方案：\n\n### 1. css 之 `overflow: hidden`\n\n当页面弹出 modal 之后，将 `.HTML_MODAL_OPEN` 添加到 `html` 上，并且禁止 html 和 body 的滚动。\n\n```css\n.HTML_MODAL_OPEN {\n  &, body {\n    overflow: hidden;\n    height: 100vh;\n  }\n}\n```\n\n缺点：\n\n1. 由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。\n2. 页面的背景还是能够有滚的动的效果\n\n### 2. js 之 preventDefault\n\n添加监听事件：\n\n```js\nmodal.addEventListener('touchmove', function(e) {\n  e.preventDefault();\n}, false);\n```\n\n缺点：\n\n1. modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。\n\n### 3. js + css 值 `position: fixed`\n\n参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：\n\ncss 部分：\n\n```css\nbody.BODY_MODAL_OPEN {\n    position: fixed;\n    width: 100%;\n}\n```\n\njs 部分：\n所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。\n\n```js\nconst scrollTop;  // 记录上次的滚动位置\n\nfunction setDocumentScroll(isShowModal) {\n    if (isShowModal) {\n      scrollTop = document.scrollingElement.scrollTop;\n      document.body.classList.add('BODY_MODAL_OPEN');\n      document.body.style.top = -scrollTop + 'px';\n      return;\n    }\n\n    // modal 隐藏回复 body 的原滚动位置\n    document.body.classList.remove('BODY_MODAL_OPEN');\n    document.scrollingElement.scrollTop = scrollTop;\n    document.body.style.top = '0';\n}\n```\n\n\n#### 参考\nhttps://uedsky.com/2016-06/mobile-modal-scroll/","source":"_posts/mobile-modal-scroll.md","raw":"---\ntitle: mobile-modal-scroll\ndate: 2018-07-31 11:03:09\ntags: ['js', 'css']\ncategories: js\n---\n\n# 移动端滚动穿透解决方案:\n\n移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。\n\n现在总结一下三种解决方案：\n\n### 1. css 之 `overflow: hidden`\n\n当页面弹出 modal 之后，将 `.HTML_MODAL_OPEN` 添加到 `html` 上，并且禁止 html 和 body 的滚动。\n\n```css\n.HTML_MODAL_OPEN {\n  &, body {\n    overflow: hidden;\n    height: 100vh;\n  }\n}\n```\n\n缺点：\n\n1. 由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。\n2. 页面的背景还是能够有滚的动的效果\n\n### 2. js 之 preventDefault\n\n添加监听事件：\n\n```js\nmodal.addEventListener('touchmove', function(e) {\n  e.preventDefault();\n}, false);\n```\n\n缺点：\n\n1. modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。\n\n### 3. js + css 值 `position: fixed`\n\n参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：\n\ncss 部分：\n\n```css\nbody.BODY_MODAL_OPEN {\n    position: fixed;\n    width: 100%;\n}\n```\n\njs 部分：\n所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。\n\n```js\nconst scrollTop;  // 记录上次的滚动位置\n\nfunction setDocumentScroll(isShowModal) {\n    if (isShowModal) {\n      scrollTop = document.scrollingElement.scrollTop;\n      document.body.classList.add('BODY_MODAL_OPEN');\n      document.body.style.top = -scrollTop + 'px';\n      return;\n    }\n\n    // modal 隐藏回复 body 的原滚动位置\n    document.body.classList.remove('BODY_MODAL_OPEN');\n    document.scrollingElement.scrollTop = scrollTop;\n    document.body.style.top = '0';\n}\n```\n\n\n#### 参考\nhttps://uedsky.com/2016-06/mobile-modal-scroll/","slug":"mobile-modal-scroll","published":1,"updated":"2018-07-31T03:57:47.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd7w000qnzz9k3wt4z9y","content":"<h1 id=\"移动端滚动穿透解决方案\"><a href=\"#移动端滚动穿透解决方案\" class=\"headerlink\" title=\"移动端滚动穿透解决方案:\"></a>移动端滚动穿透解决方案:</h1><p>移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。</p>\n<p>现在总结一下三种解决方案：</p>\n<h3 id=\"1-css-之-overflow-hidden\"><a href=\"#1-css-之-overflow-hidden\" class=\"headerlink\" title=\"1. css 之 overflow: hidden\"></a>1. css 之 <code>overflow: hidden</code></h3><p>当页面弹出 modal 之后，将 <code>.HTML_MODAL_OPEN</code> 添加到 <code>html</code> 上，并且禁止 html 和 body 的滚动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.HTML_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">  &amp;, body &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100<span class=\"selector-tag\">vh</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。</li>\n<li>页面的背景还是能够有滚的动的效果</li>\n</ol>\n<h3 id=\"2-js-之-preventDefault\"><a href=\"#2-js-之-preventDefault\" class=\"headerlink\" title=\"2. js 之 preventDefault\"></a>2. js 之 preventDefault</h3><p>添加监听事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modal.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。</li>\n</ol>\n<h3 id=\"3-js-css-值-position-fixed\"><a href=\"#3-js-css-值-position-fixed\" class=\"headerlink\" title=\"3. js + css 值 position: fixed\"></a>3. js + css 值 <code>position: fixed</code></h3><p>参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：</p>\n<p>css 部分：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.BODY_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>js 部分：<br>所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scrollTop;  <span class=\"comment\">// 记录上次的滚动位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setDocumentScroll</span>(<span class=\"params\">isShowModal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isShowModal) &#123;</span><br><span class=\"line\">      scrollTop = <span class=\"built_in\">document</span>.scrollingElement.scrollTop;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.add(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.style.top = -scrollTop + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// modal 隐藏回复 body 的原滚动位置</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.classList.remove(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.style.top = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://uedsky.com/2016-06/mobile-modal-scroll/\" target=\"_blank\" rel=\"noopener\">https://uedsky.com/2016-06/mobile-modal-scroll/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"移动端滚动穿透解决方案\"><a href=\"#移动端滚动穿透解决方案\" class=\"headerlink\" title=\"移动端滚动穿透解决方案:\"></a>移动端滚动穿透解决方案:</h1><p>移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。</p>\n<p>现在总结一下三种解决方案：</p>\n<h3 id=\"1-css-之-overflow-hidden\"><a href=\"#1-css-之-overflow-hidden\" class=\"headerlink\" title=\"1. css 之 overflow: hidden\"></a>1. css 之 <code>overflow: hidden</code></h3><p>当页面弹出 modal 之后，将 <code>.HTML_MODAL_OPEN</code> 添加到 <code>html</code> 上，并且禁止 html 和 body 的滚动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.HTML_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">  &amp;, body &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100<span class=\"selector-tag\">vh</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失。</li>\n<li>页面的背景还是能够有滚的动的效果</li>\n</ol>\n<h3 id=\"2-js-之-preventDefault\"><a href=\"#2-js-之-preventDefault\" class=\"headerlink\" title=\"2. js 之 preventDefault\"></a>2. js 之 preventDefault</h3><p>添加监听事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modal.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>modal 层里不能有其它需要滚动的内容。滚动事件会被一起禁止掉。</li>\n</ol>\n<h3 id=\"3-js-css-值-position-fixed\"><a href=\"#3-js-css-值-position-fixed\" class=\"headerlink\" title=\"3. js + css 值 position: fixed\"></a>3. js + css 值 <code>position: fixed</code></h3><p>参考很多做法，最后发现能完美解决这个问题只有 js 和 css 配合才可以。解决方案如下：</p>\n<p>css 部分：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.BODY_MODAL_OPEN</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>js 部分：<br>所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scrollTop;  <span class=\"comment\">// 记录上次的滚动位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setDocumentScroll</span>(<span class=\"params\">isShowModal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isShowModal) &#123;</span><br><span class=\"line\">      scrollTop = <span class=\"built_in\">document</span>.scrollingElement.scrollTop;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.add(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.style.top = -scrollTop + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// modal 隐藏回复 body 的原滚动位置</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.classList.remove(<span class=\"string\">'BODY_MODAL_OPEN'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.style.top = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://uedsky.com/2016-06/mobile-modal-scroll/\" target=\"_blank\" rel=\"noopener\">https://uedsky.com/2016-06/mobile-modal-scroll/</a></p>\n"},{"title":"React 生命周期详解","date":"2018-06-28T15:25:26.000Z","_content":"\n## 组件渲染顺序\n\n### 第一次 render\n\n第一次在`客户端`渲染：\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n5.  componentDidMount\n\n第一次在`服务端`渲染\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n\ncomponentDidMount 不会在服务端被渲染的过程中调用。\ngetDefaultProps 相当于 ES6 中 `staticdefaultProps = {}`\ngetInitialState 相当于 constructor 中的 `this.state = {}`\n\n### Props 改变\n\n1.  componentWillReceiveProps\n2.  shouldComponentUpdate\n3.  componentWillUpdate\n4.  render\n5.  componentDidUpdate\n\n### State 改变\n\n1.  shuldComponentDidMount\n2.  componentWillUpdate\n3.  render\n4.  componentDidUpdate\n\n### 组件销毁\n\n1. componentWillUnmount\n\n## 生命周期函数详解\n\n### getDefaultProps\n\n这个方法在组件中只会调用一次，返回的对象可以设置默认的 `props`（properties 的缩写）值。\n\n```jsx\nclass App extends React.Component {\n    getDefaultProps: () => {\n        return {\n            name: 'pomy',\n        }\n    };\n\n    render() {\n        return (\n            <div>\n                Hello {this.props.name}\n            </div>\n        );\n    }\n}\n\nexport default App;\n\n// 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy\n```\n### getInitialState\n\n该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，\n\n> getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。\n> getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。\n\n\n```jsx\nclass App extends React.Component {\n    getInitialState: () => {\n        return {liked: false};\n    };\n\n    handleClick: () => {\n        this.setState({liked: !this.state.liked});\n    };\n    render() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n}\n\nexport default App;\n```\n\n### componentWillMount\n\n该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。\n\n### render\n\n必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。\n\n### componentDidMount\n\n该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。\n\n### componentWillReceiveProps\n\n子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。\n\n### shouldComponentUpdate\n\n该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。\n\n### componentWillUpdate\n\n该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）\n\n### componentDidUpdate\n\n在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。\n\n### componentWillUnmount\n\n组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。\n\n","source":"_posts/react-Lifecycle.md","raw":"---\ntitle: React 生命周期详解\ndate: 2018-06-28 23:25:26\ntags: ['react', 'js']\n---\n\n## 组件渲染顺序\n\n### 第一次 render\n\n第一次在`客户端`渲染：\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n5.  componentDidMount\n\n第一次在`服务端`渲染\n\n1.  getDefaultProps\n2.  getInitialState\n3.  componentWillMount\n4.  render\n\ncomponentDidMount 不会在服务端被渲染的过程中调用。\ngetDefaultProps 相当于 ES6 中 `staticdefaultProps = {}`\ngetInitialState 相当于 constructor 中的 `this.state = {}`\n\n### Props 改变\n\n1.  componentWillReceiveProps\n2.  shouldComponentUpdate\n3.  componentWillUpdate\n4.  render\n5.  componentDidUpdate\n\n### State 改变\n\n1.  shuldComponentDidMount\n2.  componentWillUpdate\n3.  render\n4.  componentDidUpdate\n\n### 组件销毁\n\n1. componentWillUnmount\n\n## 生命周期函数详解\n\n### getDefaultProps\n\n这个方法在组件中只会调用一次，返回的对象可以设置默认的 `props`（properties 的缩写）值。\n\n```jsx\nclass App extends React.Component {\n    getDefaultProps: () => {\n        return {\n            name: 'pomy',\n        }\n    };\n\n    render() {\n        return (\n            <div>\n                Hello {this.props.name}\n            </div>\n        );\n    }\n}\n\nexport default App;\n\n// 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy\n```\n### getInitialState\n\n该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，\n\n> getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。\n> getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。\n\n\n```jsx\nclass App extends React.Component {\n    getInitialState: () => {\n        return {liked: false};\n    };\n\n    handleClick: () => {\n        this.setState({liked: !this.state.liked});\n    };\n    render() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n}\n\nexport default App;\n```\n\n### componentWillMount\n\n该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。\n\n### render\n\n必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。\n\n### componentDidMount\n\n该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。\n\n### componentWillReceiveProps\n\n子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。\n\n### shouldComponentUpdate\n\n该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。\n\n### componentWillUpdate\n\n该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）\n\n### componentDidUpdate\n\n在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。\n\n### componentWillUnmount\n\n组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。\n\n","slug":"react-Lifecycle","published":1,"updated":"2018-07-17T10:25:15.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd7z000unzz98621q3ur","content":"<h2 id=\"组件渲染顺序\"><a href=\"#组件渲染顺序\" class=\"headerlink\" title=\"组件渲染顺序\"></a>组件渲染顺序</h2><h3 id=\"第一次-render\"><a href=\"#第一次-render\" class=\"headerlink\" title=\"第一次 render\"></a>第一次 render</h3><p>第一次在<code>客户端</code>渲染：</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ol>\n<p>第一次在<code>服务端</code>渲染</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n</ol>\n<p>componentDidMount 不会在服务端被渲染的过程中调用。<br>getDefaultProps 相当于 ES6 中 <code>staticdefaultProps = {}</code><br>getInitialState 相当于 constructor 中的 <code>this.state = {}</code></p>\n<h3 id=\"Props-改变\"><a href=\"#Props-改变\" class=\"headerlink\" title=\"Props 改变\"></a>Props 改变</h3><ol>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"State-改变\"><a href=\"#State-改变\" class=\"headerlink\" title=\"State 改变\"></a>State 改变</h3><ol>\n<li>shuldComponentDidMount</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"组件销毁\"><a href=\"#组件销毁\" class=\"headerlink\" title=\"组件销毁\"></a>组件销毁</h3><ol>\n<li>componentWillUnmount</li>\n</ol>\n<h2 id=\"生命周期函数详解\"><a href=\"#生命周期函数详解\" class=\"headerlink\" title=\"生命周期函数详解\"></a>生命周期函数详解</h2><h3 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a>getDefaultProps</h3><p>这个方法在组件中只会调用一次，返回的对象可以设置默认的 <code>props</code>（properties 的缩写）值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            name: <span class=\"string\">'pomy'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Hello &#123;<span class=\"keyword\">this</span>.props.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"getInitialState\"><a href=\"#getInitialState\" class=\"headerlink\" title=\"getInitialState\"></a>getInitialState</h3><p>该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，</p>\n<blockquote>\n<p>getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。<br>getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">liked</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">liked</span>: !<span class=\"keyword\">this</span>.state.liked&#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.state.liked ? <span class=\"string\">'like'</span> : <span class=\"string\">'haven\\'t liked'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        You &#123;text&#125; <span class=\"keyword\">this</span>. Click to toggle.</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a>componentWillMount</h3><p>该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><p>必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。</p>\n<h3 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h3><p>该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。</p>\n<h3 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h3><p>子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p>该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。</p>\n<h3 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a>componentWillUpdate</h3><p>该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）</p>\n<h3 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h3><p>在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。</p>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"组件渲染顺序\"><a href=\"#组件渲染顺序\" class=\"headerlink\" title=\"组件渲染顺序\"></a>组件渲染顺序</h2><h3 id=\"第一次-render\"><a href=\"#第一次-render\" class=\"headerlink\" title=\"第一次 render\"></a>第一次 render</h3><p>第一次在<code>客户端</code>渲染：</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ol>\n<p>第一次在<code>服务端</code>渲染</p>\n<ol>\n<li>getDefaultProps</li>\n<li>getInitialState</li>\n<li>componentWillMount</li>\n<li>render</li>\n</ol>\n<p>componentDidMount 不会在服务端被渲染的过程中调用。<br>getDefaultProps 相当于 ES6 中 <code>staticdefaultProps = {}</code><br>getInitialState 相当于 constructor 中的 <code>this.state = {}</code></p>\n<h3 id=\"Props-改变\"><a href=\"#Props-改变\" class=\"headerlink\" title=\"Props 改变\"></a>Props 改变</h3><ol>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"State-改变\"><a href=\"#State-改变\" class=\"headerlink\" title=\"State 改变\"></a>State 改变</h3><ol>\n<li>shuldComponentDidMount</li>\n<li>componentWillUpdate</li>\n<li>render</li>\n<li>componentDidUpdate</li>\n</ol>\n<h3 id=\"组件销毁\"><a href=\"#组件销毁\" class=\"headerlink\" title=\"组件销毁\"></a>组件销毁</h3><ol>\n<li>componentWillUnmount</li>\n</ol>\n<h2 id=\"生命周期函数详解\"><a href=\"#生命周期函数详解\" class=\"headerlink\" title=\"生命周期函数详解\"></a>生命周期函数详解</h2><h3 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a>getDefaultProps</h3><p>这个方法在组件中只会调用一次，返回的对象可以设置默认的 <code>props</code>（properties 的缩写）值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            name: <span class=\"string\">'pomy'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                Hello &#123;<span class=\"keyword\">this</span>.props.name&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 在父组件没有传 this.props.name 时。默认输出结果为：Hello pomy</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"getInitialState\"><a href=\"#getInitialState\" class=\"headerlink\" title=\"getInitialState\"></a>getInitialState</h3><p>该方法有且只会调用一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props，state 与 props 的区别在于 state只存在组件的内部，</p>\n<blockquote>\n<p>getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用。<br>getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getInitialState: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">liked</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">liked</span>: !<span class=\"keyword\">this</span>.state.liked&#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> text = <span class=\"keyword\">this</span>.state.liked ? <span class=\"string\">'like'</span> : <span class=\"string\">'haven\\'t liked'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        You &#123;text&#125; <span class=\"keyword\">this</span>. Click to toggle.</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a>componentWillMount</h3><p>该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><p>必需的一个方法，用来表示组件的输出，render方法返回的结果并不是真正的 DOM 元素。</p>\n<h3 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h3><p>该方法在服务端不会被调用，该方法被调用时已经渲染出还是的 DOM ，可以在该方法中使用 window、this.getDOMNode() ，也可以访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。</p>\n<h3 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h3><p>子组件中的 props 被父组件修改是，componentWillReceiveProps 将被调用，可以在这个函数里面根据新的 props 更改 state 引起组件的重新渲染。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p>该函数是控制在 props 或者 state 发生改变时是否要引起重新渲染，如果直接返回 false 就不会执行 render 方法。一般不会在开发中使用。</p>\n<h3 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a>componentWillUpdate</h3><p>该方法在 props 和 state 即将进行渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。（容易形成死循环）</p>\n<h3 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h3><p>在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。</p>\n<h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>组件从 DOM 中卸载后被销毁，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</p>\n"},{"title":"package.json 文件","date":"2018-06-17T14:52:04.000Z","_content":"\n一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 ` npm install ` 会根据这个配置文件自动下载所需模块。\n\n### name\n\n项目的名字\n\n规则：\n 1. 该名称必须小于或等于214个字符。\n 2. 名称不能以点或下划线开头。\n 3. 新包名称中不能包含大写字母。\n 4. 该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。\n\n技巧\n 1. 不要使用与核心节点模块相同的名称。\n 2. 不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）\n 3. 这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。\n 4. 你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。[https://www.npmjs.com/](https://www.npmjs.com/)\n\n 名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 [npm-scope](https://docs.npmjs.com/misc/scope)查看更多\n\n### description\n\n在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search\n\n### version\n\n如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。\n\n版本必须可以由 [node-semver](https://docs.npmjs.com/misc/semver) 解析\n\n### keywords\n\n把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。\n\n### homepage\n\n项目首页的网址\n\n### bugs\n\n如果项目有问题，可以提交的问题的邮箱和 url。\n例如：\n```\n{ \"url\" : \"https://github.com/owner/project/issues\",\n  \"email\" : \"project@hostname.com\"\n}\n```\n\n可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 ` npm bugs ` 命令使用。\n\n### license\n\n项目包的许可证，可以让别人知道你的项目包的限制。[查看详情](https://docs.npmjs.com/files/package.json)\n\n### people fields: author, contributors  \n\nauthor 是一个人，contributors 是一群人。人具有 url 和 email 。\n\n### files\n\n\"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）\n你也可以在模块根目录下创建一个\".npmignore\"文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。\n\n容易被忽略的文件：\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json （改用shrinkwrap）\n\n### main\n\n程序的主要入口，这应该是相对于包文件夹根目录的模块ID。\n\n### browser\n\n如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）\n\n### bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）\n如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n例如：\n```\n{ \"bin\" : { \"myapp\" : \"./cli.js\" } }\n```\n\n模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。\n如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n```\n{ \n    \"name\": \"my-program\",\n    \"version\": \"1.2.5\",\n    \"bin\": \"./path/to/program\",\n}\n```\n\n### man\n\n制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。\n如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : \"./man/doc.1\"\n}\n```\n\n通过 man foo 命令会得到 ./man/doc.1 文件的内容。\n如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ]\n}\n```\n\n会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。\nman文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ]\n}\n```\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n### directories\n\nCommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。\n目前这个配置没有任何作用。\n\ndirectories.lib\n告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\ndirectories.bin\n如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。\n\ndirectories.man\n指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。\n\ndirectories.doc\n在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）\n\ndirectories.example\n放一些示例脚本，或许某一天会有用 - -！\n\n### repository\n\n代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 ` npm docs ` 命令将能够找到你的项目\n\n例如：\n```\n\"repository\" :\n  { \n      \"type\" : \"git\",\n      \"url\" : \"https://github.com/npm/npm.git\"\n  }\n\n\"repository\" :\n  { \n    \"type\" : \"svn\",\n    \"url\" : \"https://v8.googlecode.com/svn/trunk/\"\n  }\n```\n\n该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。\n\n对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法\n\n### scripts\n\n“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。\n[npm-scripts 查看更多](https://docs.npmjs.com/misc/scripts)\n\n### config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。\n用户用的时候可以使用如下用法：\n```\nhttp.createServer(...).listen(process.env.npm_package_config_port) \n```\n\n可以通过npm config set foo:port 80来修改config:\n```\n{ \n    \"name\" : \"foo\",\n    \"config\" : { \"port\" : \"8080\" }\n}\n```\n\n### dependencies 和 devDependencies\n\ndependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。\n它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n对应的版本可以加上各种限定，主要有以下几种：\n\n指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n> 1. 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n> \n> 2. 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n> \n> 3. latest：安装最新版本。\n\npackage.json 文件可以手工编写，也可以使用 ` npm init ` 命令自动生成。项目名称（name）和项目版本（version）是必填的\n\n通过指令安装：\n```\n$ npm install express --save\n$ npm install express --save-dev\n```\n\n` --save ` 参数表示将该模块写入 dependencies 属性\n` --save-dev ` 表示将该模块写入 devDependencies 属性。\n\n### peerDependencies\n\n有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。\n\n大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\n\npeerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。\n\n例如：\n```\n{\n  \"name\": \"tea-latte\",\n  \"version\": \"1.3.5\",\n  \"peerDependencies\": {\n    \"tea\": \"2.x\"\n  }\n}\n```\n\n这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：\n```\n├── tea-latte@1.3.5\n└── tea@2.2.0\n```\n\n注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。\n\n### preferGlobal\n\npreferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n\n### style\n\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。","source":"_posts/package-json文件.md","raw":"---\ntitle: package.json 文件\ndate: 2018-06-17 22:52:04\ntags: package.json\ncategories: json\n---\n\n一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 ` npm install ` 会根据这个配置文件自动下载所需模块。\n\n### name\n\n项目的名字\n\n规则：\n 1. 该名称必须小于或等于214个字符。\n 2. 名称不能以点或下划线开头。\n 3. 新包名称中不能包含大写字母。\n 4. 该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。\n\n技巧\n 1. 不要使用与核心节点模块相同的名称。\n 2. 不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）\n 3. 这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。\n 4. 你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。[https://www.npmjs.com/](https://www.npmjs.com/)\n\n 名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 [npm-scope](https://docs.npmjs.com/misc/scope)查看更多\n\n### description\n\n在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search\n\n### version\n\n如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。\n\n版本必须可以由 [node-semver](https://docs.npmjs.com/misc/semver) 解析\n\n### keywords\n\n把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。\n\n### homepage\n\n项目首页的网址\n\n### bugs\n\n如果项目有问题，可以提交的问题的邮箱和 url。\n例如：\n```\n{ \"url\" : \"https://github.com/owner/project/issues\",\n  \"email\" : \"project@hostname.com\"\n}\n```\n\n可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 ` npm bugs ` 命令使用。\n\n### license\n\n项目包的许可证，可以让别人知道你的项目包的限制。[查看详情](https://docs.npmjs.com/files/package.json)\n\n### people fields: author, contributors  \n\nauthor 是一个人，contributors 是一群人。人具有 url 和 email 。\n\n### files\n\n\"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）\n你也可以在模块根目录下创建一个\".npmignore\"文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。\n\n容易被忽略的文件：\n.git\nCVS\n.svn\n.hg\n.lock-wscript\n.wafpickle-N\n.*.swp\n.DS_Store\n._*\nnpm-debug.log\n.npmrc\nnode_modules\nconfig.gypi\n*.orig\npackage-lock.json （改用shrinkwrap）\n\n### main\n\n程序的主要入口，这应该是相对于包文件夹根目录的模块ID。\n\n### browser\n\n如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）\n\n### bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）\n如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n例如：\n```\n{ \"bin\" : { \"myapp\" : \"./cli.js\" } }\n```\n\n模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。\n如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n```\n{ \n    \"name\": \"my-program\",\n    \"version\": \"1.2.5\",\n    \"bin\": \"./path/to/program\",\n}\n```\n\n### man\n\n制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。\n如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : \"./man/doc.1\"\n}\n```\n\n通过 man foo 命令会得到 ./man/doc.1 文件的内容。\n如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ]\n}\n```\n\n会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。\nman文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n```\n{ \n    \"name\" : \"foo\",\n    \"version\" : \"1.2.3\",\n    \"description\" : \"A packaged foo fooer for fooing foos\",\n    \"main\" : \"foo.js\",\n    \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ]\n}\n```\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n### directories\n\nCommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。\n目前这个配置没有任何作用。\n\ndirectories.lib\n告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\ndirectories.bin\n如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。\n\ndirectories.man\n指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。\n\ndirectories.doc\n在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）\n\ndirectories.example\n放一些示例脚本，或许某一天会有用 - -！\n\n### repository\n\n代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 ` npm docs ` 命令将能够找到你的项目\n\n例如：\n```\n\"repository\" :\n  { \n      \"type\" : \"git\",\n      \"url\" : \"https://github.com/npm/npm.git\"\n  }\n\n\"repository\" :\n  { \n    \"type\" : \"svn\",\n    \"url\" : \"https://v8.googlecode.com/svn/trunk/\"\n  }\n```\n\n该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。\n\n对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法\n\n### scripts\n\n“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。\n[npm-scripts 查看更多](https://docs.npmjs.com/misc/scripts)\n\n### config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。\n用户用的时候可以使用如下用法：\n```\nhttp.createServer(...).listen(process.env.npm_package_config_port) \n```\n\n可以通过npm config set foo:port 80来修改config:\n```\n{ \n    \"name\" : \"foo\",\n    \"config\" : { \"port\" : \"8080\" }\n}\n```\n\n### dependencies 和 devDependencies\n\ndependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。\n它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。\n对应的版本可以加上各种限定，主要有以下几种：\n\n指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n> 1. 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n> \n> 2. 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n> \n> 3. latest：安装最新版本。\n\npackage.json 文件可以手工编写，也可以使用 ` npm init ` 命令自动生成。项目名称（name）和项目版本（version）是必填的\n\n通过指令安装：\n```\n$ npm install express --save\n$ npm install express --save-dev\n```\n\n` --save ` 参数表示将该模块写入 dependencies 属性\n` --save-dev ` 表示将该模块写入 devDependencies 属性。\n\n### peerDependencies\n\n有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。\n\n大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。\n\n最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。\n\npeerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。\n\n例如：\n```\n{\n  \"name\": \"tea-latte\",\n  \"version\": \"1.3.5\",\n  \"peerDependencies\": {\n    \"tea\": \"2.x\"\n  }\n}\n```\n\n这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：\n```\n├── tea-latte@1.3.5\n└── tea@2.2.0\n```\n\n注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。\n\n### preferGlobal\n\npreferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n\n### style\n\nstyle指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。","slug":"package-json文件","published":1,"updated":"2018-07-17T10:25:15.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd81000wnzz9c05k8511","content":"<p>一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 <code>npm install</code> 会根据这个配置文件自动下载所需模块。</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>项目的名字</p>\n<p>规则：</p>\n<ol>\n<li>该名称必须小于或等于214个字符。</li>\n<li>名称不能以点或下划线开头。</li>\n<li>新包名称中不能包含大写字母。</li>\n<li>该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。</li>\n</ol>\n<p>技巧</p>\n<ol>\n<li>不要使用与核心节点模块相同的名称。</li>\n<li>不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）</li>\n<li>这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。</li>\n<li><p>你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 <a href=\"https://docs.npmjs.com/misc/scope\" target=\"_blank\" rel=\"noopener\">npm-scope</a>查看更多</p>\n</li>\n</ol>\n<h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search</p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p>如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。</p>\n<p>版本必须可以由 <a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">node-semver</a> 解析</p>\n<h3 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h3><p>把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。</p>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><p>项目首页的网址</p>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><p>如果项目有问题，可以提交的问题的邮箱和 url。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">  &quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 <code>npm bugs</code> 命令使用。</p>\n<h3 id=\"license\"><a href=\"#license\" class=\"headerlink\" title=\"license\"></a>license</h3><p>项目包的许可证，可以让别人知道你的项目包的限制。<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">查看详情</a></p>\n<h3 id=\"people-fields-author-contributors\"><a href=\"#people-fields-author-contributors\" class=\"headerlink\" title=\"people fields: author, contributors\"></a>people fields: author, contributors</h3><p>author 是一个人，contributors 是一群人。人具有 url 和 email 。</p>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p>\n<p>容易被忽略的文件：<br>.git<br>CVS<br>.svn<br>.hg<br>.lock-wscript<br>.wafpickle-N<br>.<em>.swp<br>.DS_Store<br>._</em><br>npm-debug.log<br>.npmrc<br>node_modules<br>config.gypi<br>*.orig<br>package-lock.json （改用shrinkwrap）</p>\n<h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><p>程序的主要入口，这应该是相对于包文件夹根目录的模块ID。</p>\n<h3 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h3><p>如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot;: &quot;my-program&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.2.5&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &quot;./path/to/program&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : &quot;./man/doc.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。<br>如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 <a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br>目前这个配置没有任何作用。</p>\n<p>directories.lib<br>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<p>directories.bin<br>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<p>directories.man<br>指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。</p>\n<p>directories.doc<br>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<p>directories.example<br>放一些示例脚本，或许某一天会有用 - -！</p>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><p>代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 <code>npm docs</code> 命令将能够找到你的项目</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">      &quot;type&quot; : &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    &quot;type&quot; : &quot;svn&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。</p>\n<p>对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。<br><a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm-scripts 查看更多</a></p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.createServer(...).listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure></p>\n<p>可以通过npm config set foo:port 80来修改config:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dependencies-和-devDependencies\"><a href=\"#dependencies-和-devDependencies\" class=\"headerlink\" title=\"dependencies 和 devDependencies\"></a>dependencies 和 devDependencies</h3><p>dependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br>对应的版本可以加上各种限定，主要有以下几种：</p>\n<p>指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</p>\n<blockquote>\n<ol>\n<li><p>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</p>\n</li>\n<li><p>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</p>\n</li>\n<li><p>latest：安装最新版本。</p>\n</li>\n</ol>\n</blockquote>\n<p>package.json 文件可以手工编写，也可以使用 <code>npm init</code> 命令自动生成。项目名称（name）和项目版本（version）是必填的</p>\n<p>通过指令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br><span class=\"line\">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><code>--save</code> 参数表示将该模块写入 dependencies 属性<br><code>--save-dev</code> 表示将该模块写入 devDependencies 属性。</p>\n<h3 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。</p>\n<p>大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>\n<p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p>\n<p>peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;tea-latte&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.3.5&quot;,</span><br><span class=\"line\">  &quot;peerDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;tea&quot;: &quot;2.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── tea-latte@1.3.5</span><br><span class=\"line\">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。</p>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一般每个项目的更目录都会有一个 package.json 文件，定义这个项目所需要的模块以及项目的配置信息，通过执行 <code>npm install</code> 会根据这个配置文件自动下载所需模块。</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>项目的名字</p>\n<p>规则：</p>\n<ol>\n<li>该名称必须小于或等于214个字符。</li>\n<li>名称不能以点或下划线开头。</li>\n<li>新包名称中不能包含大写字母。</li>\n<li>该名称最终成为URL的一部分，命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。</li>\n</ol>\n<p>技巧</p>\n<ol>\n<li>不要使用与核心节点模块相同的名称。</li>\n<li>不要在名称中加入“js”或“node”。假设它是js，因为你正在编写一个package.json文件，并且你可以使用“engines”字段来指定引擎。（见下文。）</li>\n<li>这个名字可能会作为require（）的参数传递，所以它应该是简短的，但也是合理的描述。</li>\n<li><p>你可能想要检查npm注册表，看看是否已经有这个名称的东西，然后你才会太依附它。<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></p>\n<p>名称可以有选择地以范围作为前缀，例如@myorg/mypackage。查看 <a href=\"https://docs.npmjs.com/misc/scope\" target=\"_blank\" rel=\"noopener\">npm-scope</a>查看更多</p>\n</li>\n</ol>\n<h3 id=\"description\"><a href=\"#description\" class=\"headerlink\" title=\"description\"></a>description</h3><p>在其中添加说明。这是一个字符串。这有助于人们发现您的包，因为它已列入 npm search</p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p>如果你打算发布你的软件包，package.json 中最重要的东西就是它们所需的名称和版本字段。名称和版本一起构成一个假定为完全唯一的标识符。对软件包所做的更改应该随着对版本的更改而发生变化。如果您不打算发布您的软件包，则名称和版本字段是可选的。</p>\n<p>版本必须可以由 <a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">node-semver</a> 解析</p>\n<h3 id=\"keywords\"><a href=\"#keywords\" class=\"headerlink\" title=\"keywords\"></a>keywords</h3><p>把关键字放在里面。这是一串字符串。这有助于人们发现您的包，因为它已列入npm search。</p>\n<h3 id=\"homepage\"><a href=\"#homepage\" class=\"headerlink\" title=\"homepage\"></a>homepage</h3><p>项目首页的网址</p>\n<h3 id=\"bugs\"><a href=\"#bugs\" class=\"headerlink\" title=\"bugs\"></a>bugs</h3><p>如果项目有问题，可以提交的问题的邮箱和 url。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,</span><br><span class=\"line\">  &quot;email&quot; : &quot;project@hostname.com&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以指定一个值或者两个值，如果只提供 url ,就不需要指定为对象，而是字符串，并且会被 <code>npm bugs</code> 命令使用。</p>\n<h3 id=\"license\"><a href=\"#license\" class=\"headerlink\" title=\"license\"></a>license</h3><p>项目包的许可证，可以让别人知道你的项目包的限制。<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">查看详情</a></p>\n<h3 id=\"people-fields-author-contributors\"><a href=\"#people-fields-author-contributors\" class=\"headerlink\" title=\"people fields: author, contributors\"></a>people fields: author, contributors</h3><p>author 是一个人，contributors 是一群人。人具有 url 和 email 。</p>\n<h3 id=\"files\"><a href=\"#files\" class=\"headerlink\" title=\"files\"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p>\n<p>容易被忽略的文件：<br>.git<br>CVS<br>.svn<br>.hg<br>.lock-wscript<br>.wafpickle-N<br>.<em>.swp<br>.DS_Store<br>._</em><br>npm-debug.log<br>.npmrc<br>node_modules<br>config.gypi<br>*.orig<br>package-lock.json （改用shrinkwrap）</p>\n<h3 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h3><p>程序的主要入口，这应该是相对于包文件夹根目录的模块ID。</p>\n<h3 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h3><p>如果您的模块用于客户端，则应使用浏览器字段而不是主字段。这有助于提示用户可能依赖于 Node.js 模块中不可用的基元。（例如window）</p>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;bin&quot; : &#123; &quot;myapp&quot; : &quot;./cli.js&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的 ./node_modules/.bin/ 目录下创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot;: &quot;my-program&quot;,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.2.5&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &quot;./path/to/program&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用 man+ 模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : &quot;./man/doc.1&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。<br>如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;version&quot; : &quot;1.2.3&quot;,</span><br><span class=\"line\">    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;,</span><br><span class=\"line\">    &quot;main&quot; : &quot;foo.js&quot;,</span><br><span class=\"line\">    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h3 id=\"directories\"><a href=\"#directories\" class=\"headerlink\" title=\"directories\"></a>directories</h3><p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件 <a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。<br>目前这个配置没有任何作用。</p>\n<p>directories.lib<br>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<p>directories.bin<br>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到bin路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<p>directories.man<br>指定一个目录，目录里边都是man文件，这是一种配置 man 文件的语法糖。</p>\n<p>directories.doc<br>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<p>directories.example<br>放一些示例脚本，或许某一天会有用 - -！</p>\n<h3 id=\"repository\"><a href=\"#repository\" class=\"headerlink\" title=\"repository\"></a>repository</h3><p>代码库所在地址，对要贡献的人有帮助。如果 git repo 位于 GitHub上 ，那么该 <code>npm docs</code> 命令将能够找到你的项目</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">      &quot;type&quot; : &quot;git&quot;,</span><br><span class=\"line\">      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;repository&quot; :</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    &quot;type&quot; : &quot;svn&quot;,</span><br><span class=\"line\">    &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>该URL应该是一个公开可用的（也许是只读的）url，可以直接传递给VCS程序而无需任何修改。它不应该是你放入浏览器的html项目页面的网址。</p>\n<p>对于GitHub，GitHub gist，Bitbucket或GitLab存储库，您可以使用相同的快捷键语法</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"scripts\"></a>scripts</h3><p>“scripts”属性是一个包含脚本命令的字典，这些脚本命令在包的生命周期中的不同时间运行。关键是生命周期事件，值是在该点运行的命令。<br><a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener\">npm-scripts 查看更多</a></p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.createServer(...).listen(process.env.npm_package_config_port)</span><br></pre></td></tr></table></figure></p>\n<p>可以通过npm config set foo:port 80来修改config:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    &quot;name&quot; : &quot;foo&quot;,</span><br><span class=\"line\">    &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dependencies-和-devDependencies\"><a href=\"#dependencies-和-devDependencies\" class=\"headerlink\" title=\"dependencies 和 devDependencies\"></a>dependencies 和 devDependencies</h3><p>dependencies 字段指定了项目运行所依赖的模块，devDependencies 指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br>对应的版本可以加上各种限定，主要有以下几种：</p>\n<p>指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</p>\n<blockquote>\n<ol>\n<li><p>波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</p>\n</li>\n<li><p>插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</p>\n</li>\n<li><p>latest：安装最新版本。</p>\n</li>\n</ol>\n</blockquote>\n<p>package.json 文件可以手工编写，也可以使用 <code>npm init</code> 命令自动生成。项目名称（name）和项目版本（version）是必填的</p>\n<p>通过指令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br><span class=\"line\">$ npm install express --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><code>--save</code> 参数表示将该模块写入 dependencies 属性<br><code>--save-dev</code> 表示将该模块写入 devDependencies 属性。</p>\n<h3 id=\"peerDependencies\"><a href=\"#peerDependencies\" class=\"headerlink\" title=\"peerDependencies\"></a>peerDependencies</h3><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖 A 模块和 B 模块的 1.0 版，而A模块本身又依赖 B 模块的 2.0 版。</p>\n<p>大多数情况下，这不构成问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>\n<p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的B的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p>\n<p>peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;tea-latte&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.3.5&quot;,</span><br><span class=\"line\">  &quot;peerDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;tea&quot;: &quot;2.x&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这可确保您的软件包tea-latte只能与主机软件包的第二个主要版本一起安装tea。npm install tea-latte可能会产生以下依赖关系图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── tea-latte@1.3.5</span><br><span class=\"line\">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果 npm 版本1 和 版本2 peerDependencies 不依赖于依赖关系树中的更高版本，它将自动安装。在下一个主要版本的 npm（npm @ 3 ）中，这将不再是这种情况。您将收到警告，指出 peerDependency 未安装。npms 1 ＆ 2 中的行为经常令人困惑，并且很容易让你陷入依赖地狱， npm 旨在尽可能地避免这种情况。</p>\n<h3 id=\"preferGlobal\"><a href=\"#preferGlobal\" class=\"headerlink\" title=\"preferGlobal\"></a>preferGlobal</h3><p>preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><p>style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。</p>\n"},{"title":"什么是跨域？","date":"2018-06-11T14:12:53.000Z","_content":"\n简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法\n\n看如下例子：\n\n1. 同一域名下  【允许通信】\nhttp://www.a.com/a.js\nhttp://www.a.com/b.js\n\n2. 同一域名下不同文件夹  【允许通信】\nhttp://www.a.com/lab/a.js\nhttp://www.a.com/script/b.js\n\n3. 同一域名，不同端口  【不允许通信】\nhttp://www.a.com:8000/a.js\nhttp://www.a.com/b.js\n\n4. 同一域名，不同协议  【不允许通信】\nhttp://www.a.com/a.js\nhttps://www.a.com/b.js\n\n5. 域名和域名对应ip 【不允许通信】\nhttp://www.a.com/a.js\nhttp://70.32.92.74/b.js\n\n6. 主域相同，子域不同 【不允许通信】\nhttp://www.a.com/a.js\nhttp://script.a.com/b.js\n\n7. 同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】\nhttp://www.a.com/a.js\nhttp://a.com/b.js\n\n8. 不同域名 【不允许通信】\nhttp://www.cnblogs.com/a.js\nhttp://www.a.com/b.js\n\n\n#### 同源策略（same-origin policy）\n同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。\n\n\n原文链接：http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\n","source":"_posts/什么是跨域？.md","raw":"---\ntitle: 什么是跨域？\ndate: 2018-06-11 22:12:53\ntags: 跨域\ncategories: js\n---\n\n简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法\n\n看如下例子：\n\n1. 同一域名下  【允许通信】\nhttp://www.a.com/a.js\nhttp://www.a.com/b.js\n\n2. 同一域名下不同文件夹  【允许通信】\nhttp://www.a.com/lab/a.js\nhttp://www.a.com/script/b.js\n\n3. 同一域名，不同端口  【不允许通信】\nhttp://www.a.com:8000/a.js\nhttp://www.a.com/b.js\n\n4. 同一域名，不同协议  【不允许通信】\nhttp://www.a.com/a.js\nhttps://www.a.com/b.js\n\n5. 域名和域名对应ip 【不允许通信】\nhttp://www.a.com/a.js\nhttp://70.32.92.74/b.js\n\n6. 主域相同，子域不同 【不允许通信】\nhttp://www.a.com/a.js\nhttp://script.a.com/b.js\n\n7. 同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】\nhttp://www.a.com/a.js\nhttp://a.com/b.js\n\n8. 不同域名 【不允许通信】\nhttp://www.cnblogs.com/a.js\nhttp://www.a.com/b.js\n\n\n#### 同源策略（same-origin policy）\n同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。\n\n\n原文链接：http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\n","slug":"什么是跨域？","published":1,"updated":"2018-07-17T10:25:15.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd840010nzz90i9ezsu8","content":"<p>简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法</p>\n<p>看如下例子：</p>\n<ol>\n<li><p>同一域名下  【允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名下不同文件夹  【允许通信】<br><a href=\"http://www.a.com/lab/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/lab/a.js</a><br><a href=\"http://www.a.com/script/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/script/b.js</a></p>\n</li>\n<li><p>同一域名，不同端口  【不允许通信】<br><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同协议  【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"https://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">https://www.a.com/b.js</a></p>\n</li>\n<li><p>域名和域名对应ip 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://70.32.92.74/b.js\" target=\"_blank\" rel=\"noopener\">http://70.32.92.74/b.js</a></p>\n</li>\n<li><p>主域相同，子域不同 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://script.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://script.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://a.com/b.js</a></p>\n</li>\n<li><p>不同域名 【不允许通信】<br><a href=\"http://www.cnblogs.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n</ol>\n<h4 id=\"同源策略（same-origin-policy）\"><a href=\"#同源策略（same-origin-policy）\" class=\"headerlink\" title=\"同源策略（same-origin policy）\"></a>同源策略（same-origin policy）</h4><p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>简单来说跨域是 JavaScript 同源策略的限制，a.com 域名下的 js 无法操作 b.com 或是 c.a.com 域名下的对象和方法</p>\n<p>看如下例子：</p>\n<ol>\n<li><p>同一域名下  【允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名下不同文件夹  【允许通信】<br><a href=\"http://www.a.com/lab/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/lab/a.js</a><br><a href=\"http://www.a.com/script/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/script/b.js</a></p>\n</li>\n<li><p>同一域名，不同端口  【不允许通信】<br><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同协议  【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"https://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">https://www.a.com/b.js</a></p>\n</li>\n<li><p>域名和域名对应ip 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://70.32.92.74/b.js\" target=\"_blank\" rel=\"noopener\">http://70.32.92.74/b.js</a></p>\n</li>\n<li><p>主域相同，子域不同 【不允许通信】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://script.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://script.a.com/b.js</a></p>\n</li>\n<li><p>同一域名，不同二级域名（同上） 【不允许（cookie这种情况下也不允许访问）】<br><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/a.js</a><br><a href=\"http://a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://a.com/b.js</a></p>\n</li>\n<li><p>不同域名 【不允许通信】<br><a href=\"http://www.cnblogs.com/a.js\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"noopener\">http://www.a.com/b.js</a></p>\n</li>\n</ol>\n<h4 id=\"同源策略（same-origin-policy）\"><a href=\"#同源策略（same-origin-policy）\" class=\"headerlink\" title=\"同源策略（same-origin policy）\"></a>同源策略（same-origin policy）</h4><p>同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html</a></p>\n"},{"title":"浏览器内核","date":"2018-07-04T14:40:26.000Z","_content":"\n## 浏览器内核介绍\n所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br />\n浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br />\n我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。\n\n## 常见的浏览器内核有哪些？\n\n- Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]\n- Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等\n- Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]\n- Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]","source":"_posts/浏览器内核.md","raw":"---\ntitle: 浏览器内核\ndate: 2018-07-04 22:40:26\ntags: 浏览器\n---\n\n## 浏览器内核介绍\n所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br />\n浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br />\n我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。\n\n## 常见的浏览器内核有哪些？\n\n- Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]\n- Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等\n- Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]\n- Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]","slug":"浏览器内核","published":1,"updated":"2018-07-17T10:25:15.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd860012nzz9596a4xz4","content":"<h2 id=\"浏览器内核介绍\"><a href=\"#浏览器内核介绍\" class=\"headerlink\" title=\"浏览器内核介绍\"></a>浏览器内核介绍</h2><p>所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br><br>浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br><br>我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><ul>\n<li>Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]</li>\n<li>Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等</li>\n<li>Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]</li>\n<li>Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器内核介绍\"><a href=\"#浏览器内核介绍\" class=\"headerlink\" title=\"浏览器内核介绍\"></a>浏览器内核介绍</h2><p>所谓的“浏览器内核”（“Rendering Engine”）指的是一个浏览器最核心的部分，直译为：“渲染引擎”，也常称为：“排版引擎”、“解释引擎”。<br><br>浏览器引擎作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。<br><br>我们所说的“浏览器内核”或者“渲染引擎”，除了渲染引擎外也包含了 javascript 引擎，例如：WebKit。它由渲染引擎 WebCore 和 javascript 引擎 JSCore 组成。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><ul>\n<li>Trident内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称MSHTML]</li>\n<li>Gecko内核：Netscape6 及以上版本，Mozilla FirefoxGecko, MozillaSuite / SeaMonkey 等</li>\n<li>Presto内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]</li>\n<li>Webkit内核：Safari, Chrome 等。 [ Chrome的Blink（WebKit的分支）]</li>\n</ul>\n"},{"title":"解决跨域的 10 种方法","date":"2018-06-11T14:40:49.000Z","_content":"\n## 单向跨域\n\n### 一、 JSONP（JSON with Padding）\n\nhtml中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源\n\n例子：\n【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数\n\n优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。\n缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。\n\n### 二、flash URLloader\n\nflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。\n\n例子：\n从域 www.a.com 请求域 www.b.com 上的数据，我们可以借助 flash 来发送 HTTP 请求。\n1. 修改域 www.b.com 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 www.a.com 加入到白名单。\n2. 通过 Flash URLLoader 发送 HTTP 请求。\n3. 通过 Flash API 把响应结果传递给 JavaScript。\n\n缺点：不支持 IOS\n\n### 三、Access Control\n\nAccess Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。\n\n例子：\nwww.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\n\n缺点：目前只在很少的浏览器中得以支持，\n\n\n### 四、window.name\n\nwindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。\n\n例子：\n在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。\n\n优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。\n\n### 五、server proxy\n\n在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。\n\n例子：\n当 www.a.com 域下的页面需要请求 www.b.com 下的资源文件 asset.txt 时，直接发送一个指向 www.b.com/asset.txt 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 www.a.com 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 www.a.com/proxy/ , 然后这个代理发送 HTTP 请求访问 www.b.com 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。\n\n注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。\n\n## 双向跨域\n\n### 一、document.domain\n\n通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。\n\n例子：\n同域策略认为域和子域隶属于不同的域，比如 www.a.com 和 sub.a.com 是不同的域，这时，我们无法在 www.a.com 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。\n\n### 二、FIM – Fragment Identitier Messaging\n\n不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。\nFIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。\n\n### 三、Flash LocalConnection\n\n页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。\n\n### 四、window.postMessage\n\nwindow.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。\n\n### 五、Cross Frame\n\nCross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 www.a.com 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 www.b.com 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。\n\n不同的跨域请求可以使用不同的方式解决\n\n原文链接：http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html","source":"_posts/解决跨域的-10-种方法.md","raw":"---\ntitle: 解决跨域的 10 种方法\ndate: 2018-06-11 22:40:49\ntags: 跨域\ncategories: js\n---\n\n## 单向跨域\n\n### 一、 JSONP（JSON with Padding）\n\nhtml中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源\n\n例子：\n【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数\n\n优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。\n缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。\n\n### 二、flash URLloader\n\nflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。\n\n例子：\n从域 www.a.com 请求域 www.b.com 上的数据，我们可以借助 flash 来发送 HTTP 请求。\n1. 修改域 www.b.com 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 www.a.com 加入到白名单。\n2. 通过 Flash URLLoader 发送 HTTP 请求。\n3. 通过 Flash API 把响应结果传递给 JavaScript。\n\n缺点：不支持 IOS\n\n### 三、Access Control\n\nAccess Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。\n\n例子：\nwww.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\n\n缺点：目前只在很少的浏览器中得以支持，\n\n\n### 四、window.name\n\nwindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。\n\n例子：\n在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。\n\n优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。\n\n### 五、server proxy\n\n在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。\n\n例子：\n当 www.a.com 域下的页面需要请求 www.b.com 下的资源文件 asset.txt 时，直接发送一个指向 www.b.com/asset.txt 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 www.a.com 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 www.a.com/proxy/ , 然后这个代理发送 HTTP 请求访问 www.b.com 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。\n\n注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。\n\n## 双向跨域\n\n### 一、document.domain\n\n通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。\n\n例子：\n同域策略认为域和子域隶属于不同的域，比如 www.a.com 和 sub.a.com 是不同的域，这时，我们无法在 www.a.com 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。\n\n### 二、FIM – Fragment Identitier Messaging\n\n不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。\nFIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。\n\n### 三、Flash LocalConnection\n\n页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。\n\n### 四、window.postMessage\n\nwindow.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。\n\n### 五、Cross Frame\n\nCross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 www.a.com 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 www.b.com 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。\n\n不同的跨域请求可以使用不同的方式解决\n\n原文链接：http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html","slug":"解决跨域的-10-种方法","published":1,"updated":"2018-07-17T10:25:15.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkahyd880016nzz9crk41rtp","content":"<h2 id=\"单向跨域\"><a href=\"#单向跨域\" class=\"headerlink\" title=\"单向跨域\"></a>单向跨域</h2><h3 id=\"一、-JSONP（JSON-with-Padding）\"><a href=\"#一、-JSONP（JSON-with-Padding）\" class=\"headerlink\" title=\"一、 JSONP（JSON with Padding）\"></a>一、 JSONP（JSON with Padding）</h3><p>html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源</p>\n<p>例子：<br>【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数</p>\n<p>优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。<br>缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。</p>\n<h3 id=\"二、flash-URLloader\"><a href=\"#二、flash-URLloader\" class=\"headerlink\" title=\"二、flash URLloader\"></a>二、flash URLloader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>\n<p>例子：<br>从域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 请求域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的数据，我们可以借助 flash 来发送 HTTP 请求。</p>\n<ol>\n<li>修改域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 加入到白名单。</li>\n<li>通过 Flash URLLoader 发送 HTTP 请求。</li>\n<li>通过 Flash API 把响应结果传递给 JavaScript。</li>\n</ol>\n<p>缺点：不支持 IOS</p>\n<h3 id=\"三、Access-Control\"><a href=\"#三、Access-Control\" class=\"headerlink\" title=\"三、Access Control\"></a>三、Access Control</h3><p>Access Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。</p>\n<p>例子：<br><a href=\"http://www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\" target=\"_blank\" rel=\"noopener\">www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头</a></p>\n<p>缺点：目前只在很少的浏览器中得以支持，</p>\n<h3 id=\"四、window-name\"><a href=\"#四、window-name\" class=\"headerlink\" title=\"四、window.name\"></a>四、window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。</p>\n<p>例子：<br>在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。</p>\n<p>优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。</p>\n<h3 id=\"五、server-proxy\"><a href=\"#五、server-proxy\" class=\"headerlink\" title=\"五、server proxy\"></a>五、server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>\n<p>例子：<br>当 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 域下的页面需要请求 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的资源文件 asset.txt 时，直接发送一个指向 <a href=\"http://www.b.com/asset.txt\" target=\"_blank\" rel=\"noopener\">www.b.com/asset.txt</a> 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 <a href=\"http://www.a.com/proxy/\" target=\"_blank\" rel=\"noopener\">www.a.com/proxy/</a> , 然后这个代理发送 HTTP 请求访问 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。</p>\n<p>注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</p>\n<h2 id=\"双向跨域\"><a href=\"#双向跨域\" class=\"headerlink\" title=\"双向跨域\"></a>双向跨域</h2><h3 id=\"一、document-domain\"><a href=\"#一、document-domain\" class=\"headerlink\" title=\"一、document.domain\"></a>一、document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。</p>\n<p>例子：<br>同域策略认为域和子域隶属于不同的域，比如 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 和 sub.a.com 是不同的域，这时，我们无法在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。</p>\n<h3 id=\"二、FIM-–-Fragment-Identitier-Messaging\"><a href=\"#二、FIM-–-Fragment-Identitier-Messaging\" class=\"headerlink\" title=\"二、FIM – Fragment Identitier Messaging\"></a>二、FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。<br>FIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。</p>\n<h3 id=\"三、Flash-LocalConnection\"><a href=\"#三、Flash-LocalConnection\" class=\"headerlink\" title=\"三、Flash LocalConnection\"></a>三、Flash LocalConnection</h3><p>页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。</p>\n<h3 id=\"四、window-postMessage\"><a href=\"#四、window-postMessage\" class=\"headerlink\" title=\"四、window.postMessage\"></a>四、window.postMessage</h3><p>window.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>\n<h3 id=\"五、Cross-Frame\"><a href=\"#五、Cross-Frame\" class=\"headerlink\" title=\"五、Cross Frame\"></a>五、Cross Frame</h3><p>Cross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。</p>\n<p>不同的跨域请求可以使用不同的方式解决</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单向跨域\"><a href=\"#单向跨域\" class=\"headerlink\" title=\"单向跨域\"></a>单向跨域</h2><h3 id=\"一、-JSONP（JSON-with-Padding）\"><a href=\"#一、-JSONP（JSON-with-Padding）\" class=\"headerlink\" title=\"一、 JSONP（JSON with Padding）\"></a>一、 JSONP（JSON with Padding）</h3><p>html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源</p>\n<p>例子：<br>【域A】中【pageA】需要加载【域B】的数据，那么在【域B】的页面【pageB】中我以JavaScript的形式声明【pageA】需要的数据，然后在【pageA】中用script标签把【pageB】加载进来，那么【pageB】中的脚本就会得以执行。JSONP 在此基础上加入了【回调函数】，【pageB】加载完之后会执行【pageA】中定义的函数，所需要的数据会以【参数的形式】传递给该函数</p>\n<p>优点：易于实现， 在受信任的双方传递数据，JSONP是非常合适的选择。<br>缺点：如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。</p>\n<h3 id=\"二、flash-URLloader\"><a href=\"#二、flash-URLloader\" class=\"headerlink\" title=\"二、flash URLloader\"></a>二、flash URLloader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>\n<p>例子：<br>从域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 请求域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的数据，我们可以借助 flash 来发送 HTTP 请求。</p>\n<ol>\n<li>修改域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上的 crossdomain.xml (一般存放在根目录，如果没有需要手动创建) ，把 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 加入到白名单。</li>\n<li>通过 Flash URLLoader 发送 HTTP 请求。</li>\n<li>通过 Flash API 把响应结果传递给 JavaScript。</li>\n</ol>\n<p>缺点：不支持 IOS</p>\n<h3 id=\"三、Access-Control\"><a href=\"#三、Access-Control\" class=\"headerlink\" title=\"三、Access Control\"></a>三、Access Control</h3><p>Access Control 是比较超越的跨域方式，浏览器可以发送一个跨域的 HTTP 请求（Firefox, Google Chrome等通过 XMLHTTPRequest 实现，IE8 通过 XDomainRequest 实现），请求的响应必须包含一个 Access-Control-Allow-Origin 的 HTTP 响应头，该响应头声明了请求域的可访问权限。</p>\n<p>例子：<br><a href=\"http://www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头\" target=\"_blank\" rel=\"noopener\">www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头</a></p>\n<p>缺点：目前只在很少的浏览器中得以支持，</p>\n<h3 id=\"四、window-name\"><a href=\"#四、window-name\" class=\"headerlink\" title=\"四、window.name\"></a>四、window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。</p>\n<p>例子：<br>在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。</p>\n<p>优点：适合单项数据流，协议简单、安全，不会像JSONP那样不做限制地执行外部脚本。</p>\n<h3 id=\"五、server-proxy\"><a href=\"#五、server-proxy\" class=\"headerlink\" title=\"五、server proxy\"></a>五、server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>\n<p>例子：<br>当 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 域下的页面需要请求 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的资源文件 asset.txt 时，直接发送一个指向 <a href=\"http://www.b.com/asset.txt\" target=\"_blank\" rel=\"noopener\">www.b.com/asset.txt</a> 的 Ajax 请求肯定是会被浏览器阻止。这时，我们在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下配一个代理，然后把 Ajax 请求绑定到这个代理路径下，例如 <a href=\"http://www.a.com/proxy/\" target=\"_blank\" rel=\"noopener\">www.a.com/proxy/</a> , 然后这个代理发送 HTTP 请求访问 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 下的 asset.txt ，跨域的 HTTP 请求是在服务器端进行的，客户端并没有产生跨域的 Ajax 请求。</p>\n<p>注意：这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</p>\n<h2 id=\"双向跨域\"><a href=\"#双向跨域\" class=\"headerlink\" title=\"双向跨域\"></a>双向跨域</h2><h3 id=\"一、document-domain\"><a href=\"#一、document-domain\" class=\"headerlink\" title=\"一、document.domain\"></a>一、document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。</p>\n<p>例子：<br>同域策略认为域和子域隶属于不同的域，比如 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 和 sub.a.com 是不同的域，这时，我们无法在 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 下的页面中调用 sub.a.com 中定义的 JavaScript 方法。但是当我们把它们 document 的 domain 属性都修改为 a.com ，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method 来通信了。</p>\n<h3 id=\"二、FIM-–-Fragment-Identitier-Messaging\"><a href=\"#二、FIM-–-Fragment-Identitier-Messaging\" class=\"headerlink\" title=\"二、FIM – Fragment Identitier Messaging\"></a>二、FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript 只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。<br>FIM (Fragment Identitier Messaging) 就是在这个大前提下被发明的。父窗口可以对 iframe 进行 URL 读写，iframe 也可以读写父窗口的 URL ，URL 有一部分被称为 frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server 端并不关心这部分，应该说HTTP请求过程中不会携带 frag，所以这部分的修改不会产生 HTTP 请求，但是会产生浏览器历史记录。FIM 的原理就是改变 URL 的 frag 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息，并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，URL 在浏览器下有长度限制，这个制约了每次传送的数据量。</p>\n<h3 id=\"三、Flash-LocalConnection\"><a href=\"#三、Flash-LocalConnection\" class=\"headerlink\" title=\"三、Flash LocalConnection\"></a>三、Flash LocalConnection</h3><p>页面上的双向通信也可以通过 Flash 来解决，Flash API 中有 LocalConnection 这个类，该类允许两个 SWF 之间通过进程通信，这时 SWF 可以播放在独立的 Flash Player 或者 AIR 中，也可以嵌在 html 页面或者是 PDF 中。遵循这个通信原则，我们可以在不同域的 HTML 页面各自嵌套一个 SWF 来达到相互传递数据的目的了。SWF 通过 LocalConnection 交换数据是很快的，但是每次的数据量有 40kb 的大小限制。用这种方式来跨域通信过于复杂，而且需要了 2 个 SWF 文件，实用性不强。</p>\n<h3 id=\"四、window-postMessage\"><a href=\"#四、window-postMessage\" class=\"headerlink\" title=\"四、window.postMessage\"></a>四、window.postMessage</h3><p>window.postMessage 是 html5 定义的一个很新的方法，这个方法可以很方便地跨 window 通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>\n<h3 id=\"五、Cross-Frame\"><a href=\"#五、Cross-Frame\" class=\"headerlink\" title=\"五、Cross Frame\"></a>五、Cross Frame</h3><p>Cross Frame 是 FIM 的一个变种，它借助了一个空白的 iframe ，不会产生多余的浏览器历史记录，也不需要轮询 URL 的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> 上有页面 A.html 和一个空白代理页面 proxyA.html , 另一个域 <a href=\"http://www.b.com\" target=\"_blank\" rel=\"noopener\">www.b.com</a> 上有个页面 B.html 和一个空白代理页面 proxyB.html，A.html 需要向 B.html 中发送消息时，页面会创建一个隐藏的 iframe, iframe 的 src 指向 proxyB.html 并把 message 作为 URL frag，由于 B.html 和 proxyB.html 是同域，所以在 iframe 加载完成之后，B.html 可以获得 iframe 的 URL，然后解析出 message，并移除该 iframe。当 B.html 需要向 A.html 发送消息时，原理一样。Cross Frame 是很好的双向通信方式，而且安全高效，但是它在 Opera 中无法使用，不过在 Opera 下面我们可以使用更简单的 window.postMessage 来代替。</p>\n<p>不同的跨域请求可以使用不同的方式解决</p>\n<p>原文链接：<a href=\"http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjkahyd6d0001nzz9focojiul","category_id":"cjkahyd6j0004nzz94fkzxgf1","_id":"cjkahyd6o000bnzz9jrsz2l6q"},{"post_id":"cjkahyd6h0003nzz9roia89ev","category_id":"cjkahyd6j0004nzz94fkzxgf1","_id":"cjkahyd6p000enzz9q5d6j3sl"},{"post_id":"cjkahyd6j0005nzz940656xbw","category_id":"cjkahyd6o000anzz999r2wxey","_id":"cjkahyd6q000gnzz914jdkay7"},{"post_id":"cjkahyd7n000inzz9gbe4372i","category_id":"cjkahyd7s000mnzz9nkcel7ms","_id":"cjkahyd83000ynzz9wu0hho5b"},{"post_id":"cjkahyd7w000qnzz9k3wt4z9y","category_id":"cjkahyd7s000mnzz9nkcel7ms","_id":"cjkahyd850011nzz9kgidsim2"},{"post_id":"cjkahyd7t000onzz9oau0i1go","category_id":"cjkahyd7s000mnzz9nkcel7ms","_id":"cjkahyd870013nzz9z6o0lkhd"},{"post_id":"cjkahyd840010nzz90i9ezsu8","category_id":"cjkahyd7s000mnzz9nkcel7ms","_id":"cjkahyd8a0017nzz906wozlxo"},{"post_id":"cjkahyd7v000pnzz9j8lz4ffp","category_id":"cjkahyd83000xnzz9iyz16ao6","_id":"cjkahyd8b0019nzz95ovpj3v1"},{"post_id":"cjkahyd880016nzz9crk41rtp","category_id":"cjkahyd7s000mnzz9nkcel7ms","_id":"cjkahyd8c001bnzz9779vgwg8"},{"post_id":"cjkahyd81000wnzz9c05k8511","category_id":"cjkahyd870014nzz94mk5p945","_id":"cjkahyd8d001enzz909udnym3"}],"PostTag":[{"post_id":"cjkahyd670000nzz91bhq52fc","tag_id":"cjkahyd6f0002nzz92jvs1kp2","_id":"cjkahyd6l0007nzz9yb38lxik"},{"post_id":"cjkahyd6d0001nzz9focojiul","tag_id":"cjkahyd6l0006nzz90skzkgbo","_id":"cjkahyd6p000cnzz92aa03eq3"},{"post_id":"cjkahyd6h0003nzz9roia89ev","tag_id":"cjkahyd6l0006nzz90skzkgbo","_id":"cjkahyd6p000fnzz9iabzwo8r"},{"post_id":"cjkahyd6j0005nzz940656xbw","tag_id":"cjkahyd6p000dnzz9aeni3w3k","_id":"cjkahyd6q000hnzz9cpi5soei"},{"post_id":"cjkahyd7v000pnzz9j8lz4ffp","tag_id":"cjkahyd6f0002nzz92jvs1kp2","_id":"cjkahyd7z000tnzz9qu2b3nf0"},{"post_id":"cjkahyd7n000inzz9gbe4372i","tag_id":"cjkahyd7s000nnzz9mmfeyr9o","_id":"cjkahyd80000vnzz9zzvy3d48"},{"post_id":"cjkahyd7q000knzz94wxq6wg9","tag_id":"cjkahyd7y000snzz9jsjshgkk","_id":"cjkahyd8b001anzz9gvytyxv9"},{"post_id":"cjkahyd7q000knzz94wxq6wg9","tag_id":"cjkahyd7s000nnzz9mmfeyr9o","_id":"cjkahyd8c001cnzz99xpmkyf4"},{"post_id":"cjkahyd7q000knzz94wxq6wg9","tag_id":"cjkahyd870015nzz96gpxmnyi","_id":"cjkahyd8d001fnzz9craqh1fu"},{"post_id":"cjkahyd7t000onzz9oau0i1go","tag_id":"cjkahyd7s000nnzz9mmfeyr9o","_id":"cjkahyd8d001gnzz9nwm11i5e"},{"post_id":"cjkahyd7w000qnzz9k3wt4z9y","tag_id":"cjkahyd7s000nnzz9mmfeyr9o","_id":"cjkahyd8e001inzz9cdrejewm"},{"post_id":"cjkahyd7w000qnzz9k3wt4z9y","tag_id":"cjkahyd870015nzz96gpxmnyi","_id":"cjkahyd8f001jnzz9wh13m7cb"},{"post_id":"cjkahyd7z000unzz98621q3ur","tag_id":"cjkahyd8d001hnzz9padjcngn","_id":"cjkahyd8g001lnzz9spmd02ai"},{"post_id":"cjkahyd7z000unzz98621q3ur","tag_id":"cjkahyd7s000nnzz9mmfeyr9o","_id":"cjkahyd8g001mnzz9gq4plxuv"},{"post_id":"cjkahyd81000wnzz9c05k8511","tag_id":"cjkahyd8f001knzz9ospsy96r","_id":"cjkahyd8h001onzz9bno68g6w"},{"post_id":"cjkahyd840010nzz90i9ezsu8","tag_id":"cjkahyd8h001nnzz92vlvjcza","_id":"cjkahyd8i001qnzz95s1x4b0e"},{"post_id":"cjkahyd860012nzz9596a4xz4","tag_id":"cjkahyd8i001pnzz9tejaz2m0","_id":"cjkahyd8j001snzz9rpco4j80"},{"post_id":"cjkahyd880016nzz9crk41rtp","tag_id":"cjkahyd8h001nnzz92vlvjcza","_id":"cjkahyd8j001tnzz9ph01zg0t"}],"Tag":[{"name":"html","_id":"cjkahyd6f0002nzz92jvs1kp2"},{"name":"git","_id":"cjkahyd6l0006nzz90skzkgbo"},{"name":"hexo","_id":"cjkahyd6p000dnzz9aeni3w3k"},{"name":"js","_id":"cjkahyd7s000nnzz9mmfeyr9o"},{"name":"nextjs","_id":"cjkahyd7y000snzz9jsjshgkk"},{"name":"css","_id":"cjkahyd870015nzz96gpxmnyi"},{"name":"react","_id":"cjkahyd8d001hnzz9padjcngn"},{"name":"package.json","_id":"cjkahyd8f001knzz9ospsy96r"},{"name":"跨域","_id":"cjkahyd8h001nnzz92vlvjcza"},{"name":"浏览器","_id":"cjkahyd8i001pnzz9tejaz2m0"}]}}